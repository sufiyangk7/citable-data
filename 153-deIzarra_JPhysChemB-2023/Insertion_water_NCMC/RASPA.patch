From 0770c7f003ed3682c6046ebb1b715f9ea35ecbd8 Mon Sep 17 00:00:00 2001
From: AmbredeIzz <99361427+AmbredeIzz@users.noreply.github.com>
Date: Fri, 15 Sep 2023 18:20:39 +0200
Subject: [PATCH] Adapted NCMC move to insert 2 water molecules in bulk water

Modified version of RASPA2, where the the NCMC move is adapted to insert
2 water molecules in bulk water, which we use for the calculation of
free energy of water solvation.

See the associated publication at https://doi.org/10.1021/acs.jpcb.2c07902
for more details.
---
 src/Alchemical_transformation.c | 4472 +++++++++++++++++++++++++++++++
 src/Alchemical_transformation.h |  130 +
 src/cbmc.c                      |  154 +-
 src/cbmc.h                      |   74 +-
 src/constants.c                 |   21 +
 src/constants.h                 |    4 +
 src/framework.c                 |  340 ++-
 src/framework.h                 |   23 +
 src/input.c                     |  132 +-
 src/mc_moves.c                  | 2148 ++++++++++++++-
 src/mc_moves.h                  |   36 +
 src/molecule.c                  |  406 ++-
 src/molecule.h                  |   16 +
 src/monte_carlo.c               |   85 +-
 src/run.c                       |   30 +-
 src/simulation.c                |   35 +
 src/simulation.h                |   28 +-
 src/statistics.c                |   67 +-
 src/warnings.c                  |   30 +
 19 files changed, 8010 insertions(+), 221 deletions(-)
 create mode 100644 src/Alchemical_transformation.c
 create mode 100644 src/Alchemical_transformation.h

diff --git a/src/Alchemical_transformation.c b/src/Alchemical_transformation.c
new file mode 100644
index 0000000..0c66cfb
--- /dev/null
+++ b/src/Alchemical_transformation.c
@@ -0,0 +1,4472 @@
+// Alchemical_transformation.c Added by Ambroise de Izarra
+/*  
+ * Alchemical transformation is added to build functions that peform
+ * an alchemical transformation at a fixed number of particule in the system (osmotic ensemble)
+ */ 
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+#include <stdio.h>
+#include <stdlib.h>
+#include <math.h>
+#include <float.h>
+#include <stdbool.h>
+#include <time.h>
+#include <string.h>
+#include <ctype.h>
+#include <sys/stat.h>
+#include "Alchemical_transformation.h"
+#include "framework_energy.h"
+#include "molecule.h"
+#include "framework.h"
+#include "simulation.h"
+#include "ewald.h"
+#include "potentials.h"
+#include "utils.h"
+#include "output.h"
+#include "input.h"
+#include "cbmc.h"
+#include "mc_moves.h"
+#include "ewald.h"
+#include "grids.h"
+#include "spacegroup.h"
+#include "recrossing.h"
+#include "movies.h"
+#include "utils.h"
+#include "sample.h"
+#include "spectra.h"
+#include "rigid.h"
+#include "integration.h"
+#include "statistics.h"
+#include "thermo_baro_stats.h"
+#include "equations_of_state.h"
+#include "inter_energy.h"
+#include "minimization.h"
+#include "scattering_factors.h"
+#include "framework_force.h"
+#include "warnings.h"
+#include "internal_force.h"
+#include "status.h"
+#include "charge_equilibration.h"
+
+static REAL (**VectorforMixingRuleAlchemicalTransformation)[2];
+static REAL (**VectorChargeAlchemicalTransformation);
+
+int InitialPseudoAtoms;
+int NumberExtraPseudoAtoms;
+int NumberExtraComponents;
+int CurrentAlchemicalReaction;
+int IndexExtraComponent[2];
+int TransientMoleculeNbAtoms;
+static REAL RosenbluthNew;             // the new Rosenbluth weight (grow)
+static REAL RosenbluthOld; 
+
+// Save in memory initial coordinates of chosen moities 
+ADSORBATE_MOLECULE *AdsorbatesReferenceChosen;
+VECTOR **SolventBodyfixedPositions; // the positions in the body-fixed frame to be stored.
+
+// Save in memory initial NumberofPseudoType tables.
+int **NumberOfPseudoAtomsReferenceType;
+int *NumberOfPseudoAtomsReferenceTypeNew;
+int *NumberOfPseudoAtomsReferenceTypeOld;
+
+// Save in memory the degree of freedom
+int DegreesOfFreedomReferenceAdsorbates;
+int DegreesOfFreedomReferenceTranslation;
+int DegreesOfFreedomReferenceTranslationalAdsorbates;
+int DegreesOfFreedomReference;
+                                  
+int DegreesOfFreedomReferenceRotation;
+int DegreesOfFreedomReferenceAdsorbates;
+int DegreesOfFreedomReferenceRotationalAdsorbates;
+
+// Declare the chemical potential os the osmostat.
+REAL *AlchemicalWorkStore;
+REAL *AlchemicalWorkStore_vdw;
+REAL *AlchemicalWorkStore_elec;
+int SizeAlchemicalWorkStore;
+
+// for the NVE move during the Alchemical transformation.
+REAL *HybridNVEAlchDrift;
+REAL *HybridNVEAlchDriftCount;
+
+REAL *HybridNVEAlchStartTemperature;
+REAL *HybridNVEAlchStartTranslationalTemperature;
+REAL *HybridNVEAlchStartRotationalTemperature;
+REAL *HybridNVEAlchStartTemperatureFramework;
+REAL *HybridNVEAlchStartTemperatureAdsorbate;
+REAL *HybridNVEAlchStartTemperatureCation;
+REAL *HybridNVEAlchStartTemperatureCount;
+REAL *HybridNVEAlchStartTemperatureTranslationCount;
+REAL *HybridNVEAlchStartTemperatureRotationCount;
+REAL *HybridNVEAlchStartTemperatureFrameworkCount;
+REAL *HybridNVEAlchStartTemperatureAdsorbateCount;
+REAL *HybridNVEAlchStartTemperatureCationCount;
+
+REAL *HybridNVEAlchEndTemperature;
+REAL *HybridNVEAlchEndTranslationalTemperature;
+REAL *HybridNVEAlchEndRotationalTemperature;
+REAL *HybridNVEAlchEndTemperatureFramework;
+REAL *HybridNVEAlchEndTemperatureAdsorbate;
+REAL *HybridNVEAlchEndTemperatureCation;
+REAL *HybridNVEAlchEndTemperatureCount;
+REAL *HybridNVEAlchEndTemperatureTranslationCount;
+REAL *HybridNVEAlchEndTemperatureRotationCount;
+REAL *HybridNVEAlchEndTemperatureFrameworkCount;
+REAL *HybridNVEAlchEndTemperatureAdsorbateCount;
+REAL *HybridNVEAlchEndTemperatureCationCount;
+
+// We'll need the energy before and after the set up of the transient molecules.
+static REAL EnergyHostVDWFirstBead;
+static REAL EnergyAdsorbateVDWFirstBead;
+static REAL EnergyCationVDWFirstBead;
+static REAL EnergyHostChargeChargeFirstBead;
+static REAL EnergyAdsorbateChargeChargeFirstBead;
+static REAL EnergyCationChargeChargeFirstBead;
+static REAL EnergyHostChargeBondDipoleFirstBead;
+static REAL EnergyAdsorbateChargeBondDipoleFirstBead;
+static REAL EnergyCationChargeBondDipoleFirstBead;
+static REAL EnergyHostBondDipoleBondDipoleFirstBead;
+static REAL EnergyAdsorbateBondDipoleBondDipoleFirstBead;
+static REAL EnergyCationBondDipoleBondDipoleFirstBead;
+
+// We adapt the Handlefirstbead of cbmc.c to Initialize first beads of transient component.
+static void ManageFirstBead(int start);
+static void ManageRemainingBeads(int NumberOldComponent);
+
+// File to write Alchemical work thorugh MC.
+FILE *OutputOsmostatFilePtr;
+
+/*********************************************************************************************************
+ * Name       | InitializeStoreAlchemicalWork   (Added by A. de Izarra)                                  *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize vector to store Alchemical work.                      						 *
+ * Parameters | No parameters											                                 *
+ *********************************************************************************************************/
+void InitializeStoreAlchemicalWork(void)
+{
+	SizeAlchemicalWorkStore=0;
+	AlchemicalWorkStore=(REAL*)calloc(SizeAlchemicalWorkStore,sizeof(REAL));
+	AlchemicalWorkStore_vdw=(REAL*)calloc(SizeAlchemicalWorkStore,sizeof(REAL));
+	AlchemicalWorkStore_elec=(REAL*)calloc(SizeAlchemicalWorkStore,sizeof(REAL));
+}
+
+/*********************************************************************************************************
+ * Name       | IncreaseSizeAlchemicalWork      (Added by A. de Izarra)                                  *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Increase size of vector to store Alchemical work on the fly.                           	 *
+ * Parameters | No parameters											                                 *
+ *********************************************************************************************************/
+void IncreaseSizeAlchemicalWork(void)
+{
+	AlchemicalWorkStore=(REAL*)realloc(AlchemicalWorkStore,SizeAlchemicalWorkStore*sizeof(REAL));
+	AlchemicalWorkStore_vdw=(REAL*)realloc(AlchemicalWorkStore_vdw,SizeAlchemicalWorkStore*sizeof(REAL));
+	AlchemicalWorkStore_elec=(REAL*)realloc(AlchemicalWorkStore_elec,SizeAlchemicalWorkStore*sizeof(REAL));
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeFileAlchemicalWork      (Added by A. de Izarra)                                *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize vector to store Alchemical work.                        					 	 *
+ * Parameters | int Size => Number of file to store Alchemical work (=1)								 *										                                 		 *
+ *********************************************************************************************************/
+void InitializeFileAlchemicalWork(int Size)
+{	
+	int i;
+		
+	if(ContinueAfterCrash==FALSE) 
+	{
+		OutputOsmostatFilePtr=fopen("AlchemicalWork.txt","w");
+		fprintf(OutputOsmostatFilePtr,"Widom_step\t\tAlchemical_work(k)\t\tAlchemical_work(kJ/mol)\t\tAlchemical_work_elec(k)\t\tAlchemical_work_elec(kJ/mol)\t\tAlchemical_work_vdw(k)\t\tAlchemical_work_vdw(kJ/mol)\n");	
+		fflush(OutputOsmostatFilePtr);
+	}
+	else
+	{
+		// Read the osmostat file.
+		FILE * BufferOutputOsmostatFilePtr = fopen("AlchemicalWorkbuffer.txt","w");
+		OutputOsmostatFilePtr=fopen("AlchemicalWork.txt","r");
+		
+		char line[10000];
+			
+		for(i=0;i<=Size;i++)
+		{
+		  fgets(line,10000,OutputOsmostatFilePtr);
+		  fprintf(BufferOutputOsmostatFilePtr,"%s",line);
+		}	
+
+		fclose(BufferOutputOsmostatFilePtr);
+		fclose(OutputOsmostatFilePtr);
+		
+		remove("AlchemicalWork.txt");
+		rename("AlchemicalWorkbuffer.txt","AlchemicalWork.txt");
+		
+		OutputOsmostatFilePtr=fopen("AlchemicalWork.txt","a");
+	}		
+}
+
+/*********************************************************************************************************
+ * Name       | UpdateFileAlchemicalWork      (Added by A. de Izarra)                                    *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Print in file FilePtr the index-th alchemical work and contribution from elec + vdw.     *                     					 
+ * Parameters | int index => index of the computed alchemical potential									 *
+ * 			  | FILE *FilePtr => Pointer to File (AlchemicalWork.txt)							 		 *
+ *********************************************************************************************************/
+void UpdateFileAlchemicalWork(int index, FILE *FilePtr)
+{
+	fprintf(FilePtr,"%d\t\t%lf\t\t%lf\t\t%lf\t\t%lf\t\t%lf\t\t%lf\n",index,
+			AlchemicalWorkStore[index]*ENERGY_TO_KELVIN,AlchemicalWorkStore[index]*ENERGY_TO_KELVIN*KELVIN_TO_KJ_PER_MOL,
+			AlchemicalWorkStore_elec[index]*ENERGY_TO_KELVIN,AlchemicalWorkStore_elec[index]*ENERGY_TO_KELVIN*KELVIN_TO_KJ_PER_MOL,
+			AlchemicalWorkStore_vdw[index]*ENERGY_TO_KELVIN,AlchemicalWorkStore_vdw[index]*ENERGY_TO_KELVIN*KELVIN_TO_KJ_PER_MOL);
+	fflush(OutputOsmostatFilePtr);
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeNVEAlchStatistics     (Added by A. de Izarra)                                  *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize Statistics for the NVE MD during NCMC move.								     *                     					 
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void InitializeNVEAlchStatistics(void)
+{
+  int i;	
+	
+  HybridNVEAlchDrift=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchDriftCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+
+  HybridNVEAlchStartTemperature=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTranslationalTemperature=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartRotationalTemperature=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureFramework=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureAdsorbate=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureCation=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureTranslationCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureRotationCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureFrameworkCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureAdsorbateCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchStartTemperatureCationCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+
+  HybridNVEAlchEndTemperature=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTranslationalTemperature=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndRotationalTemperature=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureFramework=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureAdsorbate=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureCation=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureTranslationCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureRotationCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureFrameworkCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureAdsorbateCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  HybridNVEAlchEndTemperatureCationCount=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  
+  for(i=0;i<NumberOfSystems;i++)
+  {
+		HybridNVEAlchDrift[i]=0.0;
+		HybridNVEAlchDriftCount[i]=0.0;
+
+		HybridNVEAlchStartTemperature[i]=0.0;
+		HybridNVEAlchStartTranslationalTemperature[i]=0.0;
+		HybridNVEAlchStartRotationalTemperature[i]=0.0;
+		HybridNVEAlchStartTemperatureFramework[i]=0.0;
+		HybridNVEAlchStartTemperatureAdsorbate[i]=0.0;
+		HybridNVEAlchStartTemperatureCation[i]=0.0;
+		HybridNVEAlchStartTemperatureCount[i]=0.0;
+		HybridNVEAlchStartTemperatureTranslationCount[i]=0.0;
+		HybridNVEAlchStartTemperatureRotationCount[i]=0.0;
+		HybridNVEAlchStartTemperatureFrameworkCount[i]=0.0;
+		HybridNVEAlchStartTemperatureAdsorbateCount[i]=0.0;
+		HybridNVEAlchStartTemperatureCationCount[i]=0.0;
+
+		HybridNVEAlchEndTemperature[i]=0.0;
+		HybridNVEAlchEndTranslationalTemperature[i]=0.0;
+		HybridNVEAlchEndRotationalTemperature[i]=0.0;
+		HybridNVEAlchEndTemperatureFramework[i]=0.0;
+		HybridNVEAlchEndTemperatureAdsorbate[i]=0.0;
+		HybridNVEAlchEndTemperatureCation[i]=0.0;
+		HybridNVEAlchEndTemperatureCount[i]=0.0;
+		HybridNVEAlchEndTemperatureTranslationCount[i]=0.0;
+		HybridNVEAlchEndTemperatureRotationCount[i]=0.0;
+		HybridNVEAlchEndTemperatureFrameworkCount[i]=0.0;
+		HybridNVEAlchEndTemperatureAdsorbateCount[i]=0.0;
+		HybridNVEAlchEndTemperatureCationCount[i]=0.0;
+  }
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeIndexManagingTransientMoities      (Added by A. de Izarra)                     *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize index of the molecules that undergo alchemical transformation.				 *                     					 
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void InitializeIndexManagingTransientMoities(void)
+{
+	// The number of extra components.
+	NumberExtraComponents = 2;
+	// The number of extra pseudoatoms.
+	NumberExtraPseudoAtoms = 2*Components[SolventIndex].NumberOfAtoms;
+	
+	// The number of initial pseudo atoms.
+	InitialPseudoAtoms = NumberOfPseudoAtoms;
+	
+	// Save new transient component index
+    IndexExtraComponent[0]=NumberOfComponents;
+    IndexExtraComponent[1]=NumberOfComponents+1;
+    
+    // Store the number of atoms of a transient molecule.
+    TransientMoleculeNbAtoms = Components[SolventIndex].NumberOfAtoms; 
+    
+    // Conversion of alchemical potenial in RASPA internal units.
+    ChemicalPotentialAlchemical *= KJ_PER_MOL_TO_ENERGY;
+}
+
+/*********************************************************************************************************
+ * Name       | AddExtraPseudoAtoms      (Added by A. de Izarra)                                   		 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Add the extra pseudo atoms belonging to the molecules that 								 *
+ * 			  | undergo alchemical transformation.													     *                     					 
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void AddExtraPseudoAtoms(void)
+{       
+	int i,j;
+
+	// Allocate memory to store extra pseudoatoms of transient molecules.
+	PseudoAtoms=(PSEUDO_ATOM*)realloc(PseudoAtoms,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(PSEUDO_ATOM));
+  
+	if(!PseudoAtoms) 
+    {
+      printf("Memory reallocation error of 'PseudoAtoms' in 'molecule.c'\n");
+      exit(-1);
+    }
+
+    NumberOfPseudoAtomsTypeNew=(int*)realloc(NumberOfPseudoAtomsTypeNew,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+    if(!NumberOfPseudoAtomsTypeNew)
+    {
+      printf("Memory reallocation error of 'NumberOfPseudoAtomsTypeNew' in file %s line %d\n", __FILE__, __LINE__);
+      exit(-1);
+    }
+
+    NumberOfPseudoAtomsTypeOld=(int*)realloc(NumberOfPseudoAtomsTypeOld,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+    if(!NumberOfPseudoAtomsTypeOld)
+    {
+      printf("Memory reallocation error of 'NumberOfPseudoAtomsTypeOld' in file %s line %d\n", __FILE__, __LINE__);
+      exit(-1);
+    }
+
+
+    MapPseudoAtom=(int*)realloc(MapPseudoAtom,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+    if(!MapPseudoAtom)
+    {
+      printf("Memory reallocation error of 'MapPseudoAtom' in file %s line %d\n", __FILE__, __LINE__);
+      exit(-1);
+    }
+
+	for(j=InitialPseudoAtoms; j<InitialPseudoAtoms+NumberExtraPseudoAtoms; j++)
+	{
+		NumberOfPseudoAtomsTypeNew[j]=0;
+		NumberOfPseudoAtomsTypeOld[j]=0;
+		MapPseudoAtom[j]=0;		
+	}
+	
+    for(i=0;i<NumberOfSystems;i++)
+	{
+		 NumberOfPseudoAtomsCount[i]=(int*)realloc(NumberOfPseudoAtomsCount[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+		 if(!NumberOfPseudoAtomsCount[i])
+		 {
+		   printf("Memory reallocation error of 'NumberOfPseudoAtomsCount[i]'\n");
+		   exit(-1);
+		 }
+
+		 NumberOfPseudoAtomsType[i]=(int*)realloc(NumberOfPseudoAtomsType[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+		 if(!NumberOfPseudoAtomsType[i])
+		 {
+		   printf("Memory reallocation error of 'NumberOfPseudoAtomsType[i]'\n");
+		   exit(-1);
+		 }
+
+		 NumberOfFractionalPseudoAtomsType[i]=(int*)realloc(NumberOfFractionalPseudoAtomsType[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+		 if(!NumberOfFractionalPseudoAtomsType[i])
+		 {
+		   printf("Memory reallocation error of 'NumberOfFractionalPseudoAtomsType[i]'\n");
+		   exit(-1);
+		 }
+		 
+		 for(j=InitialPseudoAtoms; j<InitialPseudoAtoms+NumberExtraPseudoAtoms; j++)
+		 {
+			 NumberOfPseudoAtomsCount[i][j]=0;
+			 NumberOfPseudoAtomsType[i][j]=0;
+			 NumberOfFractionalPseudoAtomsType[i][j]=0;
+		 }  
+	}
+	
+ 
+    // For the new pseudoatom of transient molecules, assign its characteristics
+    int Index;
+    int atom_count;
+    char index_salt_store[10];
+    int comp;
+   
+    // The number of pseudo component to be present in the system
+    for(comp=0;comp<2;comp++)
+	{
+		atom_count = -1;
+		Index = (InitialPseudoAtoms) + comp*(Components[SolventIndex].NumberOfAtoms);
+		for(i=Index;i<Index+Components[SolventIndex].NumberOfAtoms;i++)
+		{
+			atom_count++; 
+			strcpy(PseudoAtoms[i].Name,"TransientAtom");
+			sprintf(index_salt_store,"%d",IndexExtraComponent[comp]);
+			strcat(PseudoAtoms[i].Name,index_salt_store);
+			strcat(PseudoAtoms[i].Name,"-");
+			sprintf(index_salt_store,"%d",atom_count);
+			strcat(PseudoAtoms[i].Name,index_salt_store);
+			strcpy(PseudoAtoms[i].ChemicalElement,PseudoAtoms[i].Name);
+			
+			strcpy(PseudoAtoms[i].OxidationStateString,PseudoAtoms[Components[SolventIndex].Type[atom_count]].OxidationStateString);
+			PseudoAtoms[i].OxidationState=PseudoAtoms[Components[SolventIndex].Type[atom_count]].OxidationState;
+			strcpy(PseudoAtoms[i].ScatteringSource,PseudoAtoms[Components[SolventIndex].Type[atom_count]].ScatteringSource);
+		    PseudoAtoms[i].Occupancy=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Occupancy;
+		    PseudoAtoms[i].FrameworkAtom=PseudoAtoms[Components[SolventIndex].Type[atom_count]].FrameworkAtom; // This is not framework atom
+		    PseudoAtoms[i].PrintToPDB=FALSE;
+		    PseudoAtoms[i].ScatteringType=PseudoAtoms[Components[SolventIndex].Type[atom_count]].ScatteringType;
+		    PseudoAtoms[i].AnomalousScatteringType=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnomalousScatteringType;
+		    PseudoAtoms[i].TemperatureFactor=PseudoAtoms[Components[SolventIndex].Type[atom_count]].TemperatureFactor;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.ax=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.ax;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.ay=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.ay;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.az=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.az;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.bx=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.bx;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.by=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.by;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.bz=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.bz;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.cx=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.cx;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.cy=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.cy;
+		    PseudoAtoms[i].AnisotropicTemperatureFactor.cz=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicTemperatureFactor.cz;
+		    PseudoAtoms[i].ScatteringDispersionImaginary=PseudoAtoms[Components[SolventIndex].Type[atom_count]].ScatteringDispersionImaginary;
+		    PseudoAtoms[i].Mass=0; // To be assigned in another function.
+		    PseudoAtoms[i].Charge1=0; // To be assigned in another function.
+		    PseudoAtoms[i].ChargeDefinitionType=PseudoAtoms[Components[SolventIndex].Type[atom_count]].ChargeDefinitionType;
+		    PseudoAtoms[i].Polarization.ax=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.ax;
+		    PseudoAtoms[i].Polarization.ay=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.ay;
+		    PseudoAtoms[i].Polarization.az=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.az;
+		    PseudoAtoms[i].Polarization.bx=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.bx;
+		    PseudoAtoms[i].Polarization.by=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.by;
+		    PseudoAtoms[i].Polarization.bz=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.bz;
+		    PseudoAtoms[i].Polarization.cx=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.cx;
+		    PseudoAtoms[i].Polarization.cy=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.cy;
+		    PseudoAtoms[i].Polarization.cz=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Polarization.cz;
+		    PseudoAtoms[i].HasCharges=TRUE; // Always has charge.
+		    PseudoAtoms[i].IsPolarizable=PseudoAtoms[Components[SolventIndex].Type[atom_count]].IsPolarizable;
+		    PseudoAtoms[i].Interaction=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Interaction;
+		    PseudoAtoms[i].Radius=1.0; // TO be assigned in another function.
+		    PseudoAtoms[i].Connectivity=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Connectivity;
+		    PseudoAtoms[i].TinkerType=PseudoAtoms[Components[SolventIndex].Type[atom_count]].TinkerType;
+		    PseudoAtoms[i].AnisotropicCorrection=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicCorrection;
+		    PseudoAtoms[i].AnisotropicDisplacement=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicDisplacement;
+		    PseudoAtoms[i].AnisotropicType=PseudoAtoms[Components[SolventIndex].Type[atom_count]].AnisotropicType;
+		    PseudoAtoms[i].HasVDWInteraction=PseudoAtoms[Components[SolventIndex].Type[atom_count]].HasVDWInteraction;
+		    PseudoAtoms[i].Hybridization=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Hybridization;
+		    PseudoAtoms[i].CF=PseudoAtoms[Components[SolventIndex].Type[atom_count]].CF;
+		    
+		}
+    }	
+    
+   NumberOfPseudoAtoms=InitialPseudoAtoms+NumberExtraPseudoAtoms;
+}
+
+
+void GrowTransient(int NumberOldComponent)
+{
+  int j,start;
+  REAL UVDWCorrectionAdsorbate,UVDWCorrectionCation;
+  REAL UVDWCorrectionFramework,UVDWCorrectionReplicasNew;
+  REAL UChargeChargeCorrectionReplicasNew;
+
+  UBondNew[CurrentSystem]=0.0;
+  UBendNew[CurrentSystem]=0.0;
+  UBendBendNew[CurrentSystem]=0.0;
+  UInversionBendNew[CurrentSystem]=0.0;
+  UUreyBradleyNew[CurrentSystem]=0.0;
+  UTorsionNew[CurrentSystem]=0.0;
+  UImproperTorsionNew[CurrentSystem]=0.0;
+  UBondBondNew[CurrentSystem]=0.0;
+  UBondBendNew[CurrentSystem]=0.0;
+  UBondTorsionNew[CurrentSystem]=0.0;
+  UBendTorsionNew[CurrentSystem]=0.0;
+  UIntraVDWNew[CurrentSystem]=0.0;
+  UIntraChargeChargeNew[CurrentSystem]=0.0;
+  UIntraChargeBondDipoleNew[CurrentSystem]=0.0;
+  UIntraBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+
+  UHostVDWNew[CurrentSystem]=0.0;
+  UAdsorbateVDWNew[CurrentSystem]=0.0;
+  UCationVDWNew[CurrentSystem]=0.0;
+  UHostChargeChargeNew[CurrentSystem]=0.0;
+  UAdsorbateChargeChargeNew[CurrentSystem]=0.0;
+  UCationChargeChargeNew[CurrentSystem]=0.0;
+  UHostChargeBondDipoleNew[CurrentSystem]=0.0;
+  UAdsorbateChargeBondDipoleNew[CurrentSystem]=0.0;
+  UCationChargeBondDipoleNew[CurrentSystem]=0.0;
+  UHostBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+  UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+  UCationBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+
+  RosenbluthNew=1.0;
+  OVERLAP=FALSE;
+
+  if(NumberOfBeadsAlreadyPlaced==0)
+  {
+	start=Components[CurrentComponent].StartingBead;
+	FirstBeadPosition=NewPosition[CurrentSystem][start];
+	
+    ManageFirstBead(start);
+
+    UCationVDWNew[CurrentSystem]=EnergyCationVDWFirstBead;
+    UAdsorbateVDWNew[CurrentSystem]=EnergyAdsorbateVDWFirstBead;
+    UHostVDWNew[CurrentSystem]=EnergyHostVDWFirstBead;
+
+    UCationChargeChargeNew[CurrentSystem]=EnergyCationChargeChargeFirstBead;
+    UAdsorbateChargeChargeNew[CurrentSystem]=EnergyAdsorbateChargeChargeFirstBead;
+    UHostChargeChargeNew[CurrentSystem]=EnergyHostChargeChargeFirstBead;
+
+    UCationChargeBondDipoleNew[CurrentSystem]=EnergyCationChargeBondDipoleFirstBead;
+    UAdsorbateChargeBondDipoleNew[CurrentSystem]=EnergyAdsorbateChargeBondDipoleFirstBead;
+    UHostChargeBondDipoleNew[CurrentSystem]=EnergyHostChargeBondDipoleFirstBead;
+
+    UCationBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+    UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+    UHostBondDipoleBondDipoleNew[CurrentSystem]=0.0;
+
+    NumberOfBeadsAlreadyPlaced=1;
+  }
+
+  if(Components[CurrentComponent].NumberOfAtoms>1)
+  {
+    ManageRemainingBeads(NumberOldComponent);
+  }
+
+  // copy coordinates for small MC-scheme
+  for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+  {
+    Components[CurrentComponent].RMCMOL[j]=NewPosition[CurrentSystem][j];
+    TrialPosition[CurrentSystem][j]=NewPosition[CurrentSystem][j];
+  }
+
+  // calculate anisotropic sites
+  CalculateAnisotropicTrialPositions(CurrentComponent,TrialPosition[CurrentSystem],TrialAnisotropicPosition[CurrentSystem]);
+  UVDWCorrectionFramework=CalculateFrameworkVDWEnergyCorrection(TrialPosition[CurrentSystem],TrialAnisotropicPosition[CurrentSystem],CFVDWScaling);
+  UVDWCorrectionAdsorbate=CalculateInterVDWEnergyCorrectionAdsorbate(TrialPosition[CurrentSystem],TrialAnisotropicPosition[CurrentSystem],CurrentAdsorbateMolecule);
+  UVDWCorrectionCation=CalculateInterVDWEnergyCorrectionCation(TrialPosition[CurrentSystem],TrialAnisotropicPosition[CurrentSystem],CurrentCationMolecule);
+  RosenbluthNew*=exp(-Beta[CurrentSystem]*(UVDWCorrectionFramework+UVDWCorrectionAdsorbate+UVDWCorrectionCation));
+
+  UHostVDWNew[CurrentSystem]+=UVDWCorrectionFramework;
+  UAdsorbateVDWNew[CurrentSystem]+=UVDWCorrectionAdsorbate;
+  UCationVDWNew[CurrentSystem]+=UVDWCorrectionCation;
+
+  // correct for self-energy when using replica unit cells
+  UVDWCorrectionReplicasNew=CalculateInterVDWSelfEnergyCorrectionNew();
+  UChargeChargeCorrectionReplicasNew=CalculateInterChargeChargeSelfEnergyCorrectionNew();
+  if(Components[CurrentComponent].ExtraFrameworkMolecule)
+  {
+    UCationVDWNew[CurrentSystem]+=UVDWCorrectionReplicasNew;
+    UCationChargeChargeNew[CurrentSystem]+=UChargeChargeCorrectionReplicasNew;
+  }
+  else
+  {
+    UAdsorbateVDWNew[CurrentSystem]+=UVDWCorrectionReplicasNew;
+    UAdsorbateChargeChargeNew[CurrentSystem]+=UChargeChargeCorrectionReplicasNew;
+  }
+
+  // the old config can be used as a starting point
+  Components[CurrentComponent].LMCMOL=TRUE;
+}
+
+
+/*********************************************************************************************************
+ * Name       | MakeInitialTransient      (Added by A. de Izarra)                                    	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Construct the molecules that undergo alchemical transformation.				     		 *                     					 
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *												
+ *********************************************************************************************************/
+void MakeInitialTransient(int NumberOldComponent)
+{	
+  int Comp;
+  int NumberTransientMoities=-1;
+  int i,j;
+
+  REAL UTailNew;
+  REAL RosenbluthIdealNew;
+  REAL DeltaU;
+  
+  int StoredNumberOfTrialPositions;
+  int StoredNumberOfTrialPositionsFirstBead;
+
+  StoredNumberOfTrialPositions=NumberOfTrialPositions;
+  StoredNumberOfTrialPositionsFirstBead=NumberOfTrialPositionsForTheFirstBead;
+
+  for(Comp=0; Comp<NumberExtraComponents; Comp++)
+  {
+	    UpdateInertiaTensorGroups(IndexExtraComponent[Comp]);
+	    
+		for(i=0;i<MultiplicitySalt[CurrentAlchemicalReaction][Comp];i++)
+	    {  
+			NumberTransientMoities++;
+
+			// The current transient moities is added at the top of the adsorbates pile;
+			CurrentAdsorbateMolecule=NumberOfAdsorbateMolecules[CurrentSystem];
+			
+		    CurrentComponent=IndexExtraComponent[Comp];
+		    
+		    // set Continuous Fraction (CF) atomic scaling-factors to  unity (only integer molecules can be added here)
+			for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+			{
+				CFVDWScaling[j]=1.0;
+				CFChargeScaling[j]=1.0;
+			}
+
+			// There is no need to regrow the molecule: past water coordinates into the new transient component.
+			// water->ions
+			
+			NumberOfBeadsAlreadyPlaced=0;
+			NumberOfTrialPositions=NumberOfTrialPositionsSwap;
+			NumberOfTrialPositionsForTheFirstBead=NumberOfTrialPositionsForTheFirstBeadSwap;
+			
+			if(NumberOldComponent == 1)
+			{
+				// Paste in new position the coordinate of water.
+				for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+				{
+					NewPosition[CurrentSystem][j]=AdsorbatesReferenceChosen[NumberTransientMoities].Atoms[j].Position;
+				}
+			}
+			else
+			{
+				
+				// Try the position of ions is far enough from oxygen water		
+				POINT posA,posB,dr;
+				int a,b;
+				int IsWellSettled;
+				REAL r2;
+				
+				do
+				{
+					posA.x=RandomNumber();
+					posA.y=RandomNumber();
+					posA.z=RandomNumber();
+					
+					NewPosition[CurrentSystem][0]=ConvertFromABCtoXYZ(posA);
+				
+					int exclude = CurrentAdsorbateMolecule;
+					
+					IsWellSettled=1;
+					
+					for(a=0;a<NumberOfAdsorbateMolecules[CurrentSystem];a++)
+					{
+					  if(a!=exclude)
+					  {
+						  posB=Adsorbates[CurrentSystem][a].Atoms[0].AnisotropicPosition;
+			
+						  dr.x=NewPosition[CurrentSystem][0].x-posB.x;
+						  dr.y=NewPosition[CurrentSystem][0].y-posB.y;
+						  dr.z=NewPosition[CurrentSystem][0].z-posB.z;
+						  dr=ApplyBoundaryCondition(dr);
+						  r2=SQR(dr.x)+SQR(dr.y)+SQR(dr.z);
+
+						  if(r2<(3.16*3.16))
+						  {
+							IsWellSettled = 0;
+							break;
+						  }
+					  }
+					}
+				}while(IsWellSettled==0);
+				
+		
+				
+				for(j=1;j<Components[CurrentComponent].NumberOfAtoms;j++)
+				{
+					NewPosition[CurrentSystem][j].x=0.0;
+					NewPosition[CurrentSystem][j].y=0.0;
+					NewPosition[CurrentSystem][j].z=0.0;
+				}
+			}
+
+			GrowTransient(NumberOldComponent);						
+
+		    for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+		    {
+			  if(BlockedPocket(TrialPosition[CurrentSystem][j]))
+			  return 0;
+		    }
+
+		    UTailNew=TailMolecularEnergyDifferenceAdd();
+
+		    if(ComputePolarization)
+		    {
+			    ComputeNewPolarizationEnergy(TRUE,CurrentAdsorbateMolecule,-1);
+		    }
+
+		    if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+		    {
+			    CalculateEwaldFourierAdsorbate(TRUE,FALSE,NumberOfAdsorbateMolecules[CurrentSystem],0);
+			}
+
+			UAdsorbateBond[CurrentSystem]+=UBondNew[CurrentSystem];
+			UAdsorbateUreyBradley[CurrentSystem]+=UUreyBradleyNew[CurrentSystem];
+			UAdsorbateBend[CurrentSystem]+=UBendNew[CurrentSystem];
+			UAdsorbateBendBend[CurrentSystem]+=UBendBendNew[CurrentSystem];
+			UAdsorbateInversionBend[CurrentSystem]+=UInversionBendNew[CurrentSystem];
+			UAdsorbateTorsion[CurrentSystem]+=UTorsionNew[CurrentSystem];
+			UAdsorbateImproperTorsion[CurrentSystem]+=UImproperTorsionNew[CurrentSystem];
+			UAdsorbateBondBond[CurrentSystem]+=UBondBondNew[CurrentSystem];
+			UAdsorbateBondBend[CurrentSystem]+=UBondBendNew[CurrentSystem];
+			UAdsorbateBondTorsion[CurrentSystem]+=UBondTorsionNew[CurrentSystem];
+			UAdsorbateBendTorsion[CurrentSystem]+=UBendTorsionNew[CurrentSystem];
+			UAdsorbateIntraVDW[CurrentSystem]+=UIntraVDWNew[CurrentSystem];
+
+			UAdsorbateAdsorbate[CurrentSystem]+=UAdsorbateVDWNew[CurrentSystem];
+			UAdsorbateAdsorbateVDW[CurrentSystem]+=UAdsorbateVDWNew[CurrentSystem];
+			UAdsorbateCation[CurrentSystem]+=UCationVDWNew[CurrentSystem];
+			UAdsorbateCationVDW[CurrentSystem]+=UCationVDWNew[CurrentSystem];
+			UHostAdsorbate[CurrentSystem]+=UHostVDWNew[CurrentSystem];
+			UHostAdsorbateVDW[CurrentSystem]+=UHostVDWNew[CurrentSystem];
+
+			UTailCorrection[CurrentSystem]+=UTailNew;
+
+			UHostPolarization[CurrentSystem]=UHostPolarizationNew[CurrentSystem];
+			UAdsorbatePolarization[CurrentSystem]=UAdsorbatePolarizationNew[CurrentSystem]+UPolarizationNew[CurrentSystem];
+			UCationPolarization[CurrentSystem]=UCationPolarizationNew[CurrentSystem];
+
+			UHostBackPolarization[CurrentSystem]=UHostBackPolarizationNew[CurrentSystem];
+			UAdsorbateBackPolarization[CurrentSystem]=UAdsorbateBackPolarizationNew[CurrentSystem]+UBackPolarizationNew[CurrentSystem];
+			UCationBackPolarization[CurrentSystem]=UCationBackPolarizationNew[CurrentSystem];
+
+			if(ChargeMethod!=NONE)
+			{
+			  UAdsorbateIntraChargeCharge[CurrentSystem]+=UIntraChargeChargeNew[CurrentSystem];
+			  UAdsorbateIntraChargeBondDipole[CurrentSystem]+=UIntraChargeBondDipoleNew[CurrentSystem];
+			  UAdsorbateIntraBondDipoleBondDipole[CurrentSystem]+=UIntraBondDipoleBondDipoleNew[CurrentSystem];
+
+			  UAdsorbateAdsorbateChargeChargeReal[CurrentSystem]+=UAdsorbateChargeChargeNew[CurrentSystem];
+			  UAdsorbateAdsorbateChargeBondDipoleReal[CurrentSystem]+=UAdsorbateChargeBondDipoleNew[CurrentSystem];
+			  UAdsorbateAdsorbateBondDipoleBondDipoleReal[CurrentSystem]+=UAdsorbateBondDipoleBondDipoleNew[CurrentSystem];
+			  UAdsorbateAdsorbateChargeChargeFourier[CurrentSystem]+=UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem];
+			  UAdsorbateAdsorbateChargeBondDipoleFourier[CurrentSystem]+=UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem];
+			  UAdsorbateAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]+=UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+			  UAdsorbateAdsorbateCoulomb[CurrentSystem]+=UAdsorbateChargeChargeNew[CurrentSystem]+
+														 UAdsorbateChargeBondDipoleNew[CurrentSystem]+
+														 UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]+
+														 UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem]+
+														 UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+
+														 UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+			  UAdsorbateAdsorbate[CurrentSystem]+=UAdsorbateChargeChargeNew[CurrentSystem]+
+												  UAdsorbateChargeBondDipoleNew[CurrentSystem]+
+												  UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]+
+												  UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem]+
+												  UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+
+												  UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+
+			  UHostAdsorbateChargeChargeReal[CurrentSystem]+=UHostChargeChargeNew[CurrentSystem];
+			  UHostAdsorbateChargeBondDipoleReal[CurrentSystem]+=UHostChargeBondDipoleNew[CurrentSystem];
+			  UHostAdsorbateBondDipoleBondDipoleReal[CurrentSystem]+=UHostBondDipoleBondDipoleNew[CurrentSystem];
+			  UHostAdsorbateChargeChargeFourier[CurrentSystem]+=UHostAdsorbateChargeChargeFourierDelta[CurrentSystem];
+			  UHostAdsorbateChargeBondDipoleFourier[CurrentSystem]+=UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem];
+			  UHostAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]+=UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+			  UHostAdsorbateCoulomb[CurrentSystem]+=UHostChargeChargeNew[CurrentSystem]+
+													UHostChargeBondDipoleNew[CurrentSystem]+
+													UHostBondDipoleBondDipoleNew[CurrentSystem]+
+													UHostAdsorbateChargeChargeFourierDelta[CurrentSystem]+
+													UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+
+													UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+			  UHostAdsorbate[CurrentSystem]+=UHostChargeChargeNew[CurrentSystem]+
+											 UHostChargeBondDipoleNew[CurrentSystem]+
+											 UHostBondDipoleBondDipoleNew[CurrentSystem]+
+											 UHostAdsorbateChargeChargeFourierDelta[CurrentSystem]+
+											 UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+
+											 UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+
+			  UAdsorbateCationChargeChargeReal[CurrentSystem]+=UCationChargeChargeNew[CurrentSystem];
+			  UAdsorbateCationChargeBondDipoleReal[CurrentSystem]+=UCationChargeBondDipoleNew[CurrentSystem];
+			  UAdsorbateCationBondDipoleBondDipoleReal[CurrentSystem]+=UCationBondDipoleBondDipoleNew[CurrentSystem];
+			  UAdsorbateCationChargeChargeFourier[CurrentSystem]+=UAdsorbateCationChargeChargeFourierDelta[CurrentSystem];
+			  UAdsorbateCationChargeBondDipoleFourier[CurrentSystem]+=UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem];
+			  UAdsorbateCationBondDipoleBondDipoleFourier[CurrentSystem]+=UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem];
+			  UAdsorbateCationCoulomb[CurrentSystem]+=UCationChargeChargeNew[CurrentSystem]+
+													  UCationChargeBondDipoleNew[CurrentSystem]+
+													  UCationBondDipoleBondDipoleNew[CurrentSystem]+
+													  UAdsorbateCationChargeChargeFourierDelta[CurrentSystem]+
+													  UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem]+
+													  UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem];
+			  UAdsorbateCation[CurrentSystem]+=UCationChargeChargeNew[CurrentSystem]+
+											   UCationChargeBondDipoleNew[CurrentSystem]+
+											   UCationBondDipoleBondDipoleNew[CurrentSystem]+
+											   UAdsorbateCationChargeChargeFourierDelta[CurrentSystem]+
+											   UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem]+
+											   UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem];
+
+			  NetChargeAdsorbates[CurrentSystem]+=NetChargeAdsorbateDelta;
+			  NetChargeSystem[CurrentSystem]+=NetChargeAdsorbateDelta;
+
+			  if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+				AcceptEwaldAdsorbateMove(0);
+			}
+			
+			InsertAdsorbateAlchMolecule();
+
+			DeltaU=UBondNew[CurrentSystem]+UUreyBradleyNew[CurrentSystem]+UBendNew[CurrentSystem]+UBendBendNew[CurrentSystem]+UInversionBendNew[CurrentSystem]+UTorsionNew[CurrentSystem]+
+				   UImproperTorsionNew[CurrentSystem]+UBondBondNew[CurrentSystem]+UBondBendNew[CurrentSystem]+UBondTorsionNew[CurrentSystem]+UBendTorsionNew[CurrentSystem]+
+				   UIntraVDWNew[CurrentSystem]+UIntraChargeChargeNew[CurrentSystem]+
+				   UIntraChargeBondDipoleNew[CurrentSystem]+UIntraBondDipoleBondDipoleNew[CurrentSystem]+
+				   UAdsorbateVDWNew[CurrentSystem]+UCationVDWNew[CurrentSystem]+UHostVDWNew[CurrentSystem]+
+				   UAdsorbateChargeChargeNew[CurrentSystem]+UCationChargeChargeNew[CurrentSystem]+UHostChargeChargeNew[CurrentSystem]+
+				   UAdsorbateChargeBondDipoleNew[CurrentSystem]+UCationChargeBondDipoleNew[CurrentSystem]+UHostChargeBondDipoleNew[CurrentSystem]+
+				   UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]+UCationBondDipoleBondDipoleNew[CurrentSystem]+UHostBondDipoleBondDipoleNew[CurrentSystem]+
+				   UHostAdsorbateChargeChargeFourierDelta[CurrentSystem]+UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem]+UAdsorbateCationChargeChargeFourierDelta[CurrentSystem]+
+				   UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem]+
+				   UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]+UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]+UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem]+
+				   UDeltaPolarization+UTailNew;	
+					
+				   UTotal[CurrentSystem]+=DeltaU;
+  		}
+  }
+
+  return 0;
+}
+
+
+/*********************************************************************************************************
+ * Name       | ReallocateMemoryParameterTab      (Added by A. de Izarra)                                *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Reallocate memory to store potential parameters of peudo atoms for the					 * 
+ *            | molecules that undergo the alchemical transformation.						     		 *                     					 
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void ReallocateMemoryParameterTab(void)
+{ 
+	 int k,i,j;
+	 //-----------------------------------------------
+	 // allocate extra memory in PotentialParms, updated at each alchemical transformation step.
+	 PotentialParms=(REAL(**)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS])realloc(PotentialParms,
+	 (InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(REAL(*)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS]));
+	
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {
+		  PotentialParms[i] = (REAL(*)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS])realloc(PotentialParms[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(REAL[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS]));
+	 }	
+	  
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		  PotentialParms[i] = (REAL(*)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS])calloc(InitialPseudoAtoms+NumberExtraPseudoAtoms,sizeof(REAL[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS]));
+	 }
+	 
+	 // Fill new initialized PotentialParms to zero.
+	 for(i=0;i<InitialPseudoAtoms+NumberExtraPseudoAtoms;i++)
+	 {
+		  for(j=i+1;j<InitialPseudoAtoms+NumberExtraPseudoAtoms;j++)
+		  {
+			if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+			{
+				continue;
+			}
+			
+			PotentialParms[i][j][0]=0.0;
+			PotentialParms[i][j][1]=0.0;
+			PotentialParms[i][j][2]=0.0;
+		  }
+	 }
+
+	 //-----------------------------------------------
+	 // allocate extra memory in Potentialtyoe
+	 if(PotentialType[0][0] != LENNARD_JONES)
+	 {
+		 fprintf(stderr,"Error: Alchemical transformation is set up for LENNARD-JONES interaction.\n");
+		 exit(0);
+	 }
+	 else
+	 {
+		 // Step 3: allocate extra memory in PotentialType.
+		 PotentialType=(int**)realloc(PotentialType,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*(sizeof(int*)));
+		 
+		 for(i = 0; i < InitialPseudoAtoms; i++)
+		 {
+			  PotentialType[i] = (int*)realloc(PotentialType[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+		 }
+		 
+		 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+		 {
+			  PotentialType[i] = (int*)calloc(InitialPseudoAtoms+NumberExtraPseudoAtoms,sizeof(int));
+		 }
+
+		// Fill the extended potentialTypeTab.
+		int index;
+		int atom_nr;
+		int atom_type;
+		
+		for(k=0;k<2;k++)
+		{
+			atom_nr=-1;
+			index = (InitialPseudoAtoms) + k*(Components[SolventIndex].NumberOfAtoms);
+			for(i=index;i<index+Components[SolventIndex].NumberOfAtoms;i++)
+			{
+				atom_nr++;
+				atom_type = Components[SolventIndex].Type[atom_nr];
+				PotentialType[i][i] = PotentialType[atom_type][atom_type];
+			}
+		}
+		
+		// PotentialTab updated according to mixing rules.
+		for(i=0;i<InitialPseudoAtoms+NumberExtraPseudoAtoms;i++)
+		{
+		  for(j=i+1;j<InitialPseudoAtoms+NumberExtraPseudoAtoms;j++)
+		  {
+			if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+			{
+				continue;
+			}
+			
+			if((PotentialType[i][i]==LENNARD_JONES)&&(PotentialType[j][j]==LENNARD_JONES))
+			{	
+			  PotentialType[i][j]=LENNARD_JONES;
+			  PotentialType[j][i]=LENNARD_JONES;
+			}
+			else
+			{
+		      PotentialType[i][j]=ZERO_POTENTIAL;
+			  PotentialType[j][i]=ZERO_POTENTIAL;
+			}
+		  }
+		}
+	}
+	
+	//-----------------------------------------------
+	// Allocate extra memory for tail correction.
+	TailCorrection=(int**)realloc(TailCorrection,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*(sizeof(int*)));
+	 
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {
+		  TailCorrection[i] = (int*)realloc(TailCorrection[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+	 }
+	 
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		  TailCorrection[i] = (int*)calloc(InitialPseudoAtoms+NumberExtraPseudoAtoms,sizeof(int));
+	 }
+
+	// Fill the extended TailCorrection.
+	int index;
+	
+	for(k=0;k<2;k++)
+	{
+		index = (InitialPseudoAtoms) + k*(Components[SolventIndex].NumberOfAtoms);
+		for(i=index;i<index+Components[SolventIndex].NumberOfAtoms;i++)
+		{
+			TailCorrection[i][i] = TailCorrection[0][0];
+		}
+	}
+	
+	// PotentialTab updated according to mixing rules.
+	for(i=0;i<InitialPseudoAtoms+NumberExtraPseudoAtoms;i++)
+	{
+	  for(j=i+1;j<InitialPseudoAtoms+NumberExtraPseudoAtoms;j++)
+	  {
+		if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+		{
+			continue;
+		}
+		
+		  TailCorrection[i][j]=TailCorrection[0][0];
+		  TailCorrection[j][i]=TailCorrection[0][0];
+	  }
+	}
+	
+	
+	//-----------------------------------------------
+	// Allocate extra memory for shift potential
+	ShiftPotential=(int**)realloc(ShiftPotential,(InitialPseudoAtoms+NumberExtraPseudoAtoms)*(sizeof(int*)));
+	 
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {
+		  ShiftPotential[i] = (int*)realloc(ShiftPotential[i],(InitialPseudoAtoms+NumberExtraPseudoAtoms)*sizeof(int));
+	 }
+	 
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		  ShiftPotential[i] = (int*)calloc(InitialPseudoAtoms+NumberExtraPseudoAtoms,sizeof(int));
+	 }
+
+	// Fill the extended TailCorrection.
+	
+	for(k=0;k<2;k++)
+	{
+		index = (InitialPseudoAtoms) + k*(Components[SolventIndex].NumberOfAtoms);
+		for(i=index;i<index+Components[SolventIndex].NumberOfAtoms;i++)
+		{
+			ShiftPotential[i][i] = ShiftPotential[0][0];
+		}
+	}
+	
+	// PotentialTab updated according to mixing rules.
+	for(i=0;i<InitialPseudoAtoms+NumberExtraPseudoAtoms;i++)
+	{
+	  for(j=i+1;j<InitialPseudoAtoms+NumberExtraPseudoAtoms;j++)
+	  {
+		if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+		{
+			continue;
+		}
+		
+		  ShiftPotential[i][j]=ShiftPotential[0][0];
+		  ShiftPotential[j][i]=ShiftPotential[0][0];
+	  }
+    }	
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeVectorCharge      (Added by A. de Izarra)                               		 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize vectors to store charges of the pseudo atoms of the molecules that 			 *
+ * 			  | undergo the alchemical transformation.										     		 *                     					 
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void InitializeVectorCharge(void)
+{
+	
+	 // Step 1: preparation of vectors.
+	 int Species,i;
+	 
+	 int type;
+											
+	 VectorChargeAlchemicalTransformation = (REAL(**))calloc(3,sizeof(REAL(*)));
+
+	 for(Species=0; Species<3; Species++)
+	 {	 
+		 VectorChargeAlchemicalTransformation[Species] = (REAL(*))calloc(TransientMoleculeNbAtoms,sizeof(REAL));
+		 
+		 for(i=0;i<TransientMoleculeNbAtoms;i++)
+		 {
+			 // Manage the solvent.
+			 if(Species == SolventIndex)
+			 {
+				 type = Components[SolventIndex].Type[i];
+				 
+				 VectorChargeAlchemicalTransformation[Species][i] = PseudoAtoms[type].Charge1;		 
+			 }
+			 // Manage the ions.
+			 else
+			 {
+				 // for i==0, it is the first atom corresponding to the atomic ions.
+				 if(i==0)
+				 {
+					type = Components[Species].Type[i];
+					
+					VectorChargeAlchemicalTransformation[Species][i] = PseudoAtoms[type].Charge1;	
+				 }
+				 else
+				 {
+					VectorChargeAlchemicalTransformation[Species][i]=0.0;
+				 }
+			 }
+		 }
+	 } 	 
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeChargeTransientMoities    (Added by A. de Izarra)                              *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize charges of the pseudo atoms of the molecules that undergo the alchemical		 *
+ * 			  | transformation.										     		 						 *
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *
+ *********************************************************************************************************/
+void InitializeChargeTransientMoities(int NumberOldComponent)
+{
+	int k,i,j;
+
+	// Index to put the proper parameter in the right place in PotentialParms
+	int index;
+	int atom_count;
+	
+	// Initialize pseudoatom charge
+	
+	// We know water has been chosen as old component
+	if(NumberOldComponent == 1)
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;
+				PseudoAtoms[i].Charge1 = VectorChargeAlchemicalTransformation[SolventIndex][atom_count];
+			}
+		}
+	}
+	// We know ions has been chosen as old component
+	else
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;
+				PseudoAtoms[i].Charge1 = VectorChargeAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count];
+			}
+		}
+	}
+	
+	// Initialize component charge.
+	for(i=0;i<NumberExtraComponents;i++)
+	{
+	  for(j=0;j<Components[IndexExtraComponent[i]].NumberOfAtoms;j++)
+	  {
+		Components[IndexExtraComponent[i]].Charge[j]=PseudoAtoms[Components[IndexExtraComponent[i]].Type[j]].Charge1;
+	  }
+	}
+	/*
+	// Initialize the charge of adsorbate.
+	int IndexExtraTransientAdsorbate = NumberOfAdsorbateMolecules[CurrentSystem]-NumberTransientMoities[CurrentAlchemicalReaction];
+	
+	for(i=0;i<NumberExtraComponents;i++)
+	{	  
+	  for(j=0;j<Components[IndexExtraComponent[i]].NumberOfMolecules[CurrentSystem];j++)
+	  {
+		 for(k=0;k<Components[IndexExtraComponent[i]].NumberOfAtoms;k++)
+		 {
+			 Adsorbates[CurrentSystem][IndexExtraTransientAdsorbate].Atoms[k].Charge=Components[IndexExtraComponent[i]].Charge[k];
+		 }
+		 IndexExtraTransientAdsorbate++;
+	  }
+	}
+	*/
+}
+
+/*********************************************************************************************************
+ * Name       | UpdateChargeInterpolationAlchemicalTransformation    (Added by A. de Izarra)             *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Update the charges of the pseudo atoms of the molecules that undergo the alchemical		 *
+ * 			  | transformation, during the alchemical transformation.									 *																			           					 
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *	
+ * 			  | REAL Lambda => Interpolation parameter (between 0 and 1) of the alchemical transformation*											
+ *********************************************************************************************************/
+void UpdateChargeInterpolationAlchemicalTransformation(int NumberOldComponent, REAL Lambda)
+{
+	int k,i,j;
+
+	// Index to put the proper parameter in the right place in PotentialParms
+	int index;
+	int atom_count;
+	
+	// Update the charge during the alchemical change.
+	
+	// We know water has been chosen as old component
+	if(NumberOldComponent == 1)
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;						   																			 
+				PseudoAtoms[i].Charge1 = (1.0-Lambda)*(VectorChargeAlchemicalTransformation[SolventIndex][atom_count]) + Lambda*(VectorChargeAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count]);				
+			}
+		}
+	}
+	// We know ions has been chosen as old component
+	else
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;			 
+				PseudoAtoms[i].Charge1 = (1.0-Lambda)*(VectorChargeAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count]) + Lambda*(VectorChargeAlchemicalTransformation[SolventIndex][atom_count]);
+			}
+		}
+	} 
+	
+	// Update the charge of the component.
+	for(i=0;i<NumberExtraComponents;i++)
+	{
+	  for(j=0;j<Components[IndexExtraComponent[i]].NumberOfAtoms;j++)
+	  {
+		Components[IndexExtraComponent[i]].Charge[j]=PseudoAtoms[Components[IndexExtraComponent[i]].Type[j]].Charge1;
+	  }
+	}	
+	
+	// Update the charge of adsorbate.
+	int IndexExtraTransientAdsorbate = NumberOfAdsorbateMolecules[CurrentSystem]-NumberTransientMoities[CurrentAlchemicalReaction];
+	
+	for(i=0;i<NumberExtraComponents;i++)
+	{	  
+	  for(j=0;j<Components[IndexExtraComponent[i]].NumberOfMolecules[CurrentSystem];j++)
+	  {
+		 for(k=0;k<Components[IndexExtraComponent[i]].NumberOfAtoms;k++)
+		 {
+			 Adsorbates[CurrentSystem][IndexExtraTransientAdsorbate].Atoms[k].Charge=Components[IndexExtraComponent[i]].Charge[k];
+		 }
+		 IndexExtraTransientAdsorbate++;
+	  }
+	}	
+	
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeVectorforMixingRule    (Added by A. de Izarra)            					 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize the mixing rules for the pseudo atoms of the molecules that undergo 			 *
+ * 		      | the alchemical transformation.															 *																			           					 
+ * Parameters | No parameters																			 *											
+ *********************************************************************************************************/
+void InitializeVectorforMixingRule(void)
+{
+	
+	 // Step 1: preparation of vectors.
+	 int Species,i;
+	 
+	 int type;
+											
+	 VectorforMixingRuleAlchemicalTransformation = (REAL(**)[2])calloc(3,sizeof(REAL(*)[2]));
+
+	 for(Species=0; Species<3; Species++)
+	 {
+		 VectorforMixingRuleAlchemicalTransformation[Species] = (REAL(*)[2])calloc(TransientMoleculeNbAtoms,sizeof(REAL[2]));
+		 
+		 for(i=0;i<TransientMoleculeNbAtoms;i++)
+		 {
+			 // Manage the solvent.
+			 if(Species == SolventIndex)
+			 {
+				 type = Components[SolventIndex].Type[i];
+				  
+				 VectorforMixingRuleAlchemicalTransformation[Species][i][0]=  PotentialParms[type][type][0];
+				 VectorforMixingRuleAlchemicalTransformation[Species][i][1]=  PotentialParms[type][type][1];			 
+			 }
+			 // Manage the ions.
+			 else
+			 {
+				 // for i==0, it is the first atom corresponding to the atomic ions.
+				 if(i==0)
+				 {
+					type = Components[Species].Type[i];
+					
+					VectorforMixingRuleAlchemicalTransformation[Species][i][0]=0;
+					VectorforMixingRuleAlchemicalTransformation[Species][i][1]=0;
+				 }
+				 else
+				 {
+					VectorforMixingRuleAlchemicalTransformation[Species][i][0]=0.0;
+					VectorforMixingRuleAlchemicalTransformation[Species][i][1]=0.0;
+				 }
+			 }
+		 }
+	 } 	 
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeVDWTransientMoities    (Added by A. de Izarra)                              	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize vdW radius of the pseudo atoms of the molecules that undergo the alchemical	 *
+ * 			  | transformation.										     		 						 *
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *
+ *********************************************************************************************************/
+void InitializeVDWTransientMoities(int NumberOldComponent)
+{	
+	int k,i,j;
+	
+
+	// Index to put the proper parameter in the right place in PotentialParms
+	int index;
+	int atom_count;
+	
+	// Prepare the interaction between the transformed molecules (aka: PotentialParms[i][i] for alchemical transformation)
+	
+	// We know water has been chosen as old component
+	if(NumberOldComponent == 1)
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;
+				
+				PotentialParms[i][i][0] = VectorforMixingRuleAlchemicalTransformation[SolventIndex][atom_count][0];
+				PotentialParms[i][i][1] = VectorforMixingRuleAlchemicalTransformation[SolventIndex][atom_count][1];
+			}
+		}
+	}
+	// We know ions has been chosen as old component
+	else
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;
+
+				PotentialParms[i][i][0] = VectorforMixingRuleAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count][0];
+				PotentialParms[i][i][1] = VectorforMixingRuleAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count][1];
+			}
+		}
+	}
+    // Compute the mixing rule with interpolated non-bonded vdw parameters.
+    
+    if(GeneralMixingRule=LORENTZ_BERTHELOT)
+    {
+		for(i=0;i<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;i++)
+		{
+		  for(j=i+1;j<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;j++)
+		  {
+			if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+			{
+				continue;
+			}
+			if((PotentialType[i][i]==LENNARD_JONES)&&(PotentialType[j][j]==LENNARD_JONES))
+			{	
+			  PotentialParms[i][j][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ij=sqrt(p_0^i*p_0^j)
+			  PotentialParms[j][i][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ji=sqrt(p_0^j*p_0^i)
+			  PotentialParms[i][j][1]=0.5*(PotentialParms[i][i][1]+PotentialParms[j][j][1]); // p_1^ij=(p_1^i+p_1^j)/2
+			  PotentialParms[j][i][1]=0.5*(PotentialParms[i][i][1]+PotentialParms[j][j][1]); // p_1^ji=(p_1^j+p_1^i)/2
+			}
+		  }
+		}
+      }
+	  else if(GeneralMixingRule=JORGENSEN)
+	  {
+		for(i=0;i<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;i++)
+		  for(j=i+1;j<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;j++)
+		  {
+			if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+			{
+				continue;
+			}  
+			  
+			if((PotentialType[i][i]==LENNARD_JONES)&&(PotentialType[j][j]==LENNARD_JONES))
+			{
+			  PotentialType[i][j]=LENNARD_JONES;
+			  PotentialType[j][i]=LENNARD_JONES;
+			  PotentialParms[i][j][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ij=sqrt(p_0^i*p_0^j)
+			  PotentialParms[j][i][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ji=sqrt(p_0^j*p_0^i)
+			  PotentialParms[i][j][1]=sqrt(PotentialParms[i][i][1]*PotentialParms[j][j][1]); // p_1^ij=sqrt(p_1^i*p_1^j)
+			  PotentialParms[j][i][1]=sqrt(PotentialParms[i][i][1]*PotentialParms[j][j][1]); // p_1^ji=sqrt(p_1^j*p_1^i)
+			}
+		  }
+	  }	  
+}
+
+/*********************************************************************************************************
+ * Name       | UpdateMixingRuleVDWInterpolationAlchemicalTransformation    (Added by A. de Izarra)      *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Update the mixing rules and the vdw parameters during the alchemical transformation      *																		           					 
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *	
+ * 			  | REAL Lambda => Interpolation parameter (between 0 and 1) of the alchemical transformation*											
+ *********************************************************************************************************/
+void UpdateMixingRuleVDWInterpolationAlchemicalTransformation(int NumberOldComponent, REAL Lambda)
+{
+	int k,i,j;
+
+	// Index to put the proper parameter in the right place in PotentialParms
+	int index;
+	int atom_count;
+	
+	// Prepare the interaction between the transformed molecules (aka: PotentialParms[i][i] for alchemical transformation)
+	
+	// We know water has been chosen as old component
+	if(NumberOldComponent == 1)
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;
+				PotentialParms[i][i][0] = (1.0-Lambda)*(VectorforMixingRuleAlchemicalTransformation[SolventIndex][atom_count][0]) + Lambda*(VectorforMixingRuleAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count][0]);
+				PotentialParms[i][i][1] = (1.0-Lambda)*(VectorforMixingRuleAlchemicalTransformation[SolventIndex][atom_count][1]) + Lambda*(VectorforMixingRuleAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count][1]);
+			}
+		}
+	}
+	// We know ions has been chosen as old component
+	else
+	{
+		for(k=0;k<NumberExtraComponents;k++)
+		{
+			atom_count = -1;
+			index = (InitialPseudoAtoms) + k*(TransientMoleculeNbAtoms);
+			
+			for(i=index;i<index+TransientMoleculeNbAtoms;i++)
+			{
+				atom_count++;
+				PotentialParms[i][i][0] = (1.0-Lambda)*(VectorforMixingRuleAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count][0]) + Lambda*(VectorforMixingRuleAlchemicalTransformation[SolventIndex][atom_count][0]);
+				PotentialParms[i][i][1] = (1.0-Lambda)*(VectorforMixingRuleAlchemicalTransformation[SaltIndex[CurrentAlchemicalReaction][k]][atom_count][1]) + Lambda*(VectorforMixingRuleAlchemicalTransformation[SolventIndex][atom_count][1]);
+			}
+		}
+	}
+    // Compute the mixing rule with interpolated non-bonded vdw parameters.
+    if(GeneralMixingRule=LORENTZ_BERTHELOT)
+    {
+		for(i=0;i<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;i++)
+		{
+		  for(j=i+1;j<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;j++)
+		  {
+			if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+			{
+				continue;
+			}
+			if((PotentialType[i][i]==LENNARD_JONES)&&(PotentialType[j][j]==LENNARD_JONES))
+			{	
+			  PotentialParms[i][j][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ij=sqrt(p_0^i*p_0^j)
+			  PotentialParms[j][i][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ji=sqrt(p_0^j*p_0^i)
+			  PotentialParms[i][j][1]=0.5*(PotentialParms[i][i][1]+PotentialParms[j][j][1]); // p_1^ij=(p_1^i+p_1^j)/2
+			  PotentialParms[j][i][1]=0.5*(PotentialParms[i][i][1]+PotentialParms[j][j][1]); // p_1^ji=(p_1^j+p_1^i)/2
+			}
+		  }
+		}
+      }
+	  else if(GeneralMixingRule=JORGENSEN)
+	  {
+		for(i=0;i<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;i++)
+		  for(j=i+1;j<InitialPseudoAtoms+2*TransientMoleculeNbAtoms;j++)
+		  {
+			if((i<InitialPseudoAtoms)&&(j<InitialPseudoAtoms))
+			{
+				continue;
+			}  
+			  
+			if((PotentialType[i][i]==LENNARD_JONES)&&(PotentialType[j][j]==LENNARD_JONES))
+			{
+			  PotentialType[i][j]=LENNARD_JONES;
+			  PotentialType[j][i]=LENNARD_JONES;
+			  PotentialParms[i][j][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ij=sqrt(p_0^i*p_0^j)
+			  PotentialParms[j][i][0]=sqrt(PotentialParms[i][i][0]*PotentialParms[j][j][0]); // p_0^ji=sqrt(p_0^j*p_0^i)
+			  PotentialParms[i][j][1]=sqrt(PotentialParms[i][i][1]*PotentialParms[j][j][1]); // p_1^ij=sqrt(p_1^i*p_1^j)
+			  PotentialParms[j][i][1]=sqrt(PotentialParms[i][i][1]*PotentialParms[j][j][1]); // p_1^ji=sqrt(p_1^j*p_1^i)
+			}
+		  }
+	  }
+}
+
+/*********************************************************************************************************
+ * Name       | StoreChosenMoitiesCoordinates    (Added by A. de Izarra)      							 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Store the coordinates of the chosen molecules that will be alchemically tranformed.      *																		           					 
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *									
+ *********************************************************************************************************/
+void StoreChosenMoitiesCoordinates(int NumberOldComponent)
+{	
+	int i,j;
+	int Type;
+	int Index;
+
+	// Copy coordinates and properties of chosen adsorbates.
+
+	AdsorbatesReferenceChosen=(ADSORBATE_MOLECULE*)calloc(NumberTransientMoities[CurrentAlchemicalReaction],sizeof(ADSORBATE_MOLECULE));
+	
+	for(i=0;i<NumberTransientMoities[CurrentAlchemicalReaction];i++)
+	{
+	  Index=ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][i];
+		
+	  Type = Adsorbates[CurrentSystem][Index].Type;
+	  AdsorbatesReferenceChosen[i].Type=Type;
+
+	  AdsorbatesReferenceChosen[i].Atoms=(ATOM*)calloc(Components[Type].NumberOfAtoms,sizeof(ATOM));
+	  AdsorbatesReferenceChosen[i].NumberOfAtoms=Components[Type].NumberOfAtoms;
+
+	  if(Components[Type].NumberOfGroups>0)
+		AdsorbatesReferenceChosen[i].Groups=(GROUP*)calloc(Components[Type].NumberOfGroups,sizeof(GROUP));
+	    	
+	  // Copy the pointer by value of positiona nd groups in the new vector.
+	  for(j=0;j<Components[Type].NumberOfAtoms;j++)
+	  { 
+		  AdsorbatesReferenceChosen[i].Atoms[j] = Adsorbates[CurrentSystem][Index].Atoms[j];
+	  }
+
+	  for(j=0;j<Components[Type].NumberOfGroups;j++)
+	  {
+		  AdsorbatesReferenceChosen[i].Groups[j] = Adsorbates[CurrentSystem][Index].Groups[j];
+	  }
+	}
+}
+
+/*********************************************************************************************************
+ * Name       | DeleteChosenMoities    (Added by A. de Izarra)      							 		 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Delete the initial molecules to be alchemically transformed. These molecules are 		 *
+ *            | redefined as "transient molecules" in MakeInitialTransient function, because they are 	 *
+ * 			  | candidates for the alchemical transformation.											 *						           					 
+ * Parameters | No parameters																			 *									
+ *********************************************************************************************************/
+void DeleteChosenMoities(void)
+{
+  int i,j;
+
+  REAL DeltaU,UTailOld,RosenbluthOld;
+  int LastMolecule;
+  int ComponentLastMolecule;
+ 
+  for(i=0;i<NumberTransientMoities[CurrentAlchemicalReaction];i++)
+  {
+		// The index of the chosen adsorbate molecule.
+		CurrentAdsorbateMolecule = ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][i];
+		
+		// The index of the chosen component.
+		CurrentComponent=Adsorbates[CurrentSystem][CurrentAdsorbateMolecule].Type;
+
+		for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+		{
+		CFVDWScaling[j]=1.0;
+		CFChargeScaling[j]=1.0;
+		}
+		
+		// Retrace the energy of the chosen componenent
+		NumberOfBeadsAlreadyPlaced=0;
+		
+		for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+		{
+			OldPosition[j]=Adsorbates[CurrentSystem][CurrentAdsorbateMolecule].Atoms[j].Position;
+		}
+
+		NumberOfTrialPositions=NumberOfTrialPositionsSwap;
+		NumberOfTrialPositionsForTheFirstBead=NumberOfTrialPositionsForTheFirstBeadSwap;
+
+		RosenbluthOld=RetraceMolecule(CBMC_DELETION);
+
+		UTailOld=TailMolecularEnergyDifferenceRemove();
+
+		if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+			CalculateEwaldFourierAdsorbate(FALSE,TRUE,CurrentAdsorbateMolecule,0);
+		
+
+		if(ComputePolarization)
+			ComputeNewPolarizationEnergy(FALSE,CurrentAdsorbateMolecule,-1);
+		
+		UAdsorbateBond[CurrentSystem]-=UBondOld[CurrentSystem];
+		UAdsorbateUreyBradley[CurrentSystem]-=UUreyBradleyOld[CurrentSystem];
+		UAdsorbateBend[CurrentSystem]-=UBendOld[CurrentSystem];
+		UAdsorbateBendBend[CurrentSystem]-=UBendBendOld[CurrentSystem];
+		UAdsorbateInversionBend[CurrentSystem]-=UInversionBendOld[CurrentSystem];
+		UAdsorbateTorsion[CurrentSystem]-=UTorsionOld[CurrentSystem];
+		UAdsorbateImproperTorsion[CurrentSystem]-=UImproperTorsionOld[CurrentSystem];
+		UAdsorbateBondBond[CurrentSystem]-=UBondBondOld[CurrentSystem];
+		UAdsorbateBondBend[CurrentSystem]-=UBondBendOld[CurrentSystem];
+		UAdsorbateBondTorsion[CurrentSystem]-=UBondTorsionOld[CurrentSystem];
+		UAdsorbateBendTorsion[CurrentSystem]-=UBendTorsionOld[CurrentSystem];
+		UAdsorbateIntraVDW[CurrentSystem]-=UIntraVDWOld[CurrentSystem];
+	    
+		UAdsorbateAdsorbate[CurrentSystem]-=UAdsorbateVDWOld[CurrentSystem];
+		UAdsorbateAdsorbateVDW[CurrentSystem]-=UAdsorbateVDWOld[CurrentSystem];
+		UAdsorbateCation[CurrentSystem]-=UCationVDWOld[CurrentSystem];
+		UAdsorbateCationVDW[CurrentSystem]-=UCationVDWOld[CurrentSystem];
+		UHostAdsorbate[CurrentSystem]-=UHostVDWOld[CurrentSystem];
+		UHostAdsorbateVDW[CurrentSystem]-=UHostVDWOld[CurrentSystem];
+		
+		
+		UTailCorrection[CurrentSystem]-=UTailOld;
+	
+		UHostPolarization[CurrentSystem]=UHostPolarizationNew[CurrentSystem];
+	
+		UAdsorbatePolarization[CurrentSystem]=UAdsorbatePolarizationNew[CurrentSystem]+UPolarizationNew[CurrentSystem];
+
+		UCationPolarization[CurrentSystem]=UCationPolarizationNew[CurrentSystem];
+		
+		UHostBackPolarization[CurrentSystem]=UHostBackPolarizationNew[CurrentSystem];
+		UAdsorbateBackPolarization[CurrentSystem]=UAdsorbateBackPolarizationNew[CurrentSystem]+UBackPolarizationNew[CurrentSystem];
+		UCationBackPolarization[CurrentSystem]=UCationBackPolarizationNew[CurrentSystem];
+
+		if(ChargeMethod!=NONE)
+		{
+		UAdsorbateIntraChargeCharge[CurrentSystem]-=UIntraChargeChargeOld[CurrentSystem];
+		UAdsorbateIntraChargeBondDipole[CurrentSystem]-=UIntraChargeBondDipoleOld[CurrentSystem];
+		UAdsorbateIntraBondDipoleBondDipole[CurrentSystem]-=UIntraBondDipoleBondDipoleOld[CurrentSystem];
+	
+		UAdsorbateAdsorbateChargeChargeReal[CurrentSystem]-=UAdsorbateChargeChargeOld[CurrentSystem];
+		UAdsorbateAdsorbateChargeBondDipoleReal[CurrentSystem]-=UAdsorbateChargeBondDipoleOld[CurrentSystem];
+		UAdsorbateAdsorbateBondDipoleBondDipoleReal[CurrentSystem]-=UAdsorbateBondDipoleBondDipoleOld[CurrentSystem];
+		UAdsorbateAdsorbateChargeChargeFourier[CurrentSystem]+=UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem];
+		UAdsorbateAdsorbateChargeBondDipoleFourier[CurrentSystem]+=UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem];
+		UAdsorbateAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]+=UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+		UAdsorbateAdsorbateCoulomb[CurrentSystem]+=UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem]
+													+UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]
+													+UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]
+													-UAdsorbateChargeChargeOld[CurrentSystem]
+													-UAdsorbateChargeBondDipoleOld[CurrentSystem]
+													-UAdsorbateBondDipoleBondDipoleOld[CurrentSystem];
+		UAdsorbateAdsorbate[CurrentSystem]+=UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem]
+											+UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]
+											+UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]
+											-UAdsorbateChargeChargeOld[CurrentSystem]
+											-UAdsorbateChargeBondDipoleOld[CurrentSystem]
+											-UAdsorbateBondDipoleBondDipoleOld[CurrentSystem];
+
+		UHostAdsorbateChargeChargeReal[CurrentSystem]-=UHostChargeChargeOld[CurrentSystem];
+		UHostAdsorbateChargeBondDipoleReal[CurrentSystem]-=UHostChargeBondDipoleOld[CurrentSystem];
+		UHostAdsorbateBondDipoleBondDipoleReal[CurrentSystem]-=UHostBondDipoleBondDipoleOld[CurrentSystem];
+		UHostAdsorbateChargeChargeFourier[CurrentSystem]+=UHostAdsorbateChargeChargeFourierDelta[CurrentSystem];
+		UHostAdsorbateChargeBondDipoleFourier[CurrentSystem]+=UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem];
+		UHostAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]+=UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem];
+		UHostAdsorbateCoulomb[CurrentSystem]+=UHostAdsorbateChargeChargeFourierDelta[CurrentSystem]
+											+UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]
+											+UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]
+											-UHostChargeChargeOld[CurrentSystem]
+											-UHostChargeBondDipoleOld[CurrentSystem]
+											-UHostBondDipoleBondDipoleOld[CurrentSystem];
+		UHostAdsorbate[CurrentSystem]+=UHostAdsorbateChargeChargeFourierDelta[CurrentSystem]
+										+UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]
+										+UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]
+										-UHostChargeChargeOld[CurrentSystem]
+										-UHostChargeBondDipoleOld[CurrentSystem]
+										-UHostBondDipoleBondDipoleOld[CurrentSystem];
+	
+		UAdsorbateCationChargeChargeReal[CurrentSystem]-=UCationChargeChargeOld[CurrentSystem];
+		UAdsorbateCationChargeBondDipoleReal[CurrentSystem]-=UCationChargeBondDipoleOld[CurrentSystem];
+		UAdsorbateCationBondDipoleBondDipoleReal[CurrentSystem]-=UCationBondDipoleBondDipoleOld[CurrentSystem];
+		UAdsorbateCationChargeChargeFourier[CurrentSystem]+=UAdsorbateCationChargeChargeFourierDelta[CurrentSystem];
+		UAdsorbateCationChargeBondDipoleFourier[CurrentSystem]+=UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem];
+		UAdsorbateCationBondDipoleBondDipoleFourier[CurrentSystem]+=UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem];
+		UAdsorbateCationCoulomb[CurrentSystem]+=UAdsorbateCationChargeChargeFourierDelta[CurrentSystem]
+												+UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem]
+												+UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem]
+												-UCationChargeChargeOld[CurrentSystem]
+												-UCationChargeBondDipoleOld[CurrentSystem]
+												-UCationBondDipoleBondDipoleOld[CurrentSystem];
+		UAdsorbateCation[CurrentSystem]+=UAdsorbateCationChargeChargeFourierDelta[CurrentSystem]
+										+UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem]
+										+UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem]
+										-UCationChargeChargeOld[CurrentSystem]
+										-UCationChargeBondDipoleOld[CurrentSystem]
+										-UCationBondDipoleBondDipoleOld[CurrentSystem];
+	
+		NetChargeAdsorbates[CurrentSystem]+=NetChargeAdsorbateDelta;
+		NetChargeSystem[CurrentSystem]+=NetChargeAdsorbateDelta;
+	
+		if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+			AcceptEwaldAdsorbateMove(0);
+		}
+	
+		// Update the list of chosen moities to take account of deleted index.
+		LastMolecule=NumberOfAdsorbateMolecules[CurrentSystem]-1;
+		ComponentLastMolecule=Adsorbates[CurrentSystem][LastMolecule].Type;
+		
+		for(j=i+1;j<NumberTransientMoities[CurrentAlchemicalReaction];j++)
+		{
+			// If a particule in the Chosen index is at the top of index, it takes the place of the current Chosenindex i
+			if(ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][j]==LastMolecule)
+			{
+				ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][j]=CurrentAdsorbateMolecule;
+			}
+		}	
+	
+		RemoveAdsorbateMolecule();	
+	
+		DeltaU=-UBondOld[CurrentSystem]-UUreyBradleyOld[CurrentSystem]-UBendOld[CurrentSystem]-UBendBendOld[CurrentSystem]-UInversionBendOld[CurrentSystem]-UTorsionOld[CurrentSystem]
+			-UImproperTorsionOld[CurrentSystem]-UBondBondOld[CurrentSystem]-UBondBendOld[CurrentSystem]-UBondTorsionOld[CurrentSystem]-UBendTorsionOld[CurrentSystem]
+			-UIntraVDWOld[CurrentSystem]-UIntraChargeChargeOld[CurrentSystem]-UIntraChargeBondDipoleOld[CurrentSystem]-UIntraBondDipoleBondDipoleOld[CurrentSystem]
+			-UAdsorbateVDWOld[CurrentSystem]-UCationVDWOld[CurrentSystem]-UHostVDWOld[CurrentSystem]
+			-UAdsorbateChargeChargeOld[CurrentSystem]-UCationChargeChargeOld[CurrentSystem]-UHostChargeChargeOld[CurrentSystem]
+			-UAdsorbateChargeBondDipoleOld[CurrentSystem]-UCationChargeBondDipoleOld[CurrentSystem]-UHostChargeBondDipoleOld[CurrentSystem]
+			-UAdsorbateBondDipoleBondDipoleOld[CurrentSystem]-UCationBondDipoleBondDipoleOld[CurrentSystem]-UHostBondDipoleBondDipoleOld[CurrentSystem]+
+				UHostAdsorbateChargeChargeFourierDelta[CurrentSystem]+UAdsorbateAdsorbateChargeChargeFourierDelta[CurrentSystem]+UAdsorbateCationChargeChargeFourierDelta[CurrentSystem]+
+				UHostAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+UAdsorbateAdsorbateChargeBondDipoleFourierDelta[CurrentSystem]+UAdsorbateCationChargeBondDipoleFourierDelta[CurrentSystem]+
+				UHostAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]+UAdsorbateAdsorbateBondDipoleBondDipoleFourierDelta[CurrentSystem]+UAdsorbateCationBondDipoleBondDipoleFourierDelta[CurrentSystem]+
+				UDeltaPolarization-UTailOld;
+	
+		UTotal[CurrentSystem]+=DeltaU;
+  }	
+}
+
+/*********************************************************************************************************
+ * Name       | SwitchMoietiestoRegularComponents    (Added by A. de Izarra)      					 	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | If the alchemical transformation is accepted, the transient molecules totally transformed*
+ * 			  | become normal molecules.																 *
+ * Parameters | int	NumberNewComponent => determines if new component is water (NumberNewComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberNewComponent=2) to be transformed into water. *	
+ *********************************************************************************************************/
+void SwitchMoietiestoRegularComponents(int NumberNewComponent)
+{		
+	int Comp;
+	int i,j;
+	int m;
+	int count = -1;
+	int type;
+    int nr_atoms;
+	int UntouchedAdsorbates=NumberOfAdsorbateMolecules[CurrentSystem]-NumberTransientMoities[CurrentAlchemicalReaction];
+  
+    // Copy the transient component in new adsorbates.
+	ADSORBATE_MOLECULE*AdsorbatesTransientMoities=(ADSORBATE_MOLECULE*)calloc(NumberTransientMoities[CurrentAlchemicalReaction],sizeof(ADSORBATE_MOLECULE));
+	
+	for(Comp=0; Comp<NumberExtraComponents; Comp++)
+	{
+		for(i=0;i<MultiplicitySalt[CurrentAlchemicalReaction][Comp];i++)
+	    {  
+			count++;
+			m = count+UntouchedAdsorbates;
+
+			if(NumberNewComponent == 1)
+			{
+				CurrentComponent=SolventIndex;
+			}
+			else
+			{
+				CurrentComponent=SaltIndex[CurrentAlchemicalReaction][Comp];
+			}
+			
+			AdsorbatesTransientMoities[count].Type = CurrentComponent;
+			Components[CurrentComponent].NumberOfMolecules[CurrentSystem]++;
+			AdsorbatesTransientMoities[count].NumberOfAtoms=Components[CurrentComponent].NumberOfAtoms;
+			AdsorbatesTransientMoities[count].Atoms=(ATOM*)calloc(Components[CurrentComponent].NumberOfAtoms,sizeof(ATOM));
+			
+			for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+			{	
+				type=Components[CurrentComponent].Type[j];		
+				AdsorbatesTransientMoities[count].Atoms[j].Position=Adsorbates[CurrentSystem][m].Atoms[j].Position;
+				AdsorbatesTransientMoities[count].Atoms[j].AnisotropicPosition=Adsorbates[CurrentSystem][m].Atoms[j].AnisotropicPosition;
+				AdsorbatesTransientMoities[count].Atoms[j].Velocity=Adsorbates[CurrentSystem][m].Atoms[j].Velocity;
+				AdsorbatesTransientMoities[count].Atoms[j].Force=Adsorbates[CurrentSystem][m].Atoms[j].Force;
+
+				// new Continuous-Fraction scaling factors are taken from the component-information
+				AdsorbatesTransientMoities[count].Atoms[j].CFVDWScalingParameter=CFVDWScaling[j];
+				AdsorbatesTransientMoities[count].Atoms[j].CFChargeScalingParameter=CFChargeScaling[j];
+
+				AdsorbatesTransientMoities[count].Atoms[j].Type=type;
+				AdsorbatesTransientMoities[count].Atoms[j].Fixed.x=Components[CurrentComponent].Fixed[j];
+				AdsorbatesTransientMoities[count].Atoms[j].Fixed.y=Components[CurrentComponent].Fixed[j];
+				AdsorbatesTransientMoities[count].Atoms[j].Fixed.z=Components[CurrentComponent].Fixed[j];
+				AdsorbatesTransientMoities[count].Atoms[j].Charge=Adsorbates[CurrentSystem][m].Atoms[j].Charge;
+				
+			}
+			
+			if(Components[CurrentComponent].NumberOfGroups>0)
+				AdsorbatesTransientMoities[count].Groups=(GROUP*)calloc(Components[CurrentComponent].NumberOfGroups,sizeof(GROUP));
+			
+			nr_atoms=Components[CurrentComponent].NumberOfAtoms;
+			NumberOfAtomsPerSystem[CurrentSystem]+=nr_atoms;
+			NumberOfChargesPerSystem[CurrentSystem]+=Components[CurrentComponent].NumberOfCharges;
+			NumberOfBondDipolesPerSystem[CurrentSystem]+=Components[CurrentComponent].NumberOfBondDipoles;
+			
+			// Reinitialize adsorbate pointers.
+			Adsorbates[CurrentSystem][m].Atoms=NULL;
+			Adsorbates[CurrentSystem][m].Atoms=(ATOM*)calloc(Components[CurrentComponent].NumberOfAtoms,sizeof(ATOM));
+			
+			Adsorbates[CurrentSystem][m].Groups=NULL;
+			Adsorbates[CurrentSystem][m].Groups=(GROUP*)calloc(Components[CurrentComponent].NumberOfGroups,sizeof(GROUP));
+			
+			Adsorbates[CurrentSystem][m].NumberOfAtoms=AdsorbatesTransientMoities[count].NumberOfAtoms;
+			Adsorbates[CurrentSystem][m].Type=AdsorbatesTransientMoities[count].Type;
+		
+			// Update new adsorbate.
+			for(j=0;j<Components[CurrentComponent].NumberOfAtoms;j++)
+			{
+				type=Components[CurrentComponent].Type[j];
+				Adsorbates[CurrentSystem][m].Atoms[j].Position=AdsorbatesTransientMoities[count].Atoms[j].Position;
+				Adsorbates[CurrentSystem][m].Atoms[j].AnisotropicPosition=AdsorbatesTransientMoities[count].Atoms[j].AnisotropicPosition;
+				Adsorbates[CurrentSystem][m].Atoms[j].Velocity=AdsorbatesTransientMoities[count].Atoms[j].Velocity;
+				Adsorbates[CurrentSystem][m].Atoms[j].Force=AdsorbatesTransientMoities[count].Atoms[j].Force;
+
+				// new Continuous-Fraction scaling factors are taken from the component-information
+				Adsorbates[CurrentSystem][m].Atoms[j].CFVDWScalingParameter=CFVDWScaling[j];
+				Adsorbates[CurrentSystem][m].Atoms[j].CFChargeScalingParameter=CFChargeScaling[j];
+	
+				Adsorbates[CurrentSystem][m].Atoms[j].Type=AdsorbatesTransientMoities[count].Atoms[j].Type;
+				Adsorbates[CurrentSystem][m].Atoms[j].Fixed.x=Components[CurrentComponent].Fixed[j];
+				Adsorbates[CurrentSystem][m].Atoms[j].Fixed.y=Components[CurrentComponent].Fixed[j];
+				Adsorbates[CurrentSystem][m].Atoms[j].Fixed.z=Components[CurrentComponent].Fixed[j];
+				Adsorbates[CurrentSystem][m].Atoms[j].Charge=AdsorbatesTransientMoities[count].Atoms[j].Charge;
+				NumberOfPseudoAtomsType[CurrentSystem][type]++;
+			}
+			
+			// modify the degrees of freedom
+			 for(j=0;j<Components[CurrentComponent].NumberOfGroups;j++)
+			  {
+				// Add new degrees of freedom accounting from transient->moieties
+				if(Components[CurrentComponent].Groups[j].Rigid)
+				{
+				  DegreesOfFreedomAdsorbates[CurrentSystem]+=3;
+				  DegreesOfFreedomTranslation[CurrentSystem]+=3;
+				  DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]+=3;
+				  DegreesOfFreedom[CurrentSystem]+=3;
+														   
+				  DegreesOfFreedomRotation[CurrentSystem]+=Components[CurrentComponent].Groups[j].RotationalDegreesOfFreedom;
+				  DegreesOfFreedomAdsorbates[CurrentSystem]+=Components[CurrentComponent].Groups[j].RotationalDegreesOfFreedom;
+				  DegreesOfFreedomRotationalAdsorbates[CurrentSystem]+=Components[CurrentComponent].Groups[j].RotationalDegreesOfFreedom;
+				  DegreesOfFreedom[CurrentSystem]+=Components[CurrentComponent].Groups[j].RotationalDegreesOfFreedom;
+				}
+				else
+				{
+				  DegreesOfFreedomTranslation[CurrentSystem]+=3*Components[CurrentComponent].Groups[j].NumberOfGroupAtoms;
+				  DegreesOfFreedomAdsorbates[CurrentSystem]+=3*Components[CurrentComponent].Groups[j].NumberOfGroupAtoms;
+				  DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]+=3*Components[CurrentComponent].Groups[j].NumberOfGroupAtoms;
+				  DegreesOfFreedom[CurrentSystem]+=3*Components[CurrentComponent].Groups[j].NumberOfGroupAtoms;
+				}
+				
+				// remove degrees of freedom accounting from former transient
+				if(Components[IndexExtraComponent[Comp]].Groups[j].Rigid)
+				{
+				  DegreesOfFreedomAdsorbates[CurrentSystem]-=3;
+				  DegreesOfFreedomTranslation[CurrentSystem]-=3;
+				  DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]-=3;
+				  DegreesOfFreedom[CurrentSystem]-=3;
+														   
+				  DegreesOfFreedomRotation[CurrentSystem]-=Components[IndexExtraComponent[Comp]].Groups[j].RotationalDegreesOfFreedom;
+				  DegreesOfFreedomAdsorbates[CurrentSystem]-=Components[IndexExtraComponent[Comp]].Groups[j].RotationalDegreesOfFreedom;
+				  DegreesOfFreedomRotationalAdsorbates[CurrentSystem]-=Components[IndexExtraComponent[Comp]].Groups[j].RotationalDegreesOfFreedom;
+				  DegreesOfFreedom[CurrentSystem]-=Components[IndexExtraComponent[Comp]].Groups[j].RotationalDegreesOfFreedom;
+				}
+				else
+				{
+				  DegreesOfFreedomTranslation[CurrentSystem]-=3*Components[IndexExtraComponent[Comp]].Groups[j].NumberOfGroupAtoms;
+				  DegreesOfFreedomAdsorbates[CurrentSystem]-=3*Components[IndexExtraComponent[Comp]].Groups[j].NumberOfGroupAtoms;
+				  DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]-=3*Components[IndexExtraComponent[Comp]].Groups[j].NumberOfGroupAtoms;
+				  DegreesOfFreedom[CurrentSystem]-=3*Components[IndexExtraComponent[Comp]].Groups[j].NumberOfGroupAtoms;
+				}
+				
+			  }	
+			
+			// update the center of mass
+			UpdateGroupCenterOfMassAdsorbate(m);
+
+			// compute the quaternion (orientation) from the positions
+			ComputeQuaternionAdsorbate(m);
+							
+			// Update number of atoms and so one (remove atoms and moities of transient component).				
+			nr_atoms=Components[IndexExtraComponent[Comp]].NumberOfAtoms;
+			NumberOfAtomsPerSystem[CurrentSystem]-=nr_atoms;
+			NumberOfChargesPerSystem[CurrentSystem]-=Components[CurrentComponent].NumberOfCharges;
+			NumberOfBondDipolesPerSystem[CurrentSystem]-=Components[CurrentComponent].NumberOfBondDipoles;
+			
+			Components[IndexExtraComponent[Comp]].NumberOfMolecules[CurrentSystem]--;
+			
+			for(j=0;j<Components[IndexExtraComponent[Comp]].NumberOfAtoms;j++)
+			{
+				type=Components[IndexExtraComponent[Comp]].Type[j];
+				NumberOfPseudoAtomsType[CurrentSystem][type]--;
+			}
+		}
+				
+	}
+	 
+	// update the maximum amount of atoms (maximum over all systems)
+	LargestNumberOfCoulombicSites=NumberOfChargesPerSystem[CurrentSystem];
+	LargestNumberOfBondDipoleSites=NumberOfBondDipolesPerSystem[CurrentSystem];
+	
+	for(i=0;i<Framework[CurrentSystem].NumberOfFrameworks;i++)
+	{
+		LargestNumberOfCoulombicSites+=Framework[CurrentSystem].NumberOfCharges[i];
+		LargestNumberOfBondDipoleSites+=Framework[CurrentSystem].NumberOfBondDipoles[i];
+	}
+
+	// if the number is largest than the currently allocated memory reallocate the memory for Ewald
+	// the hard-coded default here is to extend the arrays with 256 atoms
+	 
+	if(LargestNumberOfCoulombicSites>=MaxNumberOfCoulombicSites)
+	{
+		MaxNumberOfCoulombicSites+=MAX2(MaxNumberOfBeads,512);
+		if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+		ReallocateEwaldChargeMemory();
+	}
+	
+	if(LargestNumberOfBondDipoleSites>=MaxNumberOfBondDipoleSites)
+	{
+		MaxNumberOfBondDipoleSites+=MAX2(MaxNumberOfBeads,512);
+			if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+				ReallocateEwaldBondDipoleMemory();
+	}
+	 
+	 
+	 if((Ensemble[CurrentSystem]==MuPT)||(Ensemble[CurrentSystem]==MuPTPR)||(Ensemble[CurrentSystem]==MuVT))
+	 {
+		InitializeNoseHooverCurrentSystem();
+	 }
+ 
+	 for(i=0;i<NumberTransientMoities[0];i++)
+	 {
+			AdsorbatesTransientMoities[i].Atoms = NULL;
+			AdsorbatesTransientMoities[i].Groups = NULL;
+	 }
+	
+	 free(AdsorbatesTransientMoities);
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeMassTransientMoities    (Added by A. de Izarra)      					 	 	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialize the mass of transient moities, to be the mass of water molecule				 *
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *	
+ *********************************************************************************************************/
+void InitializeMassTransientMoities(int NumberOldComponent)
+{	
+	// The mass of the transient molecule has the mass of water
+	
+	// for water->ions:  keep water mass during alchemical process and switch to mass of ions at the end.
+	// for ions->water:  switch at the beginning of the process the mass of ions to water.
+	
+	int i,j,k;
+	REAL mass,total_mass;
+	total_mass=0.0;
+	int index;
+	int atom_count;
+	int A;
+	
+	// Set up the mass of the pseudo atom. (corresponding to mass of water)
+	for(i=0;i<NumberExtraComponents;i++)
+	{
+		atom_count = -1;
+		index = (InitialPseudoAtoms) + i*(TransientMoleculeNbAtoms);
+		for(j=index;j<index+TransientMoleculeNbAtoms;j++)
+		{
+				atom_count++;
+				PseudoAtoms[j].Mass=PseudoAtoms[Components[SolventIndex].Type[atom_count]].Mass;
+		}
+	}
+	// Set up the mass of the transient component.
+	for(i=0;i<NumberExtraComponents;i++)
+	{
+		CurrentComponent = IndexExtraComponent[i];
+			
+		// In order to go from water -> ions, the transient components have the mass of ions.
+		Components[CurrentComponent].Mass=Components[SolventIndex].Mass;
+						
+		for(j=0;j<Components[CurrentComponent].NumberOfGroups;j++)
+		{
+			Components[CurrentComponent].Groups[j].Mass=0.0;
+			for(k=0;k<Components[CurrentComponent].Groups[j].NumberOfGroupAtoms;k++)
+			{
+				A=Components[CurrentComponent].Groups[j].Atoms[k];
+				Components[CurrentComponent].Groups[j].Mass+=PseudoAtoms[Components[CurrentComponent].Type[A]].Mass;
+			}
+		}
+	}
+}
+
+/*********************************************************************************************************
+ * Name       | EndMassTransientMoities    (Added by A. de Izarra)      					 	 	 	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | If the final transient moities are ions -> update the mass to ions.				 		 *
+ * 			  | If the final transient moities are water -> keep the mass of water.						 *	
+ * Parameters | int	NumberOldComponent => determines if old component is water (NumberOldComponent=1)    *
+ * 			  |	to be transformed into ions or ions (NumberOldComponent=2) to be transformed into water. *	
+ *********************************************************************************************************/
+void EndMassTransientMoities(int NumberOldComponent)
+{	
+	// The mass of the transient molecule are the mass of the new component.
+	int i,j,k;
+	REAL mass,total_mass;
+	total_mass=0.0;
+	int index;
+	int atom_count;
+	int A;
+	
+	if(NumberOldComponent == 1)
+	{
+		// Set up the mass of the pseudo atom. (corresponding to mass of ions)
+		for(i=0;i<NumberExtraComponents;i++)
+		{
+			index = (InitialPseudoAtoms) + i*(TransientMoleculeNbAtoms);
+			for(j=index;j<index+TransientMoleculeNbAtoms;j++)
+			{
+				
+				//The mass of the first atom is the mass of the ion.
+				if(j==index)
+				{   
+					PseudoAtoms[j].Mass=PseudoAtoms[Components[SaltIndex[CurrentAlchemicalReaction][i]].Type[0]].Mass;
+				}
+				else
+				{
+					PseudoAtoms[j].Mass=0.0;
+				}
+			}
+		}
+		// Set up the mass of the transient component.
+		for(i=0;i<NumberExtraComponents;i++)
+		{
+			CurrentComponent = IndexExtraComponent[i];
+	
+			// In order to go from water -> ions, the transient components have the mass of ions.
+			Components[CurrentComponent].Mass=Components[SaltIndex[CurrentAlchemicalReaction][i]].Mass;
+
+			for(j=0;j<Components[CurrentComponent].NumberOfGroups;j++)
+			{
+				Components[CurrentComponent].Groups[j].Mass=0.0;
+				
+				for(k=0;k<Components[CurrentComponent].Groups[j].NumberOfGroupAtoms;k++)
+				{
+					A=Components[CurrentComponent].Groups[j].Atoms[k];
+					Components[CurrentComponent].Groups[j].Mass+=PseudoAtoms[Components[CurrentComponent].Type[A]].Mass;
+				}
+			}
+		}
+	}
+}
+
+void UpdateInertiaTensorGroups(int comp)
+{		
+  int j,k,ill;
+  REAL Mass,TotalMass,rotxyz,temp,rotall,rotlim;
+  VECTOR com,pos;
+  REAL_MATRIX3x3 eigenvectors;
+  VECTOR eigenvalues,dr;
+  int atom_nr;
+
+
+  for(j=0;j<Components[comp].NumberOfGroups;j++)
+  {
+    for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+    {
+		atom_nr=Components[comp].Groups[j].Atoms[k];
+		Components[comp].Positions[atom_nr]=SolventBodyfixedPositions[j][atom_nr];
+	}
+  }
+  
+  for(j=0;j<Components[comp].NumberOfGroups;j++)
+  {
+    TotalMass=0.0;
+    com.x=com.y=com.z=0.0;
+
+    for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+    {
+      atom_nr=Components[comp].Groups[j].Atoms[k];
+      Mass=PseudoAtoms[Components[comp].Type[atom_nr]].Mass;
+
+      com.x+=Mass*Components[comp].Positions[atom_nr].x;
+      com.y+=Mass*Components[comp].Positions[atom_nr].y;
+      com.z+=Mass*Components[comp].Positions[atom_nr].z;
+ 
+      TotalMass+=Mass;
+    }
+    com.x/=TotalMass;
+    com.y/=TotalMass;
+    com.z/=TotalMass;  
+	
+    Components[comp].Groups[j].InertiaTensor.ax=0.0;
+    Components[comp].Groups[j].InertiaTensor.bx=0.0;
+    Components[comp].Groups[j].InertiaTensor.cx=0.0;
+    Components[comp].Groups[j].InertiaTensor.ay=0.0;
+    Components[comp].Groups[j].InertiaTensor.by=0.0;
+    Components[comp].Groups[j].InertiaTensor.cy=0.0;
+    Components[comp].Groups[j].InertiaTensor.az=0.0;
+    Components[comp].Groups[j].InertiaTensor.bz=0.0;
+    Components[comp].Groups[j].InertiaTensor.cz=0.0;
+    for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+    {
+      atom_nr=Components[comp].Groups[j].Atoms[k];
+      dr.x=Components[comp].Positions[atom_nr].x-com.x;
+      dr.y=Components[comp].Positions[atom_nr].y-com.y;
+      dr.z=Components[comp].Positions[atom_nr].z-com.z;
+
+      Mass=PseudoAtoms[Components[comp].Type[atom_nr]].Mass;
+
+      Components[comp].Groups[j].InertiaTensor.ax+=Mass*dr.x*dr.x;
+      Components[comp].Groups[j].InertiaTensor.bx+=Mass*dr.y*dr.x;
+      Components[comp].Groups[j].InertiaTensor.cx+=Mass*dr.z*dr.x;
+      Components[comp].Groups[j].InertiaTensor.ay+=Mass*dr.x*dr.y;
+      Components[comp].Groups[j].InertiaTensor.by+=Mass*dr.y*dr.y;
+      Components[comp].Groups[j].InertiaTensor.cy+=Mass*dr.z*dr.y;
+      Components[comp].Groups[j].InertiaTensor.az+=Mass*dr.x*dr.z;
+      Components[comp].Groups[j].InertiaTensor.bz+=Mass*dr.y*dr.z;
+      Components[comp].Groups[j].InertiaTensor.cz+=Mass*dr.z*dr.z;
+    }
+
+    // the local body frame is taken to be that in which the rotational inertia tensor is diagonal
+    EigenSystem3x3(Components[comp].Groups[j].InertiaTensor,&eigenvectors,&eigenvalues);
+    Components[comp].Groups[j].InertiaVector.x=0.0;
+    Components[comp].Groups[j].InertiaVector.y=0.0;
+    Components[comp].Groups[j].InertiaVector.z=0.0;          
+
+    for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+    {
+      atom_nr=Components[comp].Groups[j].Atoms[k];
+      dr.x=Components[comp].Positions[atom_nr].x-com.x;
+      dr.y=Components[comp].Positions[atom_nr].y-com.y;
+      dr.z=Components[comp].Positions[atom_nr].z-com.z;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Positions[atom_nr]=pos;
+      atom_nr=Components[comp].Groups[j].Atoms[k];
+      Mass=PseudoAtoms[Components[comp].Type[atom_nr]].Mass;
+
+      Components[comp].Groups[j].InertiaVector.x+=Mass*(SQR(pos.y)+SQR(pos.z));
+      Components[comp].Groups[j].InertiaVector.y+=Mass*(SQR(pos.x)+SQR(pos.z));
+      Components[comp].Groups[j].InertiaVector.z+=Mass*(SQR(pos.x)+SQR(pos.y));
+    }
+    for(k=0;k<Components[comp].Groups[j].NumberOfPermanentDipoles;k++)
+    {
+      dr.x=Components[comp].Groups[j].PermanentDipolePositions[k].x-com.x;
+      dr.y=Components[comp].Groups[j].PermanentDipolePositions[k].y-com.y;
+      dr.z=Components[comp].Groups[j].PermanentDipolePositions[k].z-com.z;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Groups[j].PermanentDipolePositions[k]=pos;
+
+      dr.x=Components[comp].Groups[j].PermanentDipoles[k].x;
+      dr.y=Components[comp].Groups[j].PermanentDipoles[k].y;
+      dr.z=Components[comp].Groups[j].PermanentDipoles[k].z;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Groups[j].PermanentDipoles[k].x=pos.x;
+      Components[comp].Groups[j].PermanentDipoles[k].y=pos.y;
+      Components[comp].Groups[j].PermanentDipoles[k].z=pos.z;
+    }
+    for(k=0;k<Components[comp].Groups[j].NumberOfPolarizabilities;k++)
+    {
+      dr.x=Components[comp].Groups[j].PolarizabilityPositions[k].x-com.x;
+      dr.y=Components[comp].Groups[j].PolarizabilityPositions[k].y-com.y;
+      dr.z=Components[comp].Groups[j].PolarizabilityPositions[k].z-com.z;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Groups[j].PolarizabilityPositions[k]=pos;
+
+      dr.x=Components[comp].Groups[j].Polarizabilites[k].ax;
+      dr.y=Components[comp].Groups[j].Polarizabilites[k].ay;
+      dr.z=Components[comp].Groups[j].Polarizabilites[k].az;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Groups[j].Polarizabilites[k].ax=pos.x;
+      Components[comp].Groups[j].Polarizabilites[k].ay=pos.y;
+      Components[comp].Groups[j].Polarizabilites[k].az=pos.z;
+
+      dr.x=Components[comp].Groups[j].Polarizabilites[k].bx;
+      dr.y=Components[comp].Groups[j].Polarizabilites[k].by;
+      dr.z=Components[comp].Groups[j].Polarizabilites[k].bz;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Groups[j].Polarizabilites[k].bx=pos.x;
+      Components[comp].Groups[j].Polarizabilites[k].by=pos.y;
+      Components[comp].Groups[j].Polarizabilites[k].bz=pos.z;
+
+      dr.x=Components[comp].Groups[j].Polarizabilites[k].cx;
+      dr.y=Components[comp].Groups[j].Polarizabilites[k].cy;
+      dr.z=Components[comp].Groups[j].Polarizabilites[k].cz;
+      pos.x=eigenvectors.ax*dr.x+eigenvectors.bx*dr.y+eigenvectors.cx*dr.z;
+      pos.y=eigenvectors.ay*dr.x+eigenvectors.by*dr.y+eigenvectors.cy*dr.z;
+      pos.z=eigenvectors.az*dr.x+eigenvectors.bz*dr.y+eigenvectors.cz*dr.z;
+      if(fabs(pos.x)<1e-8) pos.x=0.0;
+      if(fabs(pos.y)<1e-8) pos.y=0.0;
+      if(fabs(pos.z)<1e-8) pos.z=0.0;
+      Components[comp].Groups[j].Polarizabilites[k].cx=pos.x;
+      Components[comp].Groups[j].Polarizabilites[k].cy=pos.y;
+      Components[comp].Groups[j].Polarizabilites[k].cz=pos.z;
+    }
+
+    // set axis system: Ixx >= Iyy >= Izz
+    rotxyz=MAX3(Components[comp].Groups[j].InertiaVector.x,Components[comp].Groups[j].InertiaVector.y,
+                Components[comp].Groups[j].InertiaVector.z);
+    if(rotxyz>=Components[comp].Groups[j].InertiaVector.x)
+    {
+      if(Components[comp].Groups[j].InertiaVector.y>=rotxyz)
+      {
+        for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+        {
+          atom_nr=Components[comp].Groups[j].Atoms[k];
+          temp=Components[comp].Positions[atom_nr].x;
+          Components[comp].Positions[atom_nr].x=Components[comp].Positions[atom_nr].y;
+          Components[comp].Positions[atom_nr].y=-temp;
+        }
+        for(k=0;k<Components[comp].Groups[j].NumberOfPermanentDipoles;k++)
+        {
+          temp=Components[comp].Groups[j].PermanentDipolePositions[k].x;
+          Components[comp].Groups[j].PermanentDipolePositions[k].x=Components[comp].Groups[j].PermanentDipolePositions[k].y;
+          Components[comp].Groups[j].PermanentDipolePositions[k].y=-temp;
+
+          temp=Components[comp].Groups[j].PermanentDipoles[k].x;
+          Components[comp].Groups[j].PermanentDipoles[k].x=Components[comp].Groups[j].PermanentDipoles[k].y;
+          Components[comp].Groups[j].PermanentDipoles[k].y=-temp;
+        }
+        for(k=0;k<Components[comp].Groups[j].NumberOfPolarizabilities;k++)
+        {
+          temp=Components[comp].Groups[j].PolarizabilityPositions[k].x;
+          Components[comp].Groups[j].PolarizabilityPositions[k].x=Components[comp].Groups[j].PolarizabilityPositions[k].y;
+          Components[comp].Groups[j].PolarizabilityPositions[k].y=-temp;
+
+          temp=Components[comp].Groups[j].Polarizabilites[k].ax;
+          Components[comp].Groups[j].Polarizabilites[k].ax=Components[comp].Groups[j].Polarizabilites[k].ay;
+          Components[comp].Groups[j].Polarizabilites[k].ay=-temp;
+          temp=Components[comp].Groups[j].Polarizabilites[k].bx;
+          Components[comp].Groups[j].Polarizabilites[k].bx=Components[comp].Groups[j].Polarizabilites[k].by;
+          Components[comp].Groups[j].Polarizabilites[k].by=-temp;
+          temp=Components[comp].Groups[j].Polarizabilites[k].cx;
+          Components[comp].Groups[j].Polarizabilites[k].cx=Components[comp].Groups[j].Polarizabilites[k].cy;
+          Components[comp].Groups[j].Polarizabilites[k].cy=-temp;
+        }
+
+        Components[comp].Groups[j].InertiaVector.y=Components[comp].Groups[j].InertiaVector.x;
+        Components[comp].Groups[j].InertiaVector.x=rotxyz;
+      }
+      else if(Components[comp].Groups[j].InertiaVector.z>=rotxyz)
+      {
+        for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+        {
+          atom_nr=Components[comp].Groups[j].Atoms[k];
+          temp=Components[comp].Positions[atom_nr].x;
+          Components[comp].Positions[atom_nr].x=Components[comp].Positions[atom_nr].z;
+          Components[comp].Positions[atom_nr].z=-temp;
+        }
+        for(k=0;k<Components[comp].Groups[j].NumberOfPermanentDipoles;k++)
+        {
+          temp=Components[comp].Groups[j].PermanentDipolePositions[k].x;
+          Components[comp].Groups[j].PermanentDipolePositions[k].x=Components[comp].Groups[j].PermanentDipolePositions[k].z;
+          Components[comp].Groups[j].PermanentDipolePositions[k].z=-temp;
+
+          temp=Components[comp].Groups[j].PermanentDipoles[k].x;
+          Components[comp].Groups[j].PermanentDipoles[k].x=Components[comp].Groups[j].PermanentDipoles[k].z;
+          Components[comp].Groups[j].PermanentDipoles[k].z=-temp;
+        }
+        for(k=0;k<Components[comp].Groups[j].NumberOfPolarizabilities;k++)
+        {
+          temp=Components[comp].Groups[j].PolarizabilityPositions[k].x;
+          Components[comp].Groups[j].PolarizabilityPositions[k].x=Components[comp].Groups[j].PolarizabilityPositions[k].z;
+          Components[comp].Groups[j].PolarizabilityPositions[k].z=-temp;
+
+          temp=Components[comp].Groups[j].Polarizabilites[k].ax;
+          Components[comp].Groups[j].Polarizabilites[k].ax=Components[comp].Groups[j].Polarizabilites[k].az;
+          Components[comp].Groups[j].Polarizabilites[k].az=-temp;
+          temp=Components[comp].Groups[j].Polarizabilites[k].bx;
+          Components[comp].Groups[j].Polarizabilites[k].bx=Components[comp].Groups[j].Polarizabilites[k].bz;
+          Components[comp].Groups[j].Polarizabilites[k].bz=-temp;
+          temp=Components[comp].Groups[j].Polarizabilites[k].cx;
+          Components[comp].Groups[j].Polarizabilites[k].cx=Components[comp].Groups[j].Polarizabilites[k].cz;
+          Components[comp].Groups[j].Polarizabilites[k].cz=-temp;
+        }
+
+        Components[comp].Groups[j].InertiaVector.z=Components[comp].Groups[j].InertiaVector.x;
+        Components[comp].Groups[j].InertiaVector.x=rotxyz;
+      }
+    }
+    if(Components[comp].Groups[j].InertiaVector.z>Components[comp].Groups[j].InertiaVector.y)
+    {
+      for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+      {
+        atom_nr=Components[comp].Groups[j].Atoms[k];
+        temp=Components[comp].Positions[atom_nr].y;
+        Components[comp].Positions[atom_nr].y=Components[comp].Positions[atom_nr].z;
+        Components[comp].Positions[atom_nr].z=-temp;
+      }
+      for(k=0;k<Components[comp].Groups[j].NumberOfPermanentDipoles;k++)
+      {
+        temp=Components[comp].Groups[j].PermanentDipolePositions[k].y;
+        Components[comp].Groups[j].PermanentDipolePositions[k].y=Components[comp].Groups[j].PermanentDipolePositions[k].z;
+        Components[comp].Groups[j].PermanentDipolePositions[k].z=-temp;
+
+        temp=Components[comp].Groups[j].PermanentDipoles[k].y;
+        Components[comp].Groups[j].PermanentDipoles[k].y=Components[comp].Groups[j].PermanentDipoles[k].z;
+        Components[comp].Groups[j].PermanentDipoles[k].z=-temp;
+      }
+      for(k=0;k<Components[comp].Groups[j].NumberOfPolarizabilities;k++)
+      {
+        temp=Components[comp].Groups[j].PolarizabilityPositions[k].y;
+        Components[comp].Groups[j].PolarizabilityPositions[k].y=Components[comp].Groups[j].PolarizabilityPositions[k].z;
+        Components[comp].Groups[j].PolarizabilityPositions[k].z=-temp;
+
+        temp=Components[comp].Groups[j].Polarizabilites[k].ay;
+        Components[comp].Groups[j].Polarizabilites[k].ay=Components[comp].Groups[j].Polarizabilites[k].az;
+        Components[comp].Groups[j].Polarizabilites[k].az=-temp;
+        temp=Components[comp].Groups[j].Polarizabilites[k].by;
+        Components[comp].Groups[j].Polarizabilites[k].by=Components[comp].Groups[j].Polarizabilites[k].bz;
+        Components[comp].Groups[j].Polarizabilites[k].bz=-temp;
+        temp=Components[comp].Groups[j].Polarizabilites[k].cy;
+        Components[comp].Groups[j].Polarizabilites[k].cy=Components[comp].Groups[j].Polarizabilites[k].cz;
+        Components[comp].Groups[j].Polarizabilites[k].cz=-temp;
+      }
+
+      temp=Components[comp].Groups[j].InertiaVector.z;
+      Components[comp].Groups[j].InertiaVector.z=Components[comp].Groups[j].InertiaVector.y;
+      Components[comp].Groups[j].InertiaVector.y=temp;
+    }
+
+    // remove singularities
+    rotlim=MAX2((REAL)1.0e-2,Components[comp].Groups[j].InertiaVector.x+Components[comp].Groups[j].InertiaVector.y+
+            Components[comp].Groups[j].InertiaVector.z)*1.0e-5;
+
+    if(Components[comp].Groups[j].InertiaVector.x<rotlim)
+      Components[comp].Groups[j].InverseInertiaVector.x=0.0;
+    else
+      Components[comp].Groups[j].InverseInertiaVector.x=1.0/Components[comp].Groups[j].InertiaVector.x;
+
+    if(Components[comp].Groups[j].InertiaVector.y<rotlim)
+      Components[comp].Groups[j].InverseInertiaVector.y=0.0;
+    else
+      Components[comp].Groups[j].InverseInertiaVector.y=1.0/Components[comp].Groups[j].InertiaVector.y;
+
+    if(Components[comp].Groups[j].InertiaVector.z<rotlim)
+      Components[comp].Groups[j].InverseInertiaVector.z=0.0;
+    else
+      Components[comp].Groups[j].InverseInertiaVector.z=1.0/Components[comp].Groups[j].InertiaVector.z;
+
+
+    if((Components[comp].Groups[j].InertiaVector.x+Components[comp].Groups[j].InertiaVector.y+Components[comp].Groups[j].InertiaVector.z)>1.0e-5)
+      rotall=Components[comp].Groups[j].InertiaVector.x+Components[comp].Groups[j].InertiaVector.y+Components[comp].Groups[j].InertiaVector.z;
+    else
+      rotall=1.0;
+
+    // determine point-particle,linear-group or nonlinear-group
+    ill=0;
+    if(Components[comp].Groups[j].InertiaVector.x/rotall<1.0e-5) ill++;
+    if(Components[comp].Groups[j].InertiaVector.y/rotall<1.0e-5) ill++;
+    if(Components[comp].Groups[j].InertiaVector.z/rotall<1.0e-5) ill++;
+
+    switch(ill)
+    {
+      case 0:
+        Components[comp].Groups[j].Type=NONLINEAR_MOLECULE;
+        break;
+      case 1:
+        Components[comp].Groups[j].Type=LINEAR_MOLECULE;
+        break;
+      case 2:
+      default:
+        Components[comp].Groups[j].Type=POINT_PARTICLE;
+        break;
+    }
+  }  
+}
+
+/*********************************************************************************************************
+ * Name       | AllocateTransientComponentMemory    (Added by A. de Izarra)      					 	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Allocate memory to store information component for the molecules that undergo			 *
+ * 			  | the alchemical transformation.															 *	
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void AllocateTransientComponentMemory(void)
+{
+   int index_salt = -1;
+   int index_type;
+   int count = -1;
+   int comp,i,j,k,n,nr;
+   int A,B,C,D,temp;
+   int A1,A2,B1,B2,C1,C2;
+   char index_salt_store[2];
+   VECTOR dr;
+	
+   // Reallocate memory to store the transient molecule: two type of transient molecules corresponding to cation/water and anion/water.  
+   Components=(COMPONENT*)realloc(Components,(NumberOfComponents+NumberExtraComponents)*sizeof(COMPONENT));
+ 
+   // We use only the arguments of the structure "Components" useful for the alchemical calculation.
+   for(comp=NumberOfComponents;comp<NumberOfComponents+NumberExtraComponents;comp++)
+   {
+	Components[comp].NumberOfAtoms=Components[SolventIndex].NumberOfAtoms;   
+	   
+    Components[comp].IdealGasRosenbluthWeight=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].IdealGasTotalEnergy=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].PartialPressure=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].FugacityCoefficient=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].BulkFluidDensity=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].Compressibility=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].MolFraction=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].AmountOfExcessMolecules=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+
+    Components[comp].CreateNumberOfMolecules=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].NumberOfMolecules=(int*)calloc(NumberOfSystems,sizeof(int));
+
+    Components[comp].FractionalMolecule=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].CFMoleculePresent=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].CFWangLandauScalingFactor=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].CFBiasingFactors=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+
+    Components[comp].RXMCMoleculesPresent=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].NumberOfRXMCMoleculesPresent=(int*)calloc(NumberOfSystems,sizeof(int));
+
+    Components[comp].MOLEC_PER_UC_TO_MOL_PER_KG=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].MOLEC_PER_UC_TO_MILLIGRAM_PER_GRAM_OF_FRAMEWORK=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].MOLEC_PER_UC_TO_CC_STP_G=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].MOLEC_PER_UC_TO_CC_STP_CC=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].MOL_PER_KG_TO_CC_STP_G=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+    Components[comp].MOL_PER_KG_TO_CC_STP_CC=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+
+    Components[comp].BlockPockets=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].ComputeFreeEnergyProfile=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].BlockPocketsFilename=(char(*)[256])calloc(NumberOfSystems,sizeof(char[256]));
+    Components[comp].NumberOfBlockCenters=(int*)calloc(NumberOfSystems,sizeof(int));
+    Components[comp].BlockDistance=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+    Components[comp].BlockCenters=(VECTOR**)calloc(NumberOfSystems,sizeof(VECTOR*));
+    
+    Components[comp].CFLambdaHistogramSize=Components[SolventIndex].CFLambdaHistogramSize;
+
+	Components[comp].MaximumCBMCChangeBondLength=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].MaximumCBMCChangeBendAngle=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].MaximumCBMCRotationOnCone=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].CBMCChangeBondLengthAttempts=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].CBMCChangeBondLengthAccepted=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].CBMCChangeBendAngleAttempts=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].CBMCChangeBendAngleAccepted=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].CBMCRotationOnConeAttempts=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].CBMCRotationOnConeAccepted=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].TotalCBMCChangeBondLengthAttempts=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].TotalCBMCChangeBendAngleAttempts=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].TotalCBMCRotationOnConeAttempts=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].TotalCBMCChangeBondLengthAccepted=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].TotalCBMCChangeBendAngleAccepted=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+	Components[comp].TotalCBMCRotationOnConeAccepted=(REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+
+    for(i=0;i<NumberOfSystems;i++)
+    {
+      Components[comp].BlockPockets[i]=Components[SolventIndex].BlockPockets[i];
+      
+      Components[comp].MaximumCBMCChangeBondLength[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].MaximumCBMCChangeBendAngle[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].MaximumCBMCRotationOnCone[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].CBMCChangeBondLengthAttempts[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].CBMCChangeBondLengthAccepted[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].CBMCChangeBendAngleAttempts[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].CBMCChangeBendAngleAccepted[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].CBMCRotationOnConeAttempts[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].CBMCRotationOnConeAccepted[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].TotalCBMCChangeBondLengthAttempts[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].TotalCBMCChangeBendAngleAttempts[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].TotalCBMCRotationOnConeAttempts[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].TotalCBMCChangeBondLengthAccepted[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].TotalCBMCChangeBendAngleAccepted[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+	  Components[comp].TotalCBMCRotationOnConeAccepted[i]=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+      
+      // start with no defined fractional molecule
+      Components[comp].FractionalMolecule[i]=Components[SolventIndex].FractionalMolecule[i];
+      Components[comp].CFMoleculePresent[i]=Components[SolventIndex].CFMoleculePresent[i];
+      Components[comp].CFWangLandauScalingFactor[i]=Components[SolventIndex].CFWangLandauScalingFactor[i];
+    }
+	 
+    strcpy(Components[comp].MoleculeDefinition,"Transient");
+    strcpy(Components[comp].Name,"");
+    Components[comp].Swapable=FALSE;
+    Components[comp].Widom=FALSE;
+	Components[comp].ExtraFrameworkMolecule = TRUE;
+	
+    // initialize box restriction to false (the full box is selected)
+    Components[comp].RestrictMoves=FALSE;
+    
+    // initialize the first box to all, the other 3 boxes to empty
+    Components[comp].RestrictMovesToBox=FALSE;
+    Components[comp].BoxAxisABC_Min.x=Components[comp].BoxAxisABC_Min.y=Components[comp].BoxAxisABC_Min.z=0.0;
+    Components[comp].BoxAxisABC_Max.x=Components[comp].BoxAxisABC_Max.y=Components[comp].BoxAxisABC_Max.z=1.0;
+    Components[comp].BoxAxisABC_Min2.x=Components[comp].BoxAxisABC_Min2.y=Components[comp].BoxAxisABC_Min2.z=1.0;
+    Components[comp].BoxAxisABC_Max2.x=Components[comp].BoxAxisABC_Max2.y=Components[comp].BoxAxisABC_Max2.z=0.0;
+    Components[comp].BoxAxisABC_Min3.x=Components[comp].BoxAxisABC_Min3.y=Components[comp].BoxAxisABC_Min3.z=1.0;
+    Components[comp].BoxAxisABC_Max3.x=Components[comp].BoxAxisABC_Max3.y=Components[comp].BoxAxisABC_Max3.z=0.0;
+    Components[comp].BoxAxisABC_Min4.x=Components[comp].BoxAxisABC_Min4.y=Components[comp].BoxAxisABC_Min4.z=1.0;
+    Components[comp].BoxAxisABC_Max4.x=Components[comp].BoxAxisABC_Max4.y=Components[comp].BoxAxisABC_Max4.z=0.0;
+
+    Components[comp].RestrictMovesToPrisms=FALSE;
+    for(j=0;j<MAX_NUMBER_OF_PRISMS;j++)
+    {
+      Components[comp].RestrictMovesToPrism[j]  =Components[SolventIndex].RestrictMovesToPrism[j];
+      Components[comp].RestrictPrismABC_Min[j].x=Components[SolventIndex].RestrictPrismABC_Min[j].x;
+      Components[comp].RestrictPrismABC_Max[j].x=Components[SolventIndex].RestrictPrismABC_Max[j].x;
+    }
+
+    Components[comp].RestrictMovesToCylinders=Components[SolventIndex].RestrictMovesToCylinders;
+    for(j=0;j<MAX_NUMBER_OF_CYLINDERS;j++)
+    {
+      Components[comp].RestrictMovesToCylinder[j]  =Components[SolventIndex].RestrictMovesToCylinder[j];
+      Components[comp].RestrictCylinderABC_Min[j].x=Components[SolventIndex].RestrictCylinderABC_Min[j].x;
+      Components[comp].RestrictCylinderABC_Max[j].x=Components[SolventIndex].RestrictCylinderABC_Max[j].x;
+      Components[comp].RestrictCylinderABC_Min[j].y=Components[SolventIndex].RestrictCylinderABC_Min[j].y;
+      Components[comp].RestrictCylinderABC_Max[j].y=Components[SolventIndex].RestrictCylinderABC_Max[j].y;
+      Components[comp].RestrictCylinderABC_Min[j].z=Components[SolventIndex].RestrictCylinderABC_Min[j].z;
+      Components[comp].RestrictCylinderABC_Max[j].z=Components[SolventIndex].RestrictCylinderABC_Max[j].z;
+      Components[comp].RestrictCylinderCenter[j].x =Components[SolventIndex].RestrictCylinderCenter[j].x; 
+      Components[comp].RestrictCylinderCenter[j].y =Components[SolventIndex].RestrictCylinderCenter[j].y;
+      Components[comp].RestrictCylinderCenter[j].z =Components[SolventIndex].RestrictCylinderCenter[j].z; 
+      Components[comp].RestrictCylinderDirection[j]=Components[SolventIndex].RestrictCylinderDirection[j];
+      Components[comp].RestrictCylinderRadius[j]   =Components[SolventIndex].RestrictCylinderRadius[j];   
+    }
+
+    Components[comp].RestrictMovesToSpheres=FALSE;
+    for(j=0;j<MAX_NUMBER_OF_SPHERES;j++)
+    {
+      Components[comp].RestrictMovesToSphere[j] =Components[SolventIndex].RestrictMovesToSphere[j];
+      Components[comp].RestrictSphereCenter[j].x=Components[SolventIndex].RestrictSphereCenter[j].x;
+      Components[comp].RestrictSphereCenter[j].y=Components[SolventIndex].RestrictSphereCenter[j].y;
+      Components[comp].RestrictSphereCenter[j].z=Components[SolventIndex].RestrictSphereCenter[j].z;
+      Components[comp].RestrictSphereRadius[j]  =Components[SolventIndex].RestrictSphereRadius[j];  
+    }
+	
+    Components[comp].RuizMonteroFactor=Components[SolventIndex].RuizMonteroFactor;
+    Components[comp].UmbrellaFactor=Components[SolventIndex].UmbrellaFactor;
+    Components[comp].InvertBlockPockets=Components[SolventIndex].InvertBlockPockets;
+	
+    Components[comp].Intra14VDWScalingValue=Components[SolventIndex].Intra14VDWScalingValue;
+    Components[comp].Intra14ChargeChargeScalingValue=Components[SolventIndex].Intra14ChargeChargeScalingValue;
+	
+    Components[comp].AnisotropicType=Components[SolventIndex].AnisotropicType;
+    Components[comp].BiasingDirection=Components[SolventIndex].BiasingDirection;
+
+  }
+
+  // Update components definition: the transient molecule have the same definition as solvent, by definition.
+  for(comp=NumberOfComponents;comp<NumberOfComponents+NumberExtraComponents;comp++)
+  {
+	   index_salt++;
+	   Components[comp].CriticalTemperature=Components[SolventIndex].CriticalTemperature;
+	   Components[comp].CriticalPressure=Components[SolventIndex].CriticalPressure;
+	   Components[comp].AcentricFactor= Components[SolventIndex].AcentricFactor;
+				  
+	   Components[comp].NumberOfRigidAtoms=Components[SolventIndex].NumberOfRigidAtoms;
+	   Components[comp].NumberOfFlexibleAtoms=Components[SolventIndex].NumberOfFlexibleAtoms;
+	   
+	   if(Components[comp].ExtraFrameworkMolecule)
+		NumberOfCationComponents++;
+	   else
+		NumberOfAdsorbateComponents++;
+		
+	   strcpy(Components[comp].Name, "TransientMolecule");
+	   sprintf(index_salt_store,"%d",SaltIndex[CurrentAlchemicalReaction][index_salt]);
+	   strcat(Components[comp].Name,index_salt_store);
+	    
+	   // allocate charility-centers
+	   Components[comp].Chirality=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	   Components[comp].ChiralityType=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	   Components[comp].ChiralA=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	   Components[comp].ChiralB=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	   Components[comp].ChiralC=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	   Components[comp].ChiralD=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	   
+	   for(j=0;j<Components[comp].NumberOfAtoms;j++)
+	   {
+		 Components[comp].ChiralityType[j]=NO_CHARILITY;
+		 Components[comp].Chirality[j]=FALSE;
+		 Components[comp].ChiralA[j]=0;
+		 Components[comp].ChiralB[j]=0;
+		 Components[comp].ChiralC[j]=0;
+		 Components[comp].ChiralD[j]=0;
+	   }
+	  
+	  Components[comp].Fixed=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+	  Components[comp].Type=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+      Components[comp].Charge=(REAL*)calloc(Components[comp].NumberOfAtoms,sizeof(REAL));
+      Components[comp].Connectivity=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+      
+		  // allocate bond-connectivity matrix
+		Components[comp].ConnectivityMatrix=(int**)calloc(Components[comp].NumberOfAtoms,sizeof(int*));
+	  for(j=0;j<Components[comp].NumberOfAtoms;j++)
+		Components[comp].ConnectivityMatrix[j]=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+
+	  // set the bond-connectivity to all FALSE at first
+	  for(j=0;j<Components[comp].NumberOfAtoms;j++)
+		for(k=0;k<Components[comp].NumberOfAtoms;k++)
+		  Components[comp].ConnectivityMatrix[j][k]=FALSE;
+		
+	  Components[comp].Positions=(VECTOR*)calloc(Components[comp].NumberOfAtoms,sizeof(VECTOR));
+      Components[comp].group=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
+				 
+      Components[comp].RMCMOL=(VECTOR*)calloc(Components[comp].NumberOfAtoms,sizeof(VECTOR));
+      for(i=0;i<Components[comp].NumberOfAtoms;i++)
+		Components[comp].RMCMOL[i]=Components[SolventIndex].RMCMOL[i];
+      
+      // Attribute number of groups
+      Components[comp].NumberOfGroups=Components[SolventIndex].NumberOfGroups;
+      
+      // Define groups
+      Components[comp].Groups=(GROUP_DEFINITION*)calloc(Components[comp].NumberOfGroups,sizeof(GROUP_DEFINITION));
+	  
+	  for(j=0;j<Components[comp].NumberOfGroups;j++)
+	  {
+		  Components[comp].Groups[j]=Components[SolventIndex].Groups[j];
+		  //Components[comp].Groups[j].Rigid = Components[SolventIndex].Groups[j].Rigid;
+		  //Components[comp].Groups[j].NumberOfGroupAtoms=Components[SolventIndex].Groups[j].NumberOfGroupAtoms;
+		  //Components[comp].Groups[j].NumberOfPermanentDipoles=Components[SolventIndex].Groups[j].NumberOfPermanentDipoles;
+		  //Components[comp].Groups[j].NumberOfPolarizabilities=Components[SolventIndex].Groups[j].NumberOfPolarizabilities;
+		  
+		  if(Components[comp].Groups[j].Rigid)
+			Components[comp].NumberOfRigidAtoms+=Components[comp].Groups[j].NumberOfGroupAtoms;
+		  else
+			Components[comp].NumberOfFlexibleAtoms+=Components[comp].Groups[j].NumberOfGroupAtoms;
+		  
+		  if(Components[comp].Groups[j].NumberOfGroupAtoms>0)
+          {
+			  Components[comp].Groups[j].Atoms=(int*)calloc(Components[comp].Groups[j].NumberOfGroupAtoms,sizeof(int));
+			  
+			  for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
+			  {
+				  
+				Components[comp].Groups[j].Atoms[k] = Components[SolventIndex].Groups[j].Atoms[k];
+				// !!!! TRES IMPORTANT: TYPE D'ATOME
+				index_type = (InitialPseudoAtoms) + index_salt*(Components[SolventIndex].NumberOfAtoms) + k;
+				Components[comp].Type[k]= index_type;
+				// ----------------------
+				//Components[comp].Positions[k]=Components[SolventIndex].Positions[k];
+				Components[comp].group[k]=Components[SolventIndex].group[k];
+			  }
+		  }
+		 
+		  if(Components[comp].Groups[j].NumberOfPermanentDipoles>0)
+		  {
+		    Components[comp].Groups[j].PermanentDipolePositions=(VECTOR*)calloc(Components[comp].Groups[j].NumberOfPermanentDipoles,sizeof(VECTOR));
+		    Components[comp].Groups[j].PermanentDipoles=(VECTOR*)calloc(Components[comp].Groups[j].NumberOfPermanentDipoles,sizeof(VECTOR));
+		    for(k=0;k<Components[comp].Groups[j].NumberOfPermanentDipoles;k++)
+		    {
+				Components[comp].Groups[j].PermanentDipolePositions[k].x=Components[SolventIndex].Groups[j].PermanentDipolePositions[k].x;
+				Components[comp].Groups[j].PermanentDipolePositions[k].y=Components[SolventIndex].Groups[j].PermanentDipolePositions[k].y;
+				Components[comp].Groups[j].PermanentDipolePositions[k].z=Components[SolventIndex].Groups[j].PermanentDipolePositions[k].z;
+				Components[comp].Groups[j].PermanentDipoles[k].x=Components[comp].Groups[j].PermanentDipoles[k].x;
+				Components[comp].Groups[j].PermanentDipoles[k].y=Components[comp].Groups[j].PermanentDipoles[k].y;
+				Components[comp].Groups[j].PermanentDipoles[k].z=Components[comp].Groups[j].PermanentDipoles[k].z;
+		    }
+		  }
+		  
+		  if(Components[comp].Groups[j].NumberOfPolarizabilities>0)
+		  {
+		    Components[comp].Groups[j].PolarizabilityPositions=(VECTOR*)calloc(Components[comp].Groups[j].NumberOfPolarizabilities,sizeof(VECTOR));
+		    Components[comp].Groups[j].Polarizabilites=(REAL_MATRIX3x3*)calloc(Components[comp].Groups[j].NumberOfPolarizabilities,sizeof(REAL_MATRIX3x3));
+		    for(k=0;k<Components[comp].Groups[j].NumberOfPolarizabilities;k++)
+		    {
+				Components[comp].Groups[j].PolarizabilityPositions[k].x=Components[SolventIndex].Groups[j].PolarizabilityPositions[k].x;
+				Components[comp].Groups[j].PolarizabilityPositions[k].y=Components[SolventIndex].Groups[j].PolarizabilityPositions[k].y;
+				Components[comp].Groups[j].PolarizabilityPositions[k].z=Components[SolventIndex].Groups[j].PolarizabilityPositions[k].z;
+				Components[comp].Groups[j].Polarizabilites[k].ax=Components[SolventIndex].Groups[j].Polarizabilites[k].ax;
+				Components[comp].Groups[j].Polarizabilites[k].ay=Components[SolventIndex].Groups[j].Polarizabilites[k].ay;
+				Components[comp].Groups[j].Polarizabilites[k].az=Components[SolventIndex].Groups[j].Polarizabilites[k].az;
+				Components[comp].Groups[j].Polarizabilites[k].by=Components[SolventIndex].Groups[j].Polarizabilites[k].by;
+				Components[comp].Groups[j].Polarizabilites[k].bz=Components[SolventIndex].Groups[j].Polarizabilites[k].bz;
+				Components[comp].Groups[j].Polarizabilites[k].cz=Components[SolventIndex].Groups[j].Polarizabilites[k].cz;
+		    }
+		  }
+	  }
+	   
+	  // fill in charges
+      for(j=0;j<Components[comp].NumberOfAtoms;j++)
+        Components[comp].Charge[j]=PseudoAtoms[Components[SolventIndex].Type[j]].Charge1;
+      
+      Components[comp].HasCharges=Components[SolventIndex].HasCharges;
+      for(j=0;j<Components[comp].NumberOfAtoms;j++)
+        Components[comp].HasCharges|=PseudoAtoms[Components[SolventIndex].Type[j]].HasCharges;
+      
+      Components[comp].NumberOfCharges=0;
+      for(j=0;j<Components[comp].NumberOfAtoms;j++)
+        if(PseudoAtoms[Components[comp].Type[j]].HasCharges) Components[comp].NumberOfCharges++;
+      
+      Components[comp].IsPolarizable=FALSE;
+      for(j=0;j<Components[comp].NumberOfAtoms;j++)
+        Components[comp].IsPolarizable|=PseudoAtoms[Components[SolventIndex].Type[j]].IsPolarizable;
+	  
+	  // Allocate the number of interaction
+	  Components[comp].NumberOfChiralityCenters=Components[SolventIndex].NumberOfChiralityCenters;
+	  Components[comp].NumberOfBonds=Components[SolventIndex].NumberOfBonds;
+	  Components[comp].NumberOfBondDipoles=Components[SolventIndex].NumberOfBondDipoles;
+	  Components[comp].NumberOfBends=Components[SolventIndex].NumberOfBends;
+	  Components[comp].NumberOfUreyBradleys=Components[SolventIndex].NumberOfUreyBradleys;
+	  Components[comp].NumberOfInversionBends=Components[SolventIndex].NumberOfInversionBends;
+	  Components[comp].NumberOfTorsions=Components[SolventIndex].NumberOfTorsions;
+	  Components[comp].NumberOfImproperTorsions=Components[SolventIndex].NumberOfImproperTorsions;
+	  Components[comp].NumberOfBondBonds=Components[SolventIndex].NumberOfBondBonds;
+	  Components[comp].NumberOfBondBends=Components[SolventIndex].NumberOfBondBends;
+	  Components[comp].NumberOfBendBends=Components[SolventIndex].NumberOfBendBends;
+	  Components[comp].NumberOfBondTorsions=Components[SolventIndex].NumberOfBondTorsions;
+	  Components[comp].NumberOfBendTorsions=Components[SolventIndex].NumberOfBendTorsions;
+	  Components[comp].NumberOfIntraVDW=Components[SolventIndex].NumberOfIntraVDW;
+	  Components[comp].NumberOfIntraChargeCharge=Components[SolventIndex].NumberOfIntraChargeCharge;
+	  Components[comp].NumberOfIntraChargeBondDipole=Components[SolventIndex].NumberOfIntraChargeBondDipole;
+	  Components[comp].NumberOfIntraBondDipoleBondDipole=Components[SolventIndex].NumberOfIntraBondDipoleBondDipole;
+	  
+	  // allocate bonds
+	  Components[comp].Bonds=(PAIR*)calloc(Components[comp].NumberOfBonds,sizeof(PAIR));
+	  Components[comp].BondType=(int*)calloc(Components[comp].NumberOfBonds,sizeof(int));
+	  Components[comp].BondArguments=(REAL(*)[MAX_BOND_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBonds,
+	 								 sizeof(REAL[MAX_BOND_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate bond-dipoles
+	  Components[comp].BondDipoles=(PAIR*)calloc(Components[comp].NumberOfBondDipoles,sizeof(PAIR));
+	  Components[comp].BondDipoleMagnitude=(REAL*)calloc(Components[comp].NumberOfBondDipoles,sizeof(REAL));
+	  
+	  
+	  // allocate bends
+	  Components[comp].Bends=(QUAD*)calloc(Components[comp].NumberOfBends,sizeof(QUAD));
+	  Components[comp].BendType=(int*)calloc(Components[comp].NumberOfBends,sizeof(int));
+	  Components[comp].BendArguments=(REAL(*)[MAX_BEND_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBends,
+	 								 sizeof(REAL[MAX_BEND_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate urey-bradleys
+	  Components[comp].UreyBradleys=(TRIPLE*)calloc(Components[comp].NumberOfUreyBradleys,sizeof(TRIPLE));
+	  Components[comp].UreyBradleyType=(int*)calloc(Components[comp].NumberOfUreyBradleys,sizeof(int));
+	  Components[comp].UreyBradleyArguments=(REAL(*)[MAX_UREYBRADLEY_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfUreyBradleys,
+	 								 sizeof(REAL[MAX_UREYBRADLEY_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate inversion-bends
+	  Components[comp].InversionBends=(QUAD*)calloc(Components[comp].NumberOfInversionBends,sizeof(QUAD));
+	  Components[comp].InversionBendType=(int*)calloc(Components[comp].NumberOfInversionBends,sizeof(int));
+	  Components[comp].InversionBendArguments=(REAL(*)[MAX_INVERSION_BEND_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfInversionBends,
+	 								 sizeof(REAL[MAX_INVERSION_BEND_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate torsions
+	  Components[comp].Torsions=(QUAD*)calloc(Components[comp].NumberOfTorsions,sizeof(QUAD));
+	  Components[comp].TorsionType=(int*)calloc(Components[comp].NumberOfTorsions,sizeof(int));
+	  Components[comp].TorsionArguments=(REAL(*)[MAX_TORSION_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfTorsions,
+	 								 sizeof(REAL[MAX_TORSION_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate improper torsions
+	  Components[comp].ImproperTorsions=(QUAD*)calloc(Components[comp].NumberOfImproperTorsions,sizeof(QUAD));
+	  Components[comp].ImproperTorsionType=(int*)calloc(Components[comp].NumberOfImproperTorsions,sizeof(int));
+	  Components[comp].ImproperTorsionArguments=(REAL(*)[MAX_IMPROPER_TORSION_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfImproperTorsions,
+	 								 sizeof(REAL[MAX_IMPROPER_TORSION_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate out-of-plane distances
+	  Components[comp].OutOfPlanes=(QUAD*)calloc(Components[comp].NumberOfOutOfPlanes,sizeof(QUAD));
+	  Components[comp].OutOfPlaneType=(int*)calloc(Components[comp].NumberOfOutOfPlanes,sizeof(int));
+	  Components[comp].OutOfPlaneArguments=(REAL(*)[MAX_OUT_OF_PLANE_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfOutOfPlanes,
+	 								 sizeof(REAL[MAX_OUT_OF_PLANE_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate bond-bonds
+	  Components[comp].BondBonds=(TRIPLE*)calloc(Components[comp].NumberOfBondBonds,sizeof(TRIPLE));
+	  Components[comp].BondBondType=(int*)calloc(Components[comp].NumberOfBondBonds,sizeof(int));
+	  Components[comp].BondBondArguments=(REAL(*)[MAX_BOND_BOND_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBondBonds,
+	 								 sizeof(REAL[MAX_BOND_BOND_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate bond-bends
+	  Components[comp].BondBends=(TRIPLE*)calloc(Components[comp].NumberOfBondBends,sizeof(TRIPLE));
+	  Components[comp].BondBendType=(int*)calloc(Components[comp].NumberOfBondBends,sizeof(int));
+	  Components[comp].BondBendArguments=(REAL(*)[MAX_BOND_BEND_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBondBends,
+	 								 sizeof(REAL[MAX_BOND_BEND_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate bend-bends
+	  Components[comp].BendBends=(QUAD*)calloc(Components[comp].NumberOfBendBends,sizeof(QUAD));
+	  Components[comp].BendBendType=(int*)calloc(Components[comp].NumberOfBendBends,sizeof(int));
+	  Components[comp].BendBendArguments=(REAL(*)[MAX_BEND_BEND_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBendBends,
+	 								 sizeof(REAL[MAX_BEND_BEND_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate stretch-torsions
+	  Components[comp].BondTorsions=(QUAD*)calloc(Components[comp].NumberOfBondTorsions,sizeof(QUAD));
+	  Components[comp].BondTorsionType=(int*)calloc(Components[comp].NumberOfBondTorsions,sizeof(int));
+	  Components[comp].BondTorsionArguments=(REAL(*)[MAX_BOND_TORSION_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBondTorsions,
+	 								 sizeof(REAL[MAX_BOND_TORSION_POTENTIAL_ARGUMENTS]));
+	  
+	  // allocate bend-torsions
+	  Components[comp].BendTorsions=(QUAD*)calloc(Components[comp].NumberOfBendTorsions,sizeof(QUAD));
+	  Components[comp].BendTorsionType=(int*)calloc(Components[comp].NumberOfBendTorsions,sizeof(int));
+	  Components[comp].BendTorsionArguments=(REAL(*)[MAX_BEND_TORSION_POTENTIAL_ARGUMENTS])calloc(Components[comp].NumberOfBendTorsions,
+	 								 sizeof(REAL[MAX_BEND_TORSION_POTENTIAL_ARGUMENTS]));
+	  
+	  Components[comp].IntraVDW=(PAIR*)calloc(Components[comp].NumberOfIntraVDW,sizeof(PAIR));
+	  Components[comp].IntraChargeCharge=(PAIR*)calloc(Components[comp].NumberOfIntraChargeCharge,sizeof(PAIR));
+	  Components[comp].IntraChargeBondDipole=(PAIR*)calloc(Components[comp].NumberOfIntraChargeBondDipole,sizeof(PAIR));
+	  Components[comp].IntraBondDipoleBondDipole=(PAIR*)calloc(Components[comp].NumberOfIntraBondDipoleBondDipole,sizeof(PAIR));
+				 
+	  Components[comp].IntraVDWScaling=(REAL*)calloc(Components[comp].NumberOfIntraVDW,sizeof(REAL));
+	  Components[comp].IntraChargeChargeScaling=(REAL*)calloc(Components[comp].NumberOfIntraVDW,sizeof(REAL));
+	  
+	  // allocate excluded pairs
+	  Components[comp].ExcludedIntraChargeCharge=(PAIR*)calloc(SQR(Components[comp].NumberOfAtoms),sizeof(PAIR));
+	  Components[comp].ExcludedIntraChargeBondDipole=(PAIR*)calloc(SQR(Components[comp].NumberOfAtoms),sizeof(PAIR));
+	  Components[comp].ExcludedIntraBondDipoleBondDipole=(PAIR*)calloc(SQR(Components[comp].NumberOfAtoms),sizeof(PAIR));
+	  
+	  // Attribute Bond-data
+	  if(Components[comp].NumberOfBonds>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfBonds;j++)
+		{
+			// Attribute connectivity
+			A=Components[SolventIndex].Bonds[j].A;
+			B=Components[SolventIndex].Bonds[j].B;
+		    Components[comp].Bonds[j].A=A;
+		    Components[comp].Bonds[j].B=B;
+		    Components[comp].Connectivity[A]++;
+		    Components[comp].Connectivity[B]++;
+		    Components[comp].ConnectivityMatrix[A][B]=TRUE;
+		    Components[comp].ConnectivityMatrix[B][A]=TRUE;
+
+			// Attribute bondtype	
+			Components[comp].BondType[j]=Components[SolventIndex].BondType[j];
+	
+			for(k=0;k<BondTypes[Components[comp].BondType[j]].nr_args;k++)
+			{
+				Components[comp].BondArguments[j][k]=Components[SolventIndex].BondArguments[j][k];
+			}
+			
+			switch(Components[comp].BondType[j])
+			{
+			case HARMONIC_BOND:
+			  // 0.5*p0*SQR(r-p1);
+			  // ===============================================
+			  // p_0/k_B [K/A^2]   force constant
+			  // p_1     [A]       reference bond distance
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  break;
+			case CORE_SHELL_SPRING:
+			  // 0.5*p0*SQR(r);
+			  // ===============================================
+			  // p_0/k_B [K/A^2]   force constant
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  break;
+			case MORSE_BOND:
+			  // p_0*[(1.0-{exp(-p_1*(r-p_2))})^2-1.0]
+			  // ===============================================
+			  // p_0/k_B [K]       force constant
+			  // p_1     [A^-1]    parameter
+			  // p_2     [A]       reference bond distance
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  break;
+			case LJ_12_6_BOND:
+			  // A/r_ij^12-B/r_ij^6
+			  // ===============================================
+			  // p_0/k_B [K A^12]
+			  // p_1/k_B [K A^6]
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  Components[comp].BondArguments[j][1]=Components[SolventIndex].BondArguments[j][1];
+			  break;
+			case LENNARD_JONES_BOND:
+			  // 4*p_0*((p_1/r)^12-(p_1/r)^6)
+			  // ===============================================
+			  // p_0/k_B [K]
+			  // p_1     [A]
+			  Components[comp].BondArguments[j][0]= Components[SolventIndex].BondArguments[j][0];
+			  break;
+			case BUCKINGHAM_BOND:
+			  // p_0*exp(-p_1 r)-p_2/r^6
+			  // ===============================================
+			  // p_0/k_B [K]
+			  // p_1     [A^-1]
+			  // p_2/k_B [K A^6]
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  Components[comp].BondArguments[j][2]=Components[SolventIndex].BondArguments[j][2];
+			  break;
+			case RESTRAINED_HARMONIC_BOND:
+			  // 0.5*p_0*(r-p_1)^2                   |r-p_1|<=p_2
+			  // 0.5*p_0*p_2^2+p_0*p_2*(|r-p_1|-p_2) |r-p_1|>p_2
+			  // ===============================================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2     [A]
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  break;
+			case QUARTIC_BOND:
+			  // (1/2)*p_0*(r-p_1)^2+(1/3)*p_2*(r-p_1)^3+(1/4)*p_3*(r-p_1)^4
+			  // ===========================================================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2/k_B [K/A^3]
+			  // p_3/k_B [K/A^4]
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  Components[comp].BondArguments[j][2]=Components[SolventIndex].BondArguments[j][2];
+			  Components[comp].BondArguments[j][3]=Components[SolventIndex].BondArguments[j][3];
+			  break;
+			case CFF_QUARTIC_BOND:
+			  // p_0*(r-p_1)^2+p_2*(r-p_1)^3+p_3*(r-p_1)^4
+			  // ===============================================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2/k_B [K/A^3]
+			  // p_3/k_B [K/A^4]
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  Components[comp].BondArguments[j][2]=Components[SolventIndex].BondArguments[j][2];
+			  Components[comp].BondArguments[j][3]=Components[SolventIndex].BondArguments[j][3];
+			  break;
+			case MM3_BOND:
+			  // p_0*(r-p_1)^2*(1.0-2.55*(r-p_1)+(7.0/12.0)*2.55^2*(r-p_1)^2)
+			  // ============================================================
+			  // p_0     [mdyne/A molecule]
+			  // p_1     [A]
+			  Components[comp].BondArguments[j][0]=Components[SolventIndex].BondArguments[j][0];
+			  break;
+			case RIGID_BOND:
+			  A=Components[SolventIndex].Bonds[j].A;
+			  B=Components[SolventIndex].Bonds[j].B;
+			  dr.x=Components[SolventIndex].Positions[A].x-Components[SolventIndex].Positions[B].x;
+			  dr.y=Components[SolventIndex].Positions[A].y-Components[SolventIndex].Positions[B].y;
+			  dr.z=Components[SolventIndex].Positions[A].z-Components[SolventIndex].Positions[B].z;
+			  Components[comp].BondArguments[j][0]=sqrt(SQR(dr.x)+SQR(dr.y)+SQR(dr.z));
+			  break;
+			case FIXED_BOND:
+			  Components[comp].NumberOfConstraintBonds++;
+			  break;
+			default:
+			  fprintf(stderr, "Undefined Bond potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+			  exit(0);
+			  break;
+		   }
+		}
+	  }
+	  
+	  Components[comp].ConnectivityList=(int**)calloc(Components[comp].NumberOfAtoms,sizeof(int*));
+	  for(A=0;A<Components[comp].NumberOfAtoms;A++)
+	  {
+		Components[comp].ConnectivityList[A]=(int*)calloc(Components[comp].Connectivity[A],sizeof(int));
+
+		nr=0;
+		for(B=0;B<Components[comp].NumberOfAtoms;B++)
+		 if(Components[comp].ConnectivityMatrix[A][B])
+			Components[comp].ConnectivityList[A][nr++]=B;
+	  }
+
+	  // Attribute bond-dipole date.
+	  if(Components[comp].NumberOfBondDipoles>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfBondDipoles;j++)
+		{
+		  Components[comp].BondDipoles[j].A = Components[SolventIndex].BondDipoles[j].A;
+		  Components[comp].BondDipoles[j].B = Components[SolventIndex].BondDipoles[j].B;
+		  Components[comp].BondDipoleMagnitude[j]=Components[SolventIndex].BondDipoleMagnitude[j];
+		}
+	  }
+	  
+	  
+	  // Bend-data
+	  if(Components[comp].NumberOfBends>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfBends;j++)
+		{
+		 
+			Components[comp].Bends[j].A=Components[SolventIndex].Bends[j].A;
+			Components[comp].Bends[j].B=Components[SolventIndex].Bends[j].B;
+			Components[comp].Bends[j].C=Components[SolventIndex].Bends[j].C;
+			
+			// Attribute bend-type	
+			Components[comp].BendType[j]=Components[SolventIndex].BendType[j];
+
+			for(k=0;j<BendTypes[Components[comp].BendType[j]].nr_args;j++)
+			{
+				Components[comp].BendArguments[j][k]=Components[SolventIndex].BendArguments[j][k];
+			}
+
+			switch(Components[comp].BendType[j])
+			{
+				case HARMONIC_BEND:
+				  // (1/2)p_0*(theta-p_1)^2
+				  // ===============================================
+				  // p_0/k_B [K/rad^2]
+				  // p_1     [degrees]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][1]=Components[SolventIndex].BendArguments[j][1];
+				  break;
+				case CORE_SHELL_BEND:
+				  // (1/2)p_0*(theta-p_1)^2
+				  // ===============================================
+				  // p_0/k_B [K/rad^2]
+				  // p_1     [degrees]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][1]=Components[SolventIndex].BendArguments[j][1];
+				  break;
+				case QUARTIC_BEND:
+				  // (1/2)p_0*(theta-p_1)^2+(1/3)*p_2*(theta-p_1)^3+(1/4)*p_2*(theta-p_1)^4
+				  // ======================================================================
+				  // p_0/k_B [K/rad^2]
+				  // p_1     [degrees]
+				  // p_2/k_B [K/rad^3]
+				  // p_3/k_B [K/rad^4]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][1]=Components[SolventIndex].BendArguments[j][1];
+				  Components[comp].BendArguments[j][2]=Components[SolventIndex].BendArguments[j][2];
+				  Components[comp].BendArguments[j][3]=Components[SolventIndex].BendArguments[j][3];
+				  break;
+				case CFF_QUARTIC_BEND:
+				  // p_0*(theta-p_1)^2+p_2*(theta-p_1)^3+p_3*(theta-p_1)^4
+				  // =====================================================
+				  // p_0/k_B [K/rad^2]
+				  // p_1     [degrees]
+				  // p_2/k_B [K/rad^3]
+				  // p_3/k_B [K/rad^4]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][1]=Components[SolventIndex].BendArguments[j][1];
+				  Components[comp].BendArguments[j][2]=Components[SolventIndex].BendArguments[j][2];
+				  Components[comp].BendArguments[j][3]=Components[SolventIndex].BendArguments[j][3];
+				  break;
+				case HARMONIC_COSINE_BEND:
+				  // (1/2)*p_0*(cos(theta)-cos(p_1))^2
+				  // ===============================================
+				  // p_0/k_B [K]
+				  // p_1     [degrees]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][1]=Components[SolventIndex].BendArguments[j][1];
+				  break;
+				case COSINE_BEND:
+				  // p_0*(1+cos(p_1*theta-p_2))
+				  // ===============================================
+				  // p_0/k_B [K]
+				  // p_1     [-]
+				  // p_2     [degrees]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][2]=Components[SolventIndex].BendArguments[j][2];
+				  break;
+				case TAFIPOLSKY_BEND:
+				  // 0.5*p_0*(1+cos(theta))*(1+cos(2*theta))
+				  // ===============================================
+				  // p_0/k_B [K]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  break;
+				case MM3_BEND:
+				case MM3_IN_PLANE_BEND:
+				  // p_0*(theta-p_1)^2(1-0.014*(theta-p_1)+5.6e-5*(theta-p_1)^2-7e-7*(theta-p_1)^3+2.2e-8(theta-p_1)^4)
+				  // =================================================================================================
+				  // p_0/k_B [mdyne A/rad^2]
+				  // p_1     [degrees]
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].BendArguments[j][1]=Components[SolventIndex].BendArguments[j][1];
+				  break;
+				case FIXED_BEND:
+				  Components[comp].BendArguments[j][0]=Components[SolventIndex].BendArguments[j][0];
+				  Components[comp].NumberOfConstraintBends++;
+				  break;
+				default:
+				  fprintf(stderr, "Undefined Bend potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+				  exit(0);
+				  break;
+			 }
+		}
+	  }
+	  
+	  // UreyBradley-data
+	  if(Components[comp].NumberOfUreyBradleys>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfUreyBradleys;j++)
+		{
+		  Components[comp].UreyBradleys[j].A=Components[SolventIndex].UreyBradleys[j].A;
+		  Components[comp].UreyBradleys[j].B=Components[SolventIndex].UreyBradleys[j].B;
+		  Components[comp].UreyBradleys[j].C=Components[SolventIndex].UreyBradleys[j].C;
+
+		  // Attribute Urey-Bradley.
+	      Components[comp].UreyBradleyType[j]=Components[SolventIndex].UreyBradleyType[j];
+
+		  for(k=0;k<UreyBradleyTypes[Components[comp].UreyBradleyType[j]].nr_args;k++)
+		  {
+			Components[comp].UreyBradleyArguments[j][k]=Components[SolventIndex].UreyBradleyArguments[j][k];
+		  }
+
+		  switch(Components[comp].UreyBradleyType[j])
+		  {
+			case HARMONIC_UREYBRADLEY:
+			  // 0.5*p0*SQR(r-p1);
+			  // ===============================================
+			  // p_0/k_B [K/A^2]   force constant
+			  // p_1     [A]       reference bond distance
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  break;
+			case MORSE_UREYBRADLEY:
+			  // p_0*[(1.0-{exp(-p_1*(r-p_2))})^2-1.0]
+			  // ===============================================
+			  // p_0/k_B [K]       force constant
+			  // p_1     [A^-1]    parameter
+			  // p_2     [A]       reference bond distance
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  break;
+			case LJ_12_6_UREYBRADLEY:
+			  // A/r_ij^12-B/r_ij^6
+			  // ===============================================
+			  // p_0/k_B [K A^12]
+			  // p_1/k_B [K A^6]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  Components[comp].UreyBradleyArguments[j][1]=Components[SolventIndex].UreyBradleyArguments[j][1];
+			  break;
+			case LENNARD_JONES_UREYBRADLEY:
+			  // 4*p_0*((p_1/r)^12-(p_1/r)^6)
+			  // ===============================================
+			  // p_0/k_B [K]
+			  // p_1     [A]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  break;
+			case BUCKINGHAM_UREYBRADLEY:
+			  // p_0*exp(-p_1 r)-p_2/r^6
+			  // ===============================================
+			  // p_0/k_B [K]
+			  // p_1     [A^-1]
+			  // p_2/k_B [K A^6]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  Components[comp].UreyBradleyArguments[j][2]=Components[SolventIndex].UreyBradleyArguments[j][2];
+			  break;
+			case RESTRAINED_HARMONIC_UREYBRADLEY:
+			  // 0.5*p_0*(r-p_1)^2                   |r-p_1|<=p_2
+			  // 0.5*p_0*p_2^2+p_0*p_2*(|r-p_1|-p_2) |r-p_1|>p_2
+			  // ===============================================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2     [A]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  break;
+			case QUARTIC_UREYBRADLEY:
+			  // (1/2)*p_0*(r-p_1)^2+(1/3)*p_2*(r-p_1)^3+(1/4)*p_3*(r-p_1)^4
+			  // ===========================================================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2/k_B [K/A^3]
+			  // p_3/k_B [K/A^4]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  Components[comp].UreyBradleyArguments[j][2]=Components[SolventIndex].UreyBradleyArguments[j][2];
+			  Components[comp].UreyBradleyArguments[j][3]=Components[SolventIndex].UreyBradleyArguments[j][3];
+			  break;
+			case CFF_QUARTIC_UREYBRADLEY:
+			  // p_0*(r-p_1)^2+p_2*(r-p_1)^3+p_3*(r-p_1)^4
+			  // ===============================================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2/k_B [K/A^3]
+			  // p_3/k_B [K/A^4]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  Components[comp].UreyBradleyArguments[j][2]=Components[SolventIndex].UreyBradleyArguments[j][2];
+			  Components[comp].UreyBradleyArguments[j][3]=Components[SolventIndex].UreyBradleyArguments[j][3];
+			  break;
+			case MM3_UREYBRADLEY:
+			  // p_0*(r-p_1)^2*(1.0-2.55*(r-p_1)+(7.0/12.0)*2.55^2*(r-p_1)^2)
+			  // ============================================================
+			  // p_0     [mdyne/A molecule]
+			  // p_1     [A]
+			  Components[comp].UreyBradleyArguments[j][0]=Components[SolventIndex].UreyBradleyArguments[j][0];
+			  break;
+			case RIGID_UREYBRADLEY:
+			  A=Components[SolventIndex].UreyBradleys[j].A;
+			  B=Components[SolventIndex].UreyBradleys[j].B;
+			  dr.x=Components[SolventIndex].Positions[A].x-Components[SolventIndex].Positions[B].x;
+			  dr.y=Components[SolventIndex].Positions[A].y-Components[SolventIndex].Positions[B].y;
+			  dr.z=Components[SolventIndex].Positions[A].z-Components[SolventIndex].Positions[B].z;
+			  Components[comp].BondArguments[j][0]=sqrt(SQR(dr.x)+SQR(dr.y)+SQR(dr.z));
+			  break;
+			case FIXED_UREYBRADLEY:
+			  break;
+			default:
+			  fprintf(stderr, "Undefined Urey-Bradley potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+			  exit(0);
+			  break;
+		  }
+		 }
+	  }
+	  
+	    // inversion Bend-data
+	  if(Components[comp].NumberOfInversionBends>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfInversionBends;j++)
+		{
+			Components[comp].InversionBends[j].A=Components[SolventIndex].InversionBends[j].A;
+			Components[comp].InversionBends[j].B=Components[SolventIndex].InversionBends[j].B;
+			Components[comp].InversionBends[j].C=Components[SolventIndex].InversionBends[j].C;
+			Components[comp].InversionBends[j].D=Components[SolventIndex].InversionBends[j].D;
+			
+			// Attribute Inversion Bend
+			Components[comp].InversionBendType[j]=Components[SolventIndex].InversionBendType[j];
+			
+
+		    for(k=0;k<InversionBendTypes[Components[comp].InversionBendType[j]].nr_args;k++)
+			{
+				Components[comp].InversionBendArguments[j][k]=Components[SolventIndex].InversionBendArguments[j][k];
+			}
+
+		    switch(Components[comp].InversionBendType[j])
+		    {
+				case HARMONIC_INVERSION:
+				case HARMONIC_INVERSION2:
+				  // (1/2)*p_0*(chi-p_1)^2
+				  // ===============================================
+				  // p_0/k_B [K/rad^2]
+				  // p_1     [degrees]
+				  Components[comp].InversionBendArguments[j][0]=Components[SolventIndex].InversionBendArguments[j][0];
+				  Components[comp].InversionBendArguments[j][1]=Components[SolventIndex].InversionBendArguments[j][1];
+				  break;
+				case HARMONIC_COSINE_INVERSION:
+				case HARMONIC_COSINE_INVERSION2:
+				  // (1/2)*p_0*(cos(phi)-cos(p_1))^2
+				  // ===============================================
+				  // p_0/k_B [K]
+				  // p_1     [degrees]
+				  Components[comp].InversionBendArguments[j][0]=Components[SolventIndex].InversionBendArguments[j][0];
+				  Components[comp].InversionBendArguments[j][1]=Components[SolventIndex].InversionBendArguments[j][1];
+				  break;
+				case PLANAR_INVERSION:
+				case PLANAR_INVERSION2:
+				  // (1/2)*p_0*(1-cos(phi))
+				  // ===============================================
+				  // p_0/k_B [K]
+				  Components[comp].InversionBendArguments[j][0]=Components[SolventIndex].InversionBendArguments[j][0];
+				  break;
+				case MM3_INVERSION:
+				  // p_0*(theta-p_1)^2(1-0.014*(theta-p_1)+5.6e-5*(theta-p_1)^2-7e-7*(theta-p_1)^3+2.2e-8(theta-p_1)^4)
+				  // =================================================================================================
+				  // p_0/k_B [mdyne A/rad^2]
+				  // p_1     [degrees]
+				  Components[comp].InversionBendArguments[j][0]=Components[SolventIndex].InversionBendArguments[j][0];
+				  break;
+				case FIXED_INVERSION_BEND:
+				  Components[comp].InversionBendArguments[j][0]=Components[SolventIndex].InversionBendArguments[j][0];
+				  Components[comp].NumberOfConstraintInversionBends++;
+				  break;
+				default:
+				  fprintf(stderr, "Undefined Inversion potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+				  exit(0);
+				  break;
+		   }
+		}
+	  }
+	  
+	  // Torsion-data
+	  if(Components[comp].NumberOfTorsions>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfTorsions;j++)
+		{
+			Components[comp].Torsions[j].A=Components[SolventIndex].Torsions[j].A;
+			Components[comp].Torsions[j].B=Components[SolventIndex].Torsions[j].B;
+			Components[comp].Torsions[j].C=Components[SolventIndex].Torsions[j].C;
+			Components[comp].Torsions[j].D=Components[SolventIndex].Torsions[j].D;
+      
+			// Attribute Torsion data
+			Components[comp].TorsionType[j]=Components[SolventIndex].TorsionType[j];
+
+			for(k=0;k<TorsionTypes[Components[comp].TorsionType[j]].nr_args;k++)
+			{
+				Components[comp].TorsionArguments[j][k]=Components[SolventIndex].TorsionArguments[j][k];
+			}
+
+			switch(Components[comp].TorsionType[j])
+			{
+				case HARMONIC_DIHEDRAL:
+				  // (1/2)*p_0*(phi-p_1)^2
+				  // ===============================================
+				  // p_0/k_B [K/rad^2]
+				  // p_1     [degrees]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  break;
+				case HARMONIC_COSINE_DIHEDRAL:
+				  // (1/2)*p_0*(cos(phi)-cos(p_1))^2
+				  // ===============================================
+				  // p_0/k_B [K]
+				  // p_1     [degrees]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  break;
+				case THREE_COSINE_DIHEDRAL:
+				  // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))
+				  // ========================================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  break;
+				case MM3_DIHEDRAL:
+				  // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))
+				  // ========================================================================
+				  // p_0     [kcal/mol]
+				  // p_1     [kcal/mol]
+				  // p_2     [kcal/mol]
+				  Components[comp].TorsionArguments[j][0]*=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]*=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]*=Components[SolventIndex].TorsionArguments[j][2];
+				case CVFF_BLOCKED_DIHEDRAL:
+				  // 
+				  // ========================================================================
+				  // p_0     [rad]
+				  // p_1     [K]
+				  // p_2     [-]
+				  // p_3     [rad]
+				  // p_4     [rad]
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  break;
+				case CFF_DIHEDRAL:
+				  // p_0*(1-cos(phi))+p_1*(1-cos(2*phi))+p_2*(1-cos(3*phi))
+				  // ======================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  break;
+				case CFF_DIHEDRAL2:
+				  // p_0*(1+cos(phi))+p_1*(1+cos(2*phi))+p_2*(1+cos(3*phi))
+				  // ======================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  break;
+				case SIX_COSINE_DIHEDRAL:
+				  // Prod_i=0^5 p_i*cos(phi)^i
+				  // =========================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  // p_3/k_B [K]
+				  // p_4/k_B [K]
+				  // p_5/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  Components[comp].TorsionArguments[j][4]=Components[SolventIndex].TorsionArguments[j][4];
+				  Components[comp].TorsionArguments[j][5]=Components[SolventIndex].TorsionArguments[j][5];
+				  break;
+				case TRAPPE_DIHEDRAL:
+				  // p_0[0]+p_1*(1+cos(phi))+p_2*(1-cos(2*phi))+p_3*(1+cos(3*phi))
+				  // =============================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  // p_3/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  break;
+				case TRAPPE_DIHEDRAL_EXTENDED:
+				  // p_0[0]+p_1*cos(phi)+p_2*cos(2*phi)+p_3*cos(3*phi)+p_4*cos(4*phi)
+				  // ================================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  // p_3/k_B [K]
+				  // p_4/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  Components[comp].TorsionArguments[j][4]=Components[SolventIndex].TorsionArguments[j][4];
+				  break;
+				case MOD_TRAPPE_DIHEDRAL:
+				  /* Salvador modification: 16/08/2016
+				   add phase in cos function:
+				   p_0+p_1*(1+cos(phi-p_4))+p_2*(1-cos(2*(phi-p_4)))+p_3*(1+cos(3*(phi-p_4)))
+				  */
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  Components[comp].TorsionArguments[j][4]=Components[SolventIndex].TorsionArguments[j][4];
+				  break;
+				case CVFF_DIHEDRAL:
+				  // p_0*(1+cos(p_1*phi-p_2))
+				  // ========================
+				  // p_0/k_B [K]
+				  // p_1     [-]
+				  // p_2     [degrees]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  break;
+				case OPLS_DIHEDRAL:
+				  // (1/2)p_0[0]+(1/2)p_1*(1+cos(phi))+(1/2)p_2*(1-cos(2*phi))+(1/2)p_3*(1+cos(3*phi))
+				  // =================================================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  // p_3/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  break;
+				case FOURIER_SERIES_DIHEDRAL:
+				  // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+
+				  // (1/2)p_3*(1-cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))
+				  // =======================================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  // p_3/k_B [K]
+				  // p_4/k_B [K]
+				  // p_5/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  Components[comp].TorsionArguments[j][4]=Components[SolventIndex].TorsionArguments[j][4];
+				  Components[comp].TorsionArguments[j][5]=Components[SolventIndex].TorsionArguments[j][5];
+				  break;
+				case FOURIER_SERIES_DIHEDRAL2:
+				  // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+
+				  // (1/2)p_3*(1+cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))
+				  // =======================================================================
+				  // p_0/k_B [K]
+				  // p_1/k_B [K]
+				  // p_2/k_B [K]
+				  // p_3/k_B [K]
+				  // p_4/k_B [K]
+				  // p_5/k_B [K]
+				  Components[comp].TorsionArguments[j][0]=Components[SolventIndex].TorsionArguments[j][0];
+				  Components[comp].TorsionArguments[j][1]=Components[SolventIndex].TorsionArguments[j][1];
+				  Components[comp].TorsionArguments[j][2]=Components[SolventIndex].TorsionArguments[j][2];
+				  Components[comp].TorsionArguments[j][3]=Components[SolventIndex].TorsionArguments[j][3];
+				  Components[comp].TorsionArguments[j][4]=Components[SolventIndex].TorsionArguments[j][4];
+				  Components[comp].TorsionArguments[j][5]=Components[SolventIndex].TorsionArguments[j][5];
+				  break;
+				case FIXED_DIHEDRAL:
+				  Components[comp].TorsionArguments[i][0]=Components[SolventIndex].TorsionArguments[i][0];
+				  Components[comp].NumberOfConstraintTorsions++;
+				  break;
+				default:
+				  fprintf(stderr, "Undefined Torsion potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+				  exit(0);
+				  break;
+			}
+		}
+	  }
+
+	  //  Improper Torsion-data
+	  if(Components[comp].NumberOfImproperTorsions>0)
+	  {
+		for(j=0;j<Components[comp].NumberOfImproperTorsions;j++)
+		{
+            Components[comp].ImproperTorsions[j].A=Components[SolventIndex].ImproperTorsions[j].A;
+            Components[comp].ImproperTorsions[j].B=Components[SolventIndex].ImproperTorsions[j].B;
+            Components[comp].ImproperTorsions[j].C=Components[SolventIndex].ImproperTorsions[j].C;
+            Components[comp].ImproperTorsions[j].D=Components[SolventIndex].ImproperTorsions[j].D;
+             
+            // Attribute Torsion data
+			Components[comp].ImproperTorsionType[j]=Components[SolventIndex].ImproperTorsionType[j];
+			 
+			for(k=0;k<ImproperTorsionTypes[Components[comp].ImproperTorsionType[j]].nr_args;k++)
+			{
+				Components[comp].ImproperTorsionArguments[j][k]=Components[SolventIndex].ImproperTorsionArguments[j][k];
+			}
+
+			switch(Components[comp].ImproperTorsionType[j])
+			{
+			case HARMONIC_IMPROPER_DIHEDRAL:
+			  // (1/2)*p_0*(phi-p_1)^2
+			  // ===============================================
+			  // p_0/k_B [K/rad^2]
+			  // p_1     [degrees]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  break;
+			case HARMONIC_COSINE_IMPROPER_DIHEDRAL:
+			  // (1/2)*p_0*(cos(phi)-cos(p_1))^2
+			  // ===============================================
+			  // p_0/k_B [K]
+			  // p_1     [degrees]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  break;
+			case THREE_COSINE_IMPROPER_DIHEDRAL:
+			  // (1/2)*p_0*(1+cos(phi))+(1/2)*p_1*(1-cos(2*phi))+(1/2)*p_2*(1+cos(3*phi))
+			  // ========================================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  break;
+			case MM3_IMPROPER_DIHEDRAL:
+			  // p_0*(1+cos(phi))+p_1*(1+cos(2*phi))+p_2*(1+cos(3*phi))
+			  // ======================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			case CFF_IMPROPER_DIHEDRAL:
+			  // p_0*(1-cos(phi))+p_1*(1-cos(2*phi))+p_2*(1-cos(3*phi))
+			  // ======================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  break;
+			case CFF_IMPROPER_DIHEDRAL2:
+			  // p_0*(1+cos(phi))+p_1*(1+cos(2*phi))+p_2*(1+cos(3*phi))
+			  // ======================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  break;
+			case SIX_COSINE_IMPROPER_DIHEDRAL:
+			  // Prod_i=0^5 p_i*cos(phi)^i
+			  // =========================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  // p_3/k_B [K]
+			  // p_4/k_B [K]
+			  // p_5/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  Components[comp].ImproperTorsionArguments[j][3]=Components[SolventIndex].ImproperTorsionArguments[j][3];
+			  Components[comp].ImproperTorsionArguments[j][4]=Components[SolventIndex].ImproperTorsionArguments[j][4];
+			  Components[comp].ImproperTorsionArguments[j][5]=Components[SolventIndex].ImproperTorsionArguments[j][5];
+			  break;
+			case TRAPPE_IMPROPER_DIHEDRAL:
+			  // p_0[0]+p_1*(1+cos(phi))+p_2*(1-cos(2*phi))+p_3*(1+cos(3*phi))
+			  // =============================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  // p_3/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  Components[comp].ImproperTorsionArguments[j][3]=Components[SolventIndex].ImproperTorsionArguments[j][3];
+			  break;
+			case TRAPPE_IMPROPER_DIHEDRAL_EXTENDED:
+			  // p_0[0]+p_1*cos(phi)+p_2*cos(2*phi)+p_3*cos(3*phi)+p_4*cos(4*phi)
+			  // ================================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  // p_3/k_B [K]
+			  // p_4/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  Components[comp].ImproperTorsionArguments[j][3]=Components[SolventIndex].ImproperTorsionArguments[j][3];
+			  Components[comp].ImproperTorsionArguments[j][4]=Components[SolventIndex].ImproperTorsionArguments[j][4];
+			  break;
+			case CVFF_IMPROPER_DIHEDRAL:
+			  // p_0*(1+cos(p_1*phi-p_2))
+			  // ========================
+			  // p_0/k_B [K]
+			  // p_1     [-]
+			  // p_2     [degrees]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  break;
+			case OPLS_IMPROPER_DIHEDRAL:
+			  // (1/2)p_0[0]+(1/2)p_1*(1+cos(phi))+(1/2)p_2*(1-cos(2*phi))+(1/2)p_3*(1+cos(3*phi))
+			  // =================================================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  // p_3/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  Components[comp].ImproperTorsionArguments[j][3]=Components[SolventIndex].ImproperTorsionArguments[j][3];
+			  break;
+			case FOURIER_SERIES_IMPROPER_DIHEDRAL:
+			  // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+
+			  // (1/2)p_3*(1-cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))
+			  // =======================================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  // p_3/k_B [K]
+			  // p_4/k_B [K]
+			  // p_5/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  Components[comp].ImproperTorsionArguments[j][3]=Components[SolventIndex].ImproperTorsionArguments[j][3];
+			  Components[comp].ImproperTorsionArguments[j][4]=Components[SolventIndex].ImproperTorsionArguments[j][4];
+			  Components[comp].ImproperTorsionArguments[j][5]=Components[SolventIndex].ImproperTorsionArguments[j][5];
+			  break;
+			case FOURIER_SERIES_IMPROPER_DIHEDRAL2:
+			  // (1/2)p_0*(1+cos(phi))+(1/2)p_1(1-cos(2*phi))+(1/2)*p2_2*(1+cos(3*phi))+
+			  // (1/2)p_3*(1+cos(4*phi))+(1/2)p_4*(1+cos(5*phi))+(1/2)p_5*(1+cos(6*phi))
+			  // =======================================================================
+			  // p_0/k_B [K]
+			  // p_1/k_B [K]
+			  // p_2/k_B [K]
+			  // p_3/k_B [K]
+			  // p_4/k_B [K]
+			  // p_5/k_B [K]
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].ImproperTorsionArguments[j][1]=Components[SolventIndex].ImproperTorsionArguments[j][1];
+			  Components[comp].ImproperTorsionArguments[j][2]=Components[SolventIndex].ImproperTorsionArguments[j][2];
+			  Components[comp].ImproperTorsionArguments[j][3]=Components[SolventIndex].ImproperTorsionArguments[j][3];
+			  Components[comp].ImproperTorsionArguments[j][4]=Components[SolventIndex].ImproperTorsionArguments[j][4];
+			  Components[comp].ImproperTorsionArguments[j][5]=Components[SolventIndex].ImproperTorsionArguments[j][5];
+			  break;
+			case FIXED_IMPROPER_DIHEDRAL:
+			  Components[comp].ImproperTorsionArguments[j][0]=Components[SolventIndex].ImproperTorsionArguments[j][0];
+			  Components[comp].NumberOfConstraintImproperTorsions++;
+			  break;
+			default:
+			  fprintf(stderr, "Undefined Improper Torsion potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+			  exit(0);
+			  break;
+      }
+    }
+  }
+
+  // Bond/Strech cross term-data
+  if(Components[comp].NumberOfBondBonds>0)
+  {
+
+    for(j=0;j<Components[comp].NumberOfBondBonds;j++)
+    {
+         Components[comp].BondBonds[j].A=Components[SolventIndex].BondBonds[j].A;
+         Components[comp].BondBonds[j].B=Components[SolventIndex].BondBonds[j].B;
+         Components[comp].BondBonds[j].C=Components[SolventIndex].BondBonds[j].C;
+		
+		 // Attribute Bond/stretch cross term
+		 Components[comp].BondBondType[j]=Components[SolventIndex].BondBondType[j];
+
+		 for(k=0;k<BondBondTypes[Components[comp].BondBondType[j]].nr_args;k++)
+		 {
+			Components[comp].BondBondArguments[j][k]=Components[SolventIndex].BondBondArguments[j][k];
+		 }
+
+		 switch(Components[comp].BondBondType[j])
+		 {
+			case CVFF_BOND_BOND_CROSS:
+			case CFF_BOND_BOND_CROSS:
+			  // p_0*(rab-p_1)*(rbc-p_2)
+			  // =======================
+			  // p_0/k_B [K/A^2]
+			  // p_1     [A]
+			  // p_2     [A]
+			  Components[comp].BondBondArguments[j][0]=Components[SolventIndex].BondBondArguments[j][0];
+			  break;
+			default:
+			  fprintf(stderr, "Undefined Bond-Bond potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+			  exit(0);
+			  break;
+		}
+    }
+  }
+
+  // reading Bond/Bend cross term-data
+  if(Components[comp].NumberOfBondBends>0)
+  {
+    for(j=0;j<Components[comp].NumberOfBondBends;j++)
+    {
+
+         Components[comp].BondBends[j].A=Components[SolventIndex].BondBends[j].A;
+         Components[comp].BondBends[j].B=Components[SolventIndex].BondBends[j].B;
+         Components[comp].BondBends[j].C=Components[SolventIndex].BondBends[j].C;
+          
+         // Attribute Bond/Bend cross term
+         Components[comp].BondBendType[j]=Components[SolventIndex].BondBendType[j];
+          
+		 for(k=0;k<BondBendTypes[Components[comp].BondBendType[j]].nr_args;k++)
+		 {
+			Components[comp].BondBendArguments[j][k]=Components[SolventIndex].BondBendArguments[j][k];
+		 }
+
+		 switch(Components[comp].BondBendType[j])
+		 {
+			case CVFF_BOND_BEND_CROSS:
+			case CFF_BOND_BEND_CROSS:
+			  // (Theta-p_0)*(p_1*(rab-p_2)+p_3*(rbc-p_4))
+			  // =========================================
+			  // p_0     [degrees]
+			  // p_1/k_B [K/A/rad]
+			  // p_2     [A]
+			  // p_3/k_B [K/A/rad]
+			  // p_4     [A]
+			  Components[comp].BondBendArguments[j][0]=Components[SolventIndex].BondBendArguments[j][0];
+			  Components[comp].BondBendArguments[j][1]=Components[SolventIndex].BondBendArguments[j][1];
+			  Components[comp].BondBendArguments[j][3]=Components[SolventIndex].BondBendArguments[j][3];
+			  break;
+			case MM3_BOND_BEND_CROSS:
+			  // p_0*[(rab-p_1)+(rbc-p_2)]*(Theta-p_3)
+			  // =====================================
+			  // p_0     [mdyne/rad]
+			  // p_1     [A]
+			  // p_2     [A]
+			  // p_3     [degrees]
+			  Components[comp].BondBendArguments[j][0]=Components[SolventIndex].BondBendArguments[j][0];
+			  Components[comp].BondBendArguments[j][3]=Components[SolventIndex].BondBendArguments[j][3];
+			  break;
+			case TRUNCATED_HARMONIC:
+			  // (1/2)*p_0*(Theta-p_1)^2*exp(-(pow(rab,8)+pow(rbc,8))/pow(p_2,8))
+			  // ================================================================
+			  // p_0/k_B [K/rad^2]
+			  // p_1     [degrees]
+			  // p_2     [A]
+			  Components[comp].BondBendArguments[j][0]=Components[SolventIndex].BondBendArguments[j][0];
+			  Components[comp].BondBendArguments[j][1]=Components[SolventIndex].BondBendArguments[j][1];
+			  break;
+			case SCREENED_HARMONIC:
+			  // (1/2)*p_0*(Theta-p_1)^2*exp(-(rab/p_2+rbc/p_3))
+			  // ===============================================
+			  // p_0/k_B [K/rad^2]
+			  // p_1     [degrees]
+			  // p_2     [A]
+			  // p_3     [A]
+			  Components[comp].BondBendArguments[j][0]=Components[SolventIndex].BondBendArguments[j][0];
+			  Components[comp].BondBendArguments[j][1]=Components[SolventIndex].BondBendArguments[j][1];
+			  break;
+			case SCREENED_VESSAL:
+			  // (p_0/(8.0*(Theta-PI)^2))*((p_1-PI)^2-(Theta-PI)^2)^2*exp(-(rab/p_2+rbc/p_3))
+			  // ============================================================================
+			  // p_0/k_B [K/rad^2]
+			  // p_1     [degrees]
+			  // p_2     [A]
+			  // p_3     [A]
+			  Components[comp].BondBendArguments[j][0]=Components[SolventIndex].BondBendArguments[j][0];
+			  Components[comp].BondBendArguments[j][1]=Components[SolventIndex].BondBendArguments[j][1];
+			  break;
+			case TRUNCATED_VESSAL:
+			  // p_0*[pow(theta,p_2)*(theta-p_1)^2*(theta+p_1-2.0*PI)^2-0.5*p_2*pow(PI,p_2-1.0)*(theta-p_1)^2*pow(PI-p_1,3)]
+			  //    *exp(-(pow(rab,8)+pow(rbc,8))/pow(p_3,8))
+			  // ============================================================================
+			  // p_0/k_B [K/rad^(4+p_2)]
+			  // p_1     [degrees]
+			  // p_2     [-]
+			  // p_3     [A]
+			  Components[comp].BondBendArguments[j][0]=Components[SolventIndex].BondBendArguments[j][0];
+			  Components[comp].BondBendArguments[j][1]=Components[SolventIndex].BondBendArguments[j][1];
+			  break;
+			default:
+			  fprintf(stderr, "Undefined Bond-Bend potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+			  exit(0);
+			  break;
+      }
+    }
+  }
+	  
+  // Bend/Bend cross term-data
+  if(Components[comp].NumberOfBendBends>0)
+  {
+    for(j=0;j<Components[comp].NumberOfBendBends;j++)
+    {
+		 Components[comp].BendBends[j].A=Components[SolventIndex].BendBends[j].A;
+		 Components[comp].BendBends[j].B=Components[SolventIndex].BendBends[j].B;
+		 Components[comp].BendBends[j].C=Components[SolventIndex].BendBends[j].C;
+		 Components[comp].BendBends[j].D=Components[SolventIndex].BendBends[j].D;
+
+		 // Attribute Bend/Bend cross term.
+		 Components[comp].BendBendType[j]=Components[SolventIndex].BendBendType[j];
+
+      for(k=0;k<BendBendTypes[Components[comp].BendBendType[j]].nr_args;k++)
+      {
+         Components[comp].BendBendArguments[j][k]=Components[SolventIndex].BendBendArguments[j][k];
+      }
+
+      switch(Components[comp].BendBendType[j])
+      {
+        case CVFF_BEND_BEND_CROSS:
+        case CFF_BEND_BEND_CROSS:
+         // p_0*(Theta1-p_1)*(Theta2-p_2)
+          // ===================================
+          // p_0/k_B [K/rad^2)]
+          // p_1     [degrees]
+          // p_2     [degrees]
+          Components[comp].BendBendArguments[j][0]=Components[SolventIndex].BendBendArguments[j][0];
+          Components[comp].BendBendArguments[j][1]=Components[SolventIndex].BendBendArguments[j][1];
+        case MM3_BEND_BEND_CROSS:
+          // -p_0*(Theta1-p_1)*(Theta2-p_2)
+          // ===================================
+          // p_0     [mdyne A/rad^2]
+          // p_1     [degrees]
+          // p_2     [degrees]
+          Components[comp].BendBendArguments[j][0]=Components[SolventIndex].BendBendArguments[j][0];
+          Components[comp].BendBendArguments[j][1]=Components[SolventIndex].BendBendArguments[j][1];
+          Components[comp].BendBendArguments[j][2]=Components[SolventIndex].BendBendArguments[j][2];
+          break;
+        default:
+          fprintf(stderr, "Undefined Bend-Bend potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+          exit(0);
+          break;
+      }
+    }
+  }
+  
+  // reading Bond/Torsion cross term-data
+  if(Components[comp].NumberOfBondTorsions>0)
+  {
+    for(j=0;j<Components[comp].NumberOfBondTorsions;j++)
+    {
+           Components[comp].BondTorsions[j].A=Components[SolventIndex].BondTorsions[j].A;
+           Components[comp].BondTorsions[j].B=Components[SolventIndex].BondTorsions[j].B;
+           Components[comp].BondTorsions[j].C=Components[SolventIndex].BondTorsions[j].C;
+           Components[comp].BondTorsions[j].D=Components[SolventIndex].BondTorsions[j].D;
+           
+           // Attribute Bond/Torsion cross term
+           Components[comp].BondTorsionType[j]=Components[SolventIndex].BondTorsionType[j];
+
+		   for(k=0;k<BondTorsionTypes[Components[comp].BondTorsionType[j]].nr_args;k++)
+		   {
+				Components[comp].BondTorsionArguments[j][k]=Components[SolventIndex].BondTorsionArguments[j][k];
+		   }
+
+      switch(Components[comp].BondTorsionType[j])
+      {
+        case MM3_BOND_TORSION_CROSS:
+          // (1/2)p_0(r-p_3)(1+cos(phi))+(1/2)p_1(r-p_3)(1+cos(2phi))+(1/2)p_2(r-p_3)(1+cos(3phi))
+          // =====================================================================================
+          // p_0     [kcal/A mole]
+          // p_1     [kcal/A mole]
+          // p_2     [kcal/A mole]
+          // p_3     [A]
+          Components[comp].BondTorsionArguments[j][0]=Components[SolventIndex].BondTorsionArguments[j][0];
+          Components[comp].BondTorsionArguments[j][1]=Components[SolventIndex].BondTorsionArguments[j][1];
+          Components[comp].BondTorsionArguments[j][2]=Components[SolventIndex].BondTorsionArguments[j][2];
+          break;
+        default:
+          fprintf(stderr, "Undefined Bond-Torsion potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+          exit(0);
+          break;
+      }
+    }
+  }
+
+  // Bend/Torsion cross term-data
+  if(Components[comp].NumberOfBendTorsions>0)
+  {
+    for(j=0;j<Components[comp].NumberOfBendTorsions;j++)
+    {
+           Components[comp].BendTorsions[j].A=Components[SolventIndex].BendTorsions[j].A;
+           Components[comp].BendTorsions[j].B=Components[SolventIndex].BendTorsions[j].B;
+           Components[comp].BendTorsions[j].C=Components[SolventIndex].BendTorsions[j].C;
+           Components[comp].BendTorsions[j].D=Components[SolventIndex].BendTorsions[j].D;
+           
+           // Attribute Bend/Torsion cross term
+           Components[comp].BendTorsionType[j]=Components[SolventIndex].BendTorsionType[j];
+
+      for(k=0;k<BendTorsionTypes[Components[comp].BendTorsionType[j]].nr_args;k++)
+      {
+        Components[comp].BendTorsionArguments[j][k]=Components[SolventIndex].BendTorsionArguments[j][k];
+      }
+
+      switch(Components[comp].BendTorsionType[j])
+      {
+        case SMOOTHED_DIHEDRAL:
+          // S(Theta1)*[p_0(1+cos(p_1*Phi-p_2)]*S(Theta2)
+          // ======================================================================================
+          // p_0/k_B [K/rad^2]
+          // p_1     [-]
+          // p_2     [degrees]
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        case SMOOTHED_THREE_COSINE_DIHEDRAL:
+          // S(Theta1)*[(1/2)*(1+cos(Phi))+(1/2)*p_1*(1-cos(2*Phi))+(1/2)*(1+cos(3*Phi))]*S(Theta2)
+          // ======================================================================================
+          // p_0/k_B [K]
+          // p_1/k_B [K]
+          // p_2/k_B [K]
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][1]=Components[SolventIndex].BendTorsionArguments[j][1];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        case NICHOLAS_DIHEDRAL:
+          // S(Theta1)*[(1/2)*(1+cos(Phi))+(1/2)*p_1*(1-cos(2*Phi))+(1/2)*(1+cos(3*Phi))]*S(Theta2)
+          // ======================================================================================
+          // p_0/k_B [K]
+          // p_1/k_B [K]
+          // p_2/k_B [K]
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][1]=Components[SolventIndex].BendTorsionArguments[j][1];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        case SMOOTHED_CFF_DIHEDRAL:
+         // S(Theta1)*[(1-cos(Phi))+p_1*(1-cos(2*Phi))+(1-cos(3*Phi))]*S(Theta2)
+          // ======================================================================================
+          // p_0/k_B [K]
+          // p_1/k_B [K]
+          // p_2/k_B [K]
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][1]=Components[SolventIndex].BendTorsionArguments[j][1];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        case SMOOTHED_CFF_DIHEDRAL2:
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][1]=Components[SolventIndex].BendTorsionArguments[j][1];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        case CVFF_BEND_TORSION_CROSS:
+        case CFF_BEND_TORSION_CROSS:
+          // p_0*(Theta1-p_1)*(Theta2-p_2)*cos(Phi)
+          // =====================================================================================
+          // p_0/k_B [K/rad^3]
+          // p_1     [degrees]
+          // p_2     [degrees]
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][1]=Components[SolventIndex].BendTorsionArguments[j][1];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        case SMOOTHED_CFF_BEND_TORSION_CROSS:
+          // S(Theta1)*[p_0*(Theta1-p_1)*(Theta2-p_2)*cos(Phi)]*S(Theta2)
+          // ======================================================================================
+          // p_0/k_B [K/rad^3]
+          // p_1     [degrees]
+          // p_2     [degrees]
+          Components[comp].BendTorsionArguments[j][0]=Components[SolventIndex].BendTorsionArguments[j][0];
+          Components[comp].BendTorsionArguments[j][1]=Components[SolventIndex].BendTorsionArguments[j][1];
+          Components[comp].BendTorsionArguments[j][2]=Components[SolventIndex].BendTorsionArguments[j][2];
+          break;
+        default:
+          fprintf(stderr, "Undefined Bend-Torsion potential in routine 'ReadComponentDefinition' ('molecule.c')\n");
+          exit(0);
+          break;
+      }
+    }
+  }	  
+	  
+  if(Components[comp].NumberOfIntraVDW>0)
+  {
+    for(j=0;j<Components[comp].NumberOfIntraVDW;j++)
+    {
+        Components[comp].IntraVDW[j].A=Components[SolventIndex].IntraVDW[j].A;
+        Components[comp].IntraVDW[j].B=Components[SolventIndex].IntraVDW[j].B;
+		Components[comp].IntraVDWScaling[j]=Components[SolventIndex].IntraVDWScaling[j];
+    }
+  }  
+	 
+  if(Components[comp].NumberOfIntraChargeCharge>0)
+  {
+    for(j=0;j<Components[comp].NumberOfIntraChargeCharge;j++)
+    {
+
+        Components[comp].IntraChargeCharge[j].A=Components[SolventIndex].IntraChargeCharge[j].A;
+        Components[comp].IntraChargeCharge[j].B=Components[SolventIndex].IntraChargeCharge[j].B;
+        Components[comp].IntraChargeChargeScaling[j]=Components[SolventIndex].IntraChargeChargeScaling[j];
+    }
+  }	  
+	  
+  // compute exclusions for the Ewald-summation
+  Components[comp].NumberOfExcludedIntraChargeCharge=0;
+  for(i=0;i<Components[comp].NumberOfAtoms-1;i++)
+  {
+    for(j=i+1;j<Components[comp].NumberOfAtoms;j++)
+    {
+      if((PseudoAtoms[Components[comp].Type[i]].HasCharges)&&(PseudoAtoms[Components[comp].Type[j]].HasCharges))
+      {
+        Components[comp].ExcludedIntraChargeCharge[Components[comp].NumberOfExcludedIntraChargeCharge].A=i;
+        Components[comp].ExcludedIntraChargeCharge[Components[comp].NumberOfExcludedIntraChargeCharge].B=j;
+        Components[comp].NumberOfExcludedIntraChargeCharge++;
+      }
+    }
+  }  
+	  
+  if(Components[comp].NumberOfIntraChargeBondDipole>0)
+  {
+    for(i=0;i<Components[comp].NumberOfIntraChargeBondDipole;i++)
+    {
+      Components[comp].IntraChargeBondDipole[i].A=Components[SolventIndex].IntraChargeBondDipole[i].A;
+      Components[comp].IntraChargeBondDipole[i].B=Components[SolventIndex].IntraChargeBondDipole[i].B;
+    }
+  }  
+	  
+  // add exclusion based on defined intra charge-bonddipole Coulombic potentials
+  Components[comp].NumberOfExcludedIntraChargeBondDipole=0;
+  for(i=0;i<Components[comp].NumberOfAtoms;i++)
+  {
+    if(PseudoAtoms[Components[comp].Type[i]].HasCharges)
+    {
+      for(j=0;j<Components[comp].NumberOfBondDipoles;j++)
+      {
+        Components[comp].ExcludedIntraChargeBondDipole[Components[comp].NumberOfExcludedIntraChargeBondDipole].A=i;
+        Components[comp].ExcludedIntraChargeBondDipole[Components[comp].NumberOfExcludedIntraChargeBondDipole].B=j;
+        Components[comp].NumberOfExcludedIntraChargeBondDipole++;
+      }
+    }
+  }	  
+	
+  if(Components[comp].NumberOfIntraBondDipoleBondDipole>0)
+  {
+    for(i=0;i<Components[comp].NumberOfIntraBondDipoleBondDipole;i++)
+    {
+
+      Components[comp].IntraBondDipoleBondDipole[i].A=Components[SolventIndex].IntraBondDipoleBondDipole[i].A;
+      Components[comp].IntraBondDipoleBondDipole[i].B=Components[SolventIndex].IntraBondDipoleBondDipole[i].B;
+    }
+  }  
+	
+  // add exclusion based on defined intra bonddipole-bonddipole Coulombic potentials
+  Components[comp].NumberOfExcludedIntraBondDipoleBondDipole=0;
+  for(i=0;i<Components[comp].NumberOfBondDipoles-1;i++)
+  {
+    for(j=i+1;j<Components[comp].NumberOfBondDipoles;j++)
+    {
+      Components[comp].ExcludedIntraBondDipoleBondDipole[Components[comp].NumberOfExcludedIntraBondDipoleBondDipole].A=i;
+      Components[comp].ExcludedIntraBondDipoleBondDipole[Components[comp].NumberOfExcludedIntraBondDipoleBondDipole].B=j;
+      Components[comp].NumberOfExcludedIntraBondDipoleBondDipole++;
+    }
+  }
+	  
+  // read the defined config moves  
+  Components[comp].NumberOfConfigMoves=Components[SolventIndex].NumberOfConfigMoves;
+	  
+  // allocate config-moves
+  Components[comp].NumberOfUnchangedAtomsConfig=(int*)calloc(Components[comp].NumberOfConfigMoves,sizeof(int));
+  Components[comp].UnchangedAtomsConfig=(int**)calloc(Components[comp].NumberOfConfigMoves,sizeof(int*));
+  
+  for(i=0;i<Components[comp].NumberOfConfigMoves;i++)
+  {
+    Components[comp].UnchangedAtomsConfig[i]=(int*)calloc(temp,sizeof(int));
+    Components[comp].NumberOfUnchangedAtomsConfig[i]=Components[SolventIndex].NumberOfUnchangedAtomsConfig[i];
+    for(j=0;j<temp;j++)
+    {
+		Components[comp].UnchangedAtomsConfig[i][j]=Components[SolventIndex].UnchangedAtomsConfig[i][j];
+    }
+  }
+  
+   // read the defined identity moves
+  temp=Components[SolventIndex].NumberOfIdentityConfigMoves;
+  Components[comp].NumberOfIdentityConfigMoves=0;
+  if(temp>1)
+  {
+    Components[comp].NumberOfIdentityConfigMoves=temp;
+    // allocate config-moves
+    Components[comp].NumberOfUnchangedAtomsIdentityConfig=(int*)calloc(Components[comp].NumberOfIdentityConfigMoves,sizeof(int));
+    Components[comp].UnchangedAtomsIdentityConfig=(int**)calloc(Components[comp].NumberOfIdentityConfigMoves,sizeof(int*));
+
+    for(i=0;i<Components[comp].NumberOfIdentityConfigMoves;i++)
+    {
+      Components[comp].UnchangedAtomsIdentityConfig[i]=(int*)calloc(temp,sizeof(int));
+      Components[comp].NumberOfUnchangedAtomsIdentityConfig[i]=temp;
+      for(j=0;j<temp;j++)
+      {
+        Components[comp].UnchangedAtomsIdentityConfig[i][j]=Components[SolventIndex].UnchangedAtomsIdentityConfig[i][j];
+      }
+    }
+  }
+  else
+  {
+    // allocate config-moves
+    Components[comp].StartingBead=Components[SolventIndex].StartingBead;
+    Components[comp].NumberOfIdentityConfigMoves=1;
+    Components[comp].NumberOfUnchangedAtomsIdentityConfig=(int*)calloc(Components[comp].NumberOfIdentityConfigMoves,sizeof(int));
+    Components[comp].UnchangedAtomsIdentityConfig=(int**)calloc(Components[comp].NumberOfIdentityConfigMoves,sizeof(int*));
+    Components[comp].UnchangedAtomsIdentityConfig[0]=(int*)calloc(1,sizeof(int));
+    Components[comp].NumberOfUnchangedAtomsIdentityConfig[0]=1;
+    Components[comp].UnchangedAtomsIdentityConfig[0][0]=Components[SolventIndex].UnchangedAtomsIdentityConfig[0][0]; // A MODIFIER
+  }
+
+  // Attribute defaults
+  Components[comp].LMCMOL=Components[SolventIndex].LMCMOL;
+ 
+  Components[comp].TranslationMatrix.ax=Components[SolventIndex].TranslationMatrix.ax;
+  Components[comp].TranslationMatrix.ay=Components[SolventIndex].TranslationMatrix.ay;
+  Components[comp].TranslationMatrix.az=Components[SolventIndex].TranslationMatrix.az;
+											
+  Components[comp].TranslationMatrix.bx=Components[SolventIndex].TranslationMatrix.bx;
+  Components[comp].TranslationMatrix.by=Components[SolventIndex].TranslationMatrix.by;
+  Components[comp].TranslationMatrix.bz=Components[SolventIndex].TranslationMatrix.bz;
+												
+  Components[comp].TranslationMatrix.cx=Components[SolventIndex].TranslationMatrix.cx;
+  Components[comp].TranslationMatrix.cy=Components[SolventIndex].TranslationMatrix.cy;
+  Components[comp].TranslationMatrix.cz=Components[SolventIndex].TranslationMatrix.cz;
+
+  Components[comp].SwapEvery=Components[SolventIndex].SwapEvery;
+
+  for(i=0;i<Components[comp].NumberOfAtoms;i++)
+  {
+    for(k=0;k<NumberOfSystems;k++)
+    {
+      Components[comp].MaximumCBMCChangeBondLength[k][i]=Components[SolventIndex].MaximumCBMCChangeBondLength[k][i];
+      Components[comp].MaximumCBMCChangeBendAngle[k][i] =Components[SolventIndex].MaximumCBMCChangeBendAngle[k][i];
+      Components[comp].MaximumCBMCRotationOnCone[k][i]  =Components[SolventIndex].MaximumCBMCRotationOnCone[k][i];
+      Components[comp].CBMCChangeBendAngleAttempts[k][i]=Components[SolventIndex].CBMCChangeBendAngleAttempts[k][i];
+      Components[comp].CBMCChangeBendAngleAccepted[k][i]=Components[SolventIndex].CBMCChangeBendAngleAccepted[k][i];
+      Components[comp].CBMCRotationOnConeAttempts[k][i] =Components[SolventIndex].CBMCRotationOnConeAttempts[k][i];
+      Components[comp].CBMCRotationOnConeAccepted[k][i] =Components[SolventIndex].CBMCRotationOnConeAccepted[k][i];
+    }
+  }
+
+  // search for 1-4 pairs and set scaling factors
+  // assumption: all bends must be defined
+  // there are 4-ways two bend-angle can be combined to define a quad, the non-mathcing pair is 1-4
+  
+  for(i=0;i<Components[comp].NumberOfIntraVDW;i++)
+  {
+    A=Components[comp].IntraVDW[i].A;
+    B=Components[comp].IntraVDW[i].B;
+
+    // LOOP
+    for(j=0;j<Components[comp].NumberOfBends;j++)
+    {
+      A1=Components[comp].Bends[j].A;
+      B1=Components[comp].Bends[j].B;
+      C1=Components[comp].Bends[j].C;
+      for(k=0;k<Components[comp].NumberOfBends;k++)
+      {
+        A2=Components[comp].Bends[k].A;
+        B2=Components[comp].Bends[k].B;
+        C2=Components[comp].Bends[k].C;
+
+        // 4 cases
+        if((B1==A2)&&(C1==B2)&&(((A1==A)&&(C2==B))||((A1==B)&&(C2==A)))) Components[comp].IntraVDWScaling[i]=Components[comp].Intra14VDWScalingValue;
+        if((B1==C2)&&(C1==B2)&&(((A1==A)&&(A2==B))||((A1==B)&&(A2==A)))) Components[comp].IntraVDWScaling[i]=Components[comp].Intra14VDWScalingValue;
+        if((A1==B2)&&(B1==A2)&&(((C1==A)&&(C2==B))||((C1==B)&&(C2==A)))) Components[comp].IntraVDWScaling[i]=Components[comp].Intra14VDWScalingValue;
+        if((A1==B2)&&(B1==C2)&&(((C1==A)&&(A2==B))||((C1==B)&&(A2==A)))) Components[comp].IntraVDWScaling[i]=Components[comp].Intra14VDWScalingValue;
+      }
+    }
+  }
+
+  // search for 1-4 pairs and set scaling factors
+  // assumption: all bends must be defined
+  // there are 4-ways two bend-angle can be combined to define a quad, the non-mathcing pair is 1-4
+  for(i=0;i<Components[comp].NumberOfIntraChargeCharge;i++)
+  {
+    A=Components[comp].IntraChargeCharge[i].A;
+    B=Components[comp].IntraChargeCharge[i].B;
+
+    // LOOP
+    for(j=0;j<Components[comp].NumberOfBends;j++)
+    {
+      A1=Components[comp].Bends[j].A;
+      B1=Components[comp].Bends[j].B;
+      C1=Components[comp].Bends[j].C;
+      for(k=0;k<Components[comp].NumberOfBends;k++)
+      {
+        A2=Components[comp].Bends[k].A;
+        B2=Components[comp].Bends[k].B;
+        C2=Components[comp].Bends[k].C;
+
+        // 4 cases
+        if((B1==A2)&&(C1==B2)&&(((A1==A)&&(C2==B))||((A1==B)&&(C2==A)))) Components[comp].IntraChargeChargeScaling[i]=Components[comp].Intra14ChargeChargeScalingValue;
+        if((B1==C2)&&(C1==B2)&&(((A1==A)&&(A2==B))||((A1==B)&&(A2==A)))) Components[comp].IntraChargeChargeScaling[i]=Components[comp].Intra14ChargeChargeScalingValue;
+        if((A1==B2)&&(B1==A2)&&(((C1==A)&&(C2==B))||((C1==B)&&(C2==A)))) Components[comp].IntraChargeChargeScaling[i]=Components[comp].Intra14ChargeChargeScalingValue;
+        if((A1==B2)&&(B1==C2)&&(((C1==A)&&(A2==B))||((C1==B)&&(A2==A)))) Components[comp].IntraChargeChargeScaling[i]=Components[comp].Intra14ChargeChargeScalingValue;
+      }
+    }
+  }
+
+  Components[comp].NumberOfHessianIndices=0;
+  for(i=0;i<Components[comp].NumberOfGroups;i++)
+  {
+    if(Components[comp].Groups[i].Rigid)
+      Components[comp].NumberOfHessianIndices++;
+    else
+      Components[comp].NumberOfHessianIndices+=Components[comp].Groups[i].NumberOfGroupAtoms;
+  }
+
+
+  // biasing spline
+  if(Components[comp].ReadBiasingFunction)
+  {
+    ReadBiasingProfile(comp);
+  }
+
+  }// end of loop over comp
+}
+
+/*********************************************************************************************************
+ * Name       | InitializeLambda    (Added by A. de Izarra)      					 	 				 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Initialization of the interpolation parameter of the alchemical transformation.			 *	
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void InitializeLambda(void)
+{
+  int i;
+  
+  Lambda    = (REAL*)calloc(AlchReacLambda+1,sizeof(REAL));
+  
+  for(i=0;i<=AlchReacLambda;i++)
+  {
+	Lambda[i]    = ((REAL)i)/AlchReacLambda;
+  }
+}
+
+
+void ManageFirstBead(int start)
+{
+  int i,type;
+  REAL EnergyHostVDW,EnergyAdsorbateVDW,EnergyCationVDW;
+  REAL EnergyHostChargeCharge,EnergyAdsorbateChargeCharge,EnergyCationChargeCharge;
+  REAL EnergyHostChargeBondDipole,EnergyAdsorbateChargeBondDipole,EnergyCationChargeBondDipole;
+  POINT posA;
+
+  // Remark: i=0 here because it is the first bead of the transient molecule.
+
+  // There is already a given position for the first bead.
+  posA=FirstBeadPosition;
+  type=Components[CurrentComponent].Type[start];
+
+  EnergyHostVDW=EnergyAdsorbateVDW=EnergyCationVDW=0.0;
+  EnergyHostChargeCharge=EnergyAdsorbateChargeCharge=EnergyCationChargeCharge=0.0;
+  EnergyHostChargeBondDipole=EnergyAdsorbateChargeBondDipole=EnergyCationChargeBondDipole=0.0;
+
+  // calculate energies
+  EnergyHostVDW=CalculateFrameworkVDWEnergyAtPosition(posA,type,CFVDWScaling[start]);
+  CalculateFrameworkChargeEnergyAtPosition(posA,type,&EnergyHostChargeCharge,&EnergyHostChargeBondDipole,CFChargeScaling[start]);
+
+  // compute VDW energy with adsorbates if no omit of adsorbate-adsorbate or the current molecule is a cation
+  if(Components[CurrentComponent].ExtraFrameworkMolecule||(!OmitAdsorbateAdsorbateVDWInteractions))
+    EnergyAdsorbateVDW=CalculateInterVDWEnergyAdsorbateAtPosition(posA,type,CurrentAdsorbateMolecule,CFVDWScaling[start]);
+
+  // compute Coulomb energy with adsorbates if no omit of adsorbate-adsorbate or the current molecule is a cation
+  if(Components[CurrentComponent].ExtraFrameworkMolecule||(!OmitAdsorbateAdsorbateCoulombInteractions))
+    CalculateInterChargeEnergyAdsorbateAtPosition(posA,type,&EnergyAdsorbateChargeCharge,&EnergyAdsorbateChargeBondDipole,CurrentAdsorbateMolecule,CFChargeScaling[start] * PseudoAtoms[type].Charge1);
+
+  // compute VDW energy with cations if no omit of cation-cation or the current molecule is an adsorbate
+  if((!Components[CurrentComponent].ExtraFrameworkMolecule)||(!OmitCationCationVDWInteractions))
+    EnergyCationVDW=CalculateInterVDWEnergyCationAtPosition(posA,type,CurrentCationMolecule,CFVDWScaling[start]);
+
+  // compute Coulomb energy with cations if no omit of cation-cation or the current molecule is an adsorbate
+  if((!Components[CurrentComponent].ExtraFrameworkMolecule)||(!OmitCationCationCoulombInteractions))
+    CalculateInterChargeEnergyCationAtPosition(posA,type,&EnergyCationChargeCharge,&EnergyCationChargeBondDipole,CurrentCationMolecule,CFChargeScaling[start] * PseudoAtoms[type].Charge1);
+
+    EnergyHostVDWFirstBead=EnergyHostVDW;
+    EnergyAdsorbateVDWFirstBead=EnergyAdsorbateVDW;
+
+    EnergyCationVDWFirstBead=EnergyCationVDW;
+
+    EnergyHostChargeChargeFirstBead=EnergyHostChargeCharge;
+    EnergyAdsorbateChargeChargeFirstBead=EnergyAdsorbateChargeCharge;
+    EnergyCationChargeChargeFirstBead=EnergyCationChargeCharge;
+
+    EnergyHostChargeBondDipoleFirstBead=EnergyHostChargeBondDipole;
+    EnergyAdsorbateChargeBondDipoleFirstBead=EnergyAdsorbateChargeBondDipole;
+    EnergyCationChargeBondDipoleFirstBead=EnergyCationChargeBondDipole;
+
+    EnergyHostBondDipoleBondDipoleFirstBead=0.0;
+    EnergyAdsorbateBondDipoleBondDipoleFirstBead=0.0;
+    EnergyCationBondDipoleBondDipoleFirstBead=0.0;
+
+}
+
+
+void ManageRemainingBeads(int NumberOldComponent)
+{
+  int j,k,ip,iu;
+
+  SetConnectivityMatrix();
+
+	if(NumberOldComponent==1) // water->ions
+	{
+		SetGrowingStatus();
+
+		Interactions();
+
+		for(k=0;k<Components[CurrentComponent].NumberOfAtoms;k++)
+		{
+		  // The new position to be inserted are in fact the old one (we do this to match raspa function.
+		  TrialPositions[0][k]=NewPosition[CurrentSystem][k];
+		}
+
+		ComputeExternalEnergies();
+			
+		UBondNew[CurrentSystem]+=UBondTrial[0];
+		UUreyBradleyNew[CurrentSystem]+=UUreyBradleyTrial[0];
+		UBendNew[CurrentSystem]+=UBendTrial[0];
+		UBendBendNew[CurrentSystem]+=UBendBendTrial[0];
+		UInversionBendNew[CurrentSystem]+=UInversionBendTrial[0];
+		UTorsionNew[CurrentSystem]+=UTorsionTrial[0];
+		UImproperTorsionNew[CurrentSystem]+=UImproperTorsionTrial[0];
+		UBondBondNew[CurrentSystem]+=UBondBondTrial[0];
+		UBondBendNew[CurrentSystem]+=UBondBendTrial[0];
+		UBondTorsionNew[CurrentSystem]+=UBondTorsionTrial[0];
+		UBendTorsionNew[CurrentSystem]+=UBendTorsionTrial[0];
+		UIntraVDWNew[CurrentSystem]+=UIntraVDWTrial[0];
+		UIntraChargeChargeNew[CurrentSystem]+=UIntraChargeChargeTrial[0];
+		UIntraChargeBondDipoleNew[CurrentSystem]+=UIntraChargeBondDipoleTrial[0];
+		UIntraBondDipoleBondDipoleNew[CurrentSystem]+=UIntraBondDipoleBondDipoleTrial[0];
+
+		UHostVDWNew[CurrentSystem]+=UHostVDWTrial[0];
+		UAdsorbateVDWNew[CurrentSystem]+=UAdsorbateVDWTrial[0];
+		UCationVDWNew[CurrentSystem]+=UCationVDWTrial[0];
+		UHostChargeChargeNew[CurrentSystem]+=UHostChargeChargeTrial[0];
+		UAdsorbateChargeChargeNew[CurrentSystem]+=UAdsorbateChargeChargeTrial[0];
+		UCationChargeChargeNew[CurrentSystem]+=UCationChargeChargeTrial[0];
+		UHostChargeBondDipoleNew[CurrentSystem]+=UHostChargeBondDipoleTrial[0];
+		UAdsorbateChargeBondDipoleNew[CurrentSystem]+=UAdsorbateChargeBondDipoleTrial[0];
+		UCationChargeBondDipoleNew[CurrentSystem]+=UCationChargeBondDipoleTrial[0];
+		UHostBondDipoleBondDipoleNew[CurrentSystem]+=UHostBondDipoleBondDipoleTrial[0];
+		UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]+=UAdsorbateBondDipoleBondDipoleTrial[0];
+		UCationBondDipoleBondDipoleNew[CurrentSystem]+=UCationBondDipoleBondDipoleTrial[0];
+	}
+	else // ions->water
+	{
+		SetGrowingStatus();
+
+		Interactions();
+
+		// The position of the first bead is already known. (it is the position of the former ion).
+
+		TrialPositions[0][0]=NewPosition[CurrentSystem][0];
+		  int comp = CurrentComponent;
+
+		GenerateTrialOrientationsSimpleSphere(FALSE);
+
+		ComputeExternalEnergies();
+
+		UBondNew[CurrentSystem]+=UBondTrial[0];
+		UBendNew[CurrentSystem]+=UBendTrial[0];
+		UBendBendNew[CurrentSystem]+=UBendBendTrial[0];
+		UInversionBendNew[CurrentSystem]+=UInversionBendTrial[0];
+		UUreyBradleyNew[CurrentSystem]+=UUreyBradleyTrial[0];
+		UTorsionNew[CurrentSystem]+=UTorsionTrial[0];
+		UImproperTorsionNew[CurrentSystem]+=UImproperTorsionTrial[0];
+		UBondBondNew[CurrentSystem]+=UBondBondTrial[0];
+		UBondBendNew[CurrentSystem]+=UBondBendTrial[0];
+		UBondTorsionNew[CurrentSystem]+=UBondTorsionTrial[0];
+		UBendTorsionNew[CurrentSystem]+=UBendTorsionTrial[0];
+		UIntraVDWNew[CurrentSystem]+=UIntraVDWTrial[0];
+		UIntraChargeChargeNew[CurrentSystem]+=UIntraChargeChargeTrial[0];
+		UIntraChargeBondDipoleNew[CurrentSystem]+=UIntraChargeBondDipoleTrial[0];
+		UIntraBondDipoleBondDipoleNew[CurrentSystem]+=UIntraBondDipoleBondDipoleTrial[0];
+
+		UCationVDWNew[CurrentSystem]+=UCationVDWTrial[0];
+		UAdsorbateVDWNew[CurrentSystem]+=UAdsorbateVDWTrial[0];
+		UHostVDWNew[CurrentSystem]+=UHostVDWTrial[0];
+		UHostChargeChargeNew[CurrentSystem]+=UHostChargeChargeTrial[0];
+		UAdsorbateChargeChargeNew[CurrentSystem]+=UAdsorbateChargeChargeTrial[0];
+		UCationChargeChargeNew[CurrentSystem]+=UCationChargeChargeTrial[0];
+		UHostChargeBondDipoleNew[CurrentSystem]+=UHostChargeBondDipoleTrial[0];
+		UAdsorbateChargeBondDipoleNew[CurrentSystem]+=UAdsorbateChargeBondDipoleTrial[0];
+		UCationChargeBondDipoleNew[CurrentSystem]+=UCationChargeBondDipoleTrial[0];
+		UHostBondDipoleBondDipoleNew[CurrentSystem]+=UHostBondDipoleBondDipoleTrial[0];
+		UAdsorbateBondDipoleBondDipoleNew[CurrentSystem]+=UAdsorbateBondDipoleBondDipoleTrial[0];
+		UCationBondDipoleBondDipoleNew[CurrentSystem]+=UCationBondDipoleBondDipoleTrial[0];
+	
+		// update the selected trial-position to the 'NewPosition'
+		for(j=NumberOfBeadsAlreadyPlaced;j<Components[CurrentComponent].NumberOfAtoms;j++)
+			NewPosition[CurrentSystem][j]=TrialPositions[0][j];
+	}
+	for(j=0;j<Components[CurrentComponent].Groups[CurrentGroup].NumberOfGroupAtoms;j++)
+    {
+          int atom_nr=Components[CurrentComponent].Groups[CurrentGroup].Atoms[j];
+    } 
+}
+
+/*********************************************************************************************************
+ * Name       | RemoveExtraPseudoAtoms    (Added by A. de Izarra)      					 	 		     *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Once alchemical transformation is finished, remove extra pseudo atoms of the molecules	 *
+ * 			  | that undergo the alchemical transformation.												 *	
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void RemoveExtraPseudoAtoms(void)
+{
+	
+	int i;
+	
+	PseudoAtoms=(PSEUDO_ATOM*)realloc(PseudoAtoms,(InitialPseudoAtoms)*sizeof(PSEUDO_ATOM));
+
+	NumberOfPseudoAtomsTypeNew=(int*)realloc(NumberOfPseudoAtomsTypeNew,(InitialPseudoAtoms)*sizeof(int));
+    NumberOfPseudoAtomsTypeOld=(int*)realloc(NumberOfPseudoAtomsTypeOld,(InitialPseudoAtoms)*sizeof(int));
+    MapPseudoAtom=(int*)realloc(MapPseudoAtom,(InitialPseudoAtoms)*sizeof(int));
+    
+
+    for(i=0;i<NumberOfSystems;i++)
+	{
+		 NumberOfPseudoAtomsCount[i]=(int*)realloc(NumberOfPseudoAtomsCount[i],(InitialPseudoAtoms)*sizeof(int));
+		 NumberOfPseudoAtomsType[i]=(int*)realloc(NumberOfPseudoAtomsType[i],(InitialPseudoAtoms)*sizeof(int));
+		 NumberOfFractionalPseudoAtomsType[i]=(int*)realloc(NumberOfFractionalPseudoAtomsType[i],(InitialPseudoAtoms)*sizeof(int));	
+	}
+	
+	// Reinitialize the size of Numberof pseudo atoms.
+	NumberOfPseudoAtoms=InitialPseudoAtoms;
+	
+	
+}
+
+/*********************************************************************************************************
+ * Name       | DeallocateTransientComponentMemory    (Added by A. de Izarra)      					     *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Deallocate memory for the component of the molecules that undergo the alchemical         *
+ * 			  | transformation.																			 *
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void DeallocateTransientComponentMemory(void)
+{
+	Components=(COMPONENT*)realloc(Components,(NumberOfComponents)*sizeof(COMPONENT));
+}
+
+/*********************************************************************************************************
+ * Name       | DeallocateMemoryParameterTab    (Added by A. de Izarra)      					     	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Deallocate memory for the paramter tab that store the vdw interaction for the 			 *
+ * 			  | pseudoatoms of the molecules that undergo the alchemical transformation.				 *
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void DeallocateMemoryParameterTab(void)
+{
+	int i;
+	 //-----------------------------------------------
+	 // reallocate extra memory in PotentialParms, updated at each alchemical transformation step.
+	 PotentialParms=(REAL(**)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS])realloc(PotentialParms,
+	 (InitialPseudoAtoms)*sizeof(REAL(*)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS]));
+
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {
+		  PotentialParms[i] = (REAL(*)[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS])realloc(PotentialParms[i],(InitialPseudoAtoms)*sizeof(REAL[MAX_NUMBER_OF_POTENTIAL_ARGUMENTS]));
+	 }
+
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		  //free(PotentialParms[i]); 
+	 }
+
+     
+	 //-----------------------------------------------
+	 // reallocate extra memory in Potentialtyoe
+	 PotentialType=(int**)realloc(PotentialType,(InitialPseudoAtoms)*(sizeof(int*)));
+		 
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {	 
+	
+		PotentialType[i] = (int*)realloc(PotentialType[i],(InitialPseudoAtoms)*sizeof(int));
+	 }
+		 
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		//free(PotentialType[i]);
+	 }
+
+		
+	
+	//-----------------------------------------------
+	// Allocate extra memory for tail correction.
+	TailCorrection=(int**)realloc(TailCorrection,(InitialPseudoAtoms)*(sizeof(int*)));
+	 
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {
+		  TailCorrection[i] = (int*)realloc(TailCorrection[i],(InitialPseudoAtoms)*sizeof(int));
+	 }
+	 
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		 // free(TailCorrection[i]);
+	 }
+
+	
+	
+	//-----------------------------------------------
+	// Allocate extra memory for shift potential
+	ShiftPotential=(int**)realloc(ShiftPotential,(InitialPseudoAtoms)*(sizeof(int*)));
+	 
+	 for(i = 0; i < InitialPseudoAtoms; i++)
+	 {
+		  ShiftPotential[i] = (int*)realloc(ShiftPotential[i],(InitialPseudoAtoms)*sizeof(int));
+	 }
+	 
+	 for(i = InitialPseudoAtoms; i < InitialPseudoAtoms+NumberExtraPseudoAtoms; i++)
+	 {
+		  //free(ShiftPotential[i]);
+	 }	 
+}
+
+/*********************************************************************************************************
+ * Name       | DeallocateChosenMoitiesCoordinates    (Added by A. de Izarra)      					     *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Deallocate the vectors that store the initial position of the molecules that			 *
+ * 			  | undergo the alchemical transformation.													 *
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void DeallocateChosenMoitiesCoordinates(void)
+{
+	int i,j;
+	
+	for(i=0;i<NumberTransientMoities[CurrentAlchemicalReaction];i++)
+	{
+		free(AdsorbatesReferenceChosen[i].Atoms);
+		free(AdsorbatesReferenceChosen[i].Groups);
+	}
+	
+	free(AdsorbatesReferenceChosen);
+}
diff --git a/src/Alchemical_transformation.h b/src/Alchemical_transformation.h
new file mode 100644
index 0000000..2a0b49d
--- /dev/null
+++ b/src/Alchemical_transformation.h
@@ -0,0 +1,130 @@
+// Alchemical_transformation.h Added by Ambroise de Izarra
+/* 
+ * Alchemical transformation is added to build functions that peform
+ * an alchemical transformation at a fixed number of particule in the system (osmotic ensemble)
+ */ 
+#ifndef ALCHEMICAL_H
+#define ALCHEMICAL_H
+
+#include "molecule.h"
+
+extern int IsAlchemicalorOsmoticStep;
+
+extern int InitialPseudoAtoms;
+extern int NumberExtraPseudoAtoms;
+extern int NumberExtraComponents;
+extern int CurrentAlchemicalReaction;
+extern int IndexExtraComponent[2];
+extern int TransientMoleculeNbAtoms;
+
+// Save in memory initial coordinates of chosen moities 
+extern ADSORBATE_MOLECULE *AdsorbatesReferenceChosen;
+extern VECTOR **SolventBodyfixedPositions;
+
+// Save in memory initial NumberofPseudoType tables.
+extern int **NumberOfPseudoAtomsReferenceType;
+extern int *NumberOfPseudoAtomsReferenceTypeNew;
+extern int *NumberOfPseudoAtomsReferenceTypeOld;
+
+// Save in memory the degree of freedom
+extern int DegreesOfFreedomReferenceAdsorbates;
+extern int DegreesOfFreedomReferenceTranslation;
+extern int DegreesOfFreedomReferenceTranslationalAdsorbates;
+extern int DegreesOfFreedomReference;
+                              
+extern int DegreesOfFreedomReferenceRotation;
+extern int DegreesOfFreedomReferenceAdsorbates;
+extern int DegreesOfFreedomReferenceRotationalAdsorbates;
+
+// Declare the chemical potential os the osmostat.
+extern REAL *AlchemicalWorkStore;
+extern REAL *AlchemicalWorkStore_vdw;
+extern REAL *AlchemicalWorkStore_elec;
+extern int SizeAlchemicalWorkStore;
+
+// for the NVE move during the Alchemical transformation.
+extern REAL *HybridNVEAlchDrift;
+extern REAL *HybridNVEAlchDriftCount;
+
+extern REAL *HybridNVEAlchStartTemperature;
+extern REAL *HybridNVEAlchStartTranslationalTemperature;
+extern REAL *HybridNVEAlchStartRotationalTemperature;
+extern REAL *HybridNVEAlchStartTemperatureFramework;
+extern REAL *HybridNVEAlchStartTemperatureAdsorbate;
+extern REAL *HybridNVEAlchStartTemperatureCation;
+extern REAL *HybridNVEAlchStartTemperatureCount;
+extern REAL *HybridNVEAlchStartTemperatureTranslationCount;
+extern REAL *HybridNVEAlchStartTemperatureRotationCount;
+extern REAL *HybridNVEAlchStartTemperatureFrameworkCount;
+extern REAL *HybridNVEAlchStartTemperatureAdsorbateCount;
+extern REAL *HybridNVEAlchStartTemperatureCationCount;
+
+extern REAL *HybridNVEAlchEndTemperature;
+extern REAL *HybridNVEAlchEndTranslationalTemperature;
+extern REAL *HybridNVEAlchEndRotationalTemperature;
+extern REAL *HybridNVEAlchEndTemperatureFramework;
+extern REAL *HybridNVEAlchEndTemperatureAdsorbate;
+extern REAL *HybridNVEAlchEndTemperatureCation;
+extern REAL *HybridNVEAlchEndTemperatureCount;
+extern REAL *HybridNVEAlchEndTemperatureTranslationCount;
+extern REAL *HybridNVEAlchEndTemperatureRotationCount;
+extern REAL *HybridNVEAlchEndTemperatureFrameworkCount;
+extern REAL *HybridNVEAlchEndTemperatureAdsorbateCount;
+extern REAL *HybridNVEAlchEndTemperatureCationCount;
+
+// File to write Alchemical work thorugh MC.
+extern FILE *OutputOsmostatFilePtr;
+
+// Manage storage of the Alchemicalwork and write Alchemical work
+void InitializeStoreAlchemicalWork(void);
+void IncreaseSizeAlchemicalWork(void);
+void InitializeFileAlchemicalWork(int Size);
+void UpdateFileAlchemicalWork(int index, FILE *FilePtr);
+
+// Initialize statistics for NVE-MD during alchemical transformation.
+void InitializeNVEAlchStatistics(void);
+
+// Index and constant for managing transient components.
+void InitializeIndexManagingTransientMoities(void);
+
+// Prepare addition of transient
+void MakeInitialTransient(int NumberOldComponent);
+void GrowTransient(int Iicode);
+void ReallocateMemoryParameterTab(void);
+
+// Management of charge during alchemical transformation.
+void InitializeVectorCharge(void);
+void InitializeChargeTransientMoities(int NumberOldComponent);
+void UpdateChargeInterpolationAlchemicalTransformation(int NumberOldComponent, REAL Lambda);
+
+// Management of vdw para during alchemical transformation.
+void InitializeVectorforMixingRule(void);
+void InitializeVDWTransientMoities(int NumberOldComponent);
+void UpdateMixingRuleVDWInterpolationAlchemicalTransformation(int NumberOldComponent, REAL Lambda);
+
+// Preparation of the initial system: store coordinates of Chosen moities and delete chosen moities from adsorbates + Update the energy. 
+void StoreChosenMoitiesCoordinates(int NumberOldComponent);
+void DeleteChosenMoities(void);
+
+// If step accepted, transfert the moities into the "regular" components.
+void SwitchMoietiestoRegularComponents(int NumberNewComponent);
+
+// Initialize vectors, memory
+void InitializeMassTransientMoities(int NumberOldComponent);
+void EndMassTransientMoities(int NumberOldComponent);
+void UpdateInertiaTensorGroups(int comp);
+void AllocateTransientComponentMemory(void);
+void AddExtraPseudoAtoms(void);
+
+// Initialize lambda for interpolation of non-bonded parameter.
+void InitializeLambda(void);
+
+// Deallocate memory at the end of each step.
+void RemoveExtraPseudoAtoms();
+void DeallocateTransientComponentMemory();
+void DeallocateMemoryParameterTab();
+void DeallocateChosenMoitiesCoordinates();
+
+
+#endif
+
diff --git a/src/cbmc.c b/src/cbmc.c
index e8e53b4..142b920 100644
--- a/src/cbmc.c
+++ b/src/cbmc.c
@@ -62,23 +62,26 @@ static REAL RosenbluthOld;             // the old Rosenbluth weight (retrace)
 static REAL *RosenbluthTorsion;
 static REAL RosenBluthFactorFirstBead;
 
-static int CurrentBead;       // the current bead (new beads are grown from this one)
-static int CurrentGroup;      // the current group
+// Modified by Ambroise switch static to non-static
+//-------------------------------------------------------------------
+int CurrentBead;       // the current bead (new beads are grown from this one)
+int CurrentGroup;      // the current group
 
-static int NumberOfPreviousBeads;  // the number of previous beads
-static int PreviousBead;           // the first previous bead
-static int PreviousGroup;          // the previous group
+int NumberOfPreviousBeads;  // the number of previous beads
 
-static int NumberOfBeadsToBePlaced;              // the numer of beads to be placed
-static int *BeadsToBePlaced;
+int PreviousBead;           // the first previous bead
+int PreviousGroup;          // the previous group
+
+int NumberOfBeadsToBePlaced;              // the numer of beads to be placed
+int *BeadsToBePlaced;
 
 int NumberOfBeadsAlreadyPlaced;              // the number of beads already placed
 int *BeadsAlreadyPlaced; // a list of atom-ids
 
-static int NumberOfBranches;                                      // the number of branches
-static int *NumberOfBranchAtoms;              // the number of atoms per branch
-static int **BranchAtoms; // a list of atom-ids per branch
-
+int NumberOfBranches;                                      // the number of branches
+int *NumberOfBranchAtoms;              // the number of atoms per branch
+int **BranchAtoms; // a list of atom-ids per branch
+//-------------------------------------------------------------------
 VECTOR FirstBeadPosition;
 VECTOR **NewPosition;
 VECTOR *OldPosition;
@@ -268,43 +271,43 @@ REAL *UCationPermanentDipolePermanentDipoleOld;
 REAL *UHostPermanentDipolePermanentDipoleOld;
 
 // trial energies
-static REAL *UBondTrial;
-static REAL *UBendTrial;
-static REAL *UBendBendTrial;
-static REAL *UUreyBradleyTrial;
-static REAL *UInversionBendTrial;
-static REAL *UTorsionTrial;
-static REAL *UImproperTorsionTrial;
-static REAL *UBondBondTrial;
-static REAL *UBondBendTrial;
-static REAL *UBondTorsionTrial;
-static REAL *UBendTorsionTrial;
-static REAL *UIntraVDWTrial;
-static REAL *UIntraChargeChargeTrial;
-static REAL *UIntraChargeBondDipoleTrial;
-static REAL *UIntraBondDipoleBondDipoleTrial;
-
-static REAL *UHostVDWTrial;
-static REAL *UAdsorbateVDWTrial;
-static REAL *UCationVDWTrial;
-static REAL *UHostChargeChargeTrial;
-static REAL *UAdsorbateChargeChargeTrial;
-static REAL *UCationChargeChargeTrial;
-static REAL *UHostChargeBondDipoleTrial;
-static REAL *UAdsorbateChargeBondDipoleTrial;
-static REAL *UCationChargeBondDipoleTrial;
-static REAL *UHostChargePermanentDipoleTrial;
-static REAL *UAdsorbateChargePermanentDipoleTrial;
-static REAL *UCationChargePermanentDipoleTrial;
-static REAL *UHostBondDipoleBondDipoleTrial;
-static REAL *UAdsorbateBondDipoleBondDipoleTrial;
-static REAL *UCationBondDipoleBondDipoleTrial;
-static REAL *UHostBondDipolePermanentDipoleTrial;
-static REAL *UAdsorbateBondDipolePermanentDipoleTrial;
-static REAL *UCationBondDipolePermanentDipoleTrial;
-static REAL *UHostPermanentDipolePermanentDipoleTrial;
-static REAL *UAdsorbatePermanentDipolePermanentDipoleTrial;
-static REAL *UCationPermanentDipolePermanentDipoleTrial;
+REAL *UBondTrial;
+REAL *UBendTrial;
+REAL *UBendBendTrial;
+REAL *UUreyBradleyTrial;
+REAL *UInversionBendTrial;
+REAL *UTorsionTrial;
+REAL *UImproperTorsionTrial;
+REAL *UBondBondTrial;
+REAL *UBondBendTrial;
+REAL *UBondTorsionTrial;
+REAL *UBendTorsionTrial;
+REAL *UIntraVDWTrial;
+REAL *UIntraChargeChargeTrial;
+REAL *UIntraChargeBondDipoleTrial;
+REAL *UIntraBondDipoleBondDipoleTrial;
+
+REAL *UHostVDWTrial;
+REAL *UAdsorbateVDWTrial;
+REAL *UCationVDWTrial;
+REAL *UHostChargeChargeTrial;
+REAL *UAdsorbateChargeChargeTrial;
+REAL *UCationChargeChargeTrial;
+REAL *UHostChargeBondDipoleTrial;
+REAL *UAdsorbateChargeBondDipoleTrial;
+REAL *UCationChargeBondDipoleTrial;
+REAL *UHostChargePermanentDipoleTrial;
+REAL *UAdsorbateChargePermanentDipoleTrial;
+REAL *UCationChargePermanentDipoleTrial;
+REAL *UHostBondDipoleBondDipoleTrial;
+REAL *UAdsorbateBondDipoleBondDipoleTrial;
+REAL *UCationBondDipoleBondDipoleTrial;
+REAL *UHostBondDipolePermanentDipoleTrial;
+REAL *UAdsorbateBondDipolePermanentDipoleTrial;
+REAL *UCationBondDipolePermanentDipoleTrial;
+REAL *UHostPermanentDipolePermanentDipoleTrial;
+REAL *UAdsorbatePermanentDipolePermanentDipoleTrial;
+REAL *UCationPermanentDipolePermanentDipoleTrial;
 
 static REAL EnergyHostVDWFirstBead;
 static REAL EnergyAdsorbateVDWFirstBead;
@@ -368,17 +371,24 @@ static int *BoolToBePlaced;
 static int *BoolAlreadyPlacedOrToBePlaced;
 static int *beadn;
 static int *PossibleCurrentBeads;
-static int **MoleculeTodoConnectivity;
+int **MoleculeTodoConnectivity;
 static int **MoleculeConnectivity;
 
+// Added by Ambroise de Izarra
+//-----------------------------------------------------------------------------
+// Switch from static to non static because used for alchemical transformation
 static int HandleFirstBead(int Switch);
-static void Interactions(void);
-static int GenerateTrialOrientationsSimpleSphere(int Old);
-static int GenerateTrialOrientationsMCScheme(int Old);
-static int ComputeExternalEnergies(void);
+void Interactions(void);
 
-static int Rosen(void);
-static int RosenOld(void);
+// Switch from static to non static because used for alchemical transformation
+int GenerateTrialOrientationsSimpleSphere(int Old);
+int GenerateTrialOrientationsMCScheme(int Old);
+int ComputeExternalEnergies(void);
+
+// Switch from static to non static because used for alchemical transformation
+int Rosen(void);
+int RosenOld(void);
+//-----------------------------------------------------------------------------
 
 static REAL ComputeSumRosenbluthWeight(REAL *BoltzmannFactors,int *Overlap,int NumberOfTrialPositions);
 static REAL ComputeNormalizedRosenbluthWeight(REAL *BoltzmannFactors,int *Overlap,int NumberOfTrialPositions);
@@ -654,6 +664,7 @@ int HandleFirstBead(int Switch)
         FirstBeadPosition=ConvertFromABCtoXYZ(s);
       } while(!ValidCartesianPoint(CurrentComponent,FirstBeadPosition));
     }
+    
     Trial[i]=FirstBeadPosition;
 
     posA=Trial[i];
@@ -759,6 +770,7 @@ int HandleFirstBead(int Switch)
 
   EnergyHostVDWFirstBead=EnergiesHostVDW[i];
   EnergyAdsorbateVDWFirstBead=EnergiesAdsorbateVDW[i];
+  
   EnergyCationVDWFirstBead=EnergiesCationVDW[i];
 
   EnergyHostChargeChargeFirstBead=EnergiesHostChargeCharge[i];
@@ -1139,9 +1151,14 @@ void Interactions(void)
   }
 }
 
+// Added by Ambroise de Izarra;
+//-------------------------------------------------------------------
+int Itrial;
+//-------------------------------------------------------------------
 int ComputeExternalEnergies(void)
 {
-  int i,j,Itrial,A,B,type,typeA,typeB;
+	
+  int i,j,A,B,type,typeA,typeB;
   REAL rr,r;
   REAL EnergiesIntra,EnergiesIntraChargeCharge,EnergiesIntraChargeBondDipole,EnergiesIntraBondDipoleBondDipole;
   REAL EnergyHostVDW,EnergyAdsorbateVDW,EnergyCationVDW;
@@ -1181,12 +1198,13 @@ int ComputeExternalEnergies(void)
     EnergiesHostBondDipoleBondDipole=0.0;
     EnergiesAdsorbateBondDipoleBondDipole=0.0;
     EnergiesCationBondDipoleBondDipole=0.0;
-
+  
     for(j=0;j<NumberOfBeadsToBePlaced;j++)
     {
       TRIAL_OVERLAP=FALSE;
       if (BeadsToBePlaced[j]<Components[CurrentComponent].NumberOfAtoms)
       {
+			
         posAVDW=posA=TrialPositions[Itrial][BeadsToBePlaced[j]];
         type=Components[CurrentComponent].Type[BeadsToBePlaced[j]];
 
@@ -1462,6 +1480,7 @@ int ComputeExternalEnergies(void)
       Overlap[Itrial]=TRUE;
     }
   }
+
   return 0;
 }
 
@@ -1516,6 +1535,8 @@ int GenerateTrialOrientationsSimpleSphere(int Old)
       bond_length[j]=GenerateBondlength(Bonds[j]);
   }
 
+  
+
   for(iu=0;iu<NumberOfTrialPositions;iu++)
   {
     if(!(Old&&iu==0))    // generate 'k' new trial positions for the second bead except for the first trial position (iu=0) when retracing
@@ -1531,18 +1552,18 @@ int GenerateTrialOrientationsSimpleSphere(int Old)
           atom_nr=Components[CurrentComponent].Groups[CurrentGroup].Atoms[j];
           cord[j].x=Components[CurrentComponent].Positions[atom_nr].x-Components[CurrentComponent].Positions[CurrentBead].x;
           cord[j].y=Components[CurrentComponent].Positions[atom_nr].y-Components[CurrentComponent].Positions[CurrentBead].y;
-          cord[j].z=Components[CurrentComponent].Positions[atom_nr].z-Components[CurrentComponent].Positions[CurrentBead].z;
+          cord[j].z=Components[CurrentComponent].Positions[atom_nr].z-Components[CurrentComponent].Positions[CurrentBead].z;          
         }
-
+        
         RandomArrayRotationMatrix(cord,Components[CurrentComponent].Groups[CurrentGroup].NumberOfGroupAtoms);
-
+		
         for(j=0;j<Components[CurrentComponent].Groups[CurrentGroup].NumberOfGroupAtoms;j++)
         {
           atom_nr=Components[CurrentComponent].Groups[CurrentGroup].Atoms[j];
           TrialPositions[iu][atom_nr].x=TrialPositions[0][CurrentBead].x+cord[j].x;
           TrialPositions[iu][atom_nr].y=TrialPositions[0][CurrentBead].y+cord[j].y;
           TrialPositions[iu][atom_nr].z=TrialPositions[0][CurrentBead].z+cord[j].z;
-        }
+        }  
       }
       else
       {
@@ -2760,12 +2781,14 @@ int Rosen(void)
     SetGrowingStatus();
 
     Interactions();
-
+    
+   
+    
     // fill trialpositions of the beads that are already grown
     for(iu=0;iu<NumberOfTrialPositions;iu++)
       for(j=0;j<NumberOfBeadsAlreadyPlaced;j++)
         TrialPositions[iu][BeadsAlreadyPlaced[j]]=NewPosition[CurrentSystem][BeadsAlreadyPlaced[j]];
-
+		
     for(j=0;j<NumberOfTrialPositionsTorsion;j++)
       RosenbluthTorsion[j]=1.0;
 
@@ -2832,7 +2855,7 @@ int Rosen(void)
         MoleculeTodoConnectivity[j][ip]=FALSE;
     }
   } while(NumberOfBeadsAlreadyPlaced!=Components[CurrentComponent].NumberOfAtoms);
-
+  
   return 0;
 }
 
@@ -2948,7 +2971,7 @@ REAL RetraceMolecule(int Iicode)
   UHostBondDipoleBondDipoleOld[CurrentSystem]=0.0;
   UAdsorbateBondDipoleBondDipoleOld[CurrentSystem]=0.0;
   UCationBondDipoleBondDipoleOld[CurrentSystem]=0.0;
-
+  
   RosenbluthOld=1.0;
 
   OVERLAP=FALSE;
@@ -2972,6 +2995,7 @@ REAL RetraceMolecule(int Iicode)
     RosenbluthOld=RosenBluthFactorFirstBead;
 
     UCationVDWOld[CurrentSystem]=EnergyCationVDWFirstBead;
+    
     UAdsorbateVDWOld[CurrentSystem]=EnergyAdsorbateVDWFirstBead;
     UHostVDWOld[CurrentSystem]=EnergyHostVDWFirstBead;
 
diff --git a/src/cbmc.h b/src/cbmc.h
index 8671873..16d5d4c 100644
--- a/src/cbmc.h
+++ b/src/cbmc.h
@@ -44,6 +44,11 @@ extern int BiasingMethod;
 
 #define MAX_NUMBER_OF_TRIAL_POSITIONS 2000
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+extern int Itrial;
+//-------------------------------------------------------------------
+
 extern int NumberOfTrialPositions;
 extern int NumberOfTrialPositionsForTheFirstBead;
 extern int NumberOfTrialMovesPerOpenBead;
@@ -146,8 +151,66 @@ extern REAL *UHostBondDipoleBondDipoleOld;
 extern REAL *UAdsorbateBondDipoleBondDipoleOld;
 extern REAL *UCationBondDipoleBondDipoleOld;
 
-extern int NumberOfBeadsAlreadyPlaced;                         // number of atoms that are already placed
-extern int *BeadsAlreadyPlaced;
+// trial energies
+extern REAL *UBondTrial;
+extern REAL *UBendTrial;
+extern REAL *UBendBendTrial;
+extern REAL *UUreyBradleyTrial;
+extern REAL *UInversionBendTrial;
+extern REAL *UTorsionTrial;
+extern REAL *UImproperTorsionTrial;
+extern REAL *UBondBondTrial;
+extern REAL *UBondBendTrial;
+extern REAL *UBondTorsionTrial;
+extern REAL *UBendTorsionTrial;
+extern REAL *UIntraVDWTrial;
+extern REAL *UIntraChargeChargeTrial;
+extern REAL *UIntraChargeBondDipoleTrial;
+extern REAL *UIntraBondDipoleBondDipoleTrial;
+
+extern REAL *UHostVDWTrial;
+extern REAL *UAdsorbateVDWTrial;
+extern REAL *UCationVDWTrial;
+extern REAL *UHostChargeChargeTrial;
+extern REAL *UAdsorbateChargeChargeTrial;
+extern REAL *UCationChargeChargeTrial;
+extern REAL *UHostChargeBondDipoleTrial;
+extern REAL *UAdsorbateChargeBondDipoleTrial;
+extern REAL *UCationChargeBondDipoleTrial;
+extern REAL *UHostChargePermanentDipoleTrial;
+extern REAL *UAdsorbateChargePermanentDipoleTrial;
+extern REAL *UCationChargePermanentDipoleTrial;
+extern REAL *UHostBondDipoleBondDipoleTrial;
+extern REAL *UAdsorbateBondDipoleBondDipoleTrial;
+extern REAL *UCationBondDipoleBondDipoleTrial;
+extern REAL *UHostBondDipolePermanentDipoleTrial;
+extern REAL *UAdsorbateBondDipolePermanentDipoleTrial;
+extern REAL *UCationBondDipolePermanentDipoleTrial;
+extern REAL *UHostPermanentDipolePermanentDipoleTrial;
+extern REAL *UAdsorbatePermanentDipolePermanentDipoleTrial;
+extern REAL *UCationPermanentDipolePermanentDipoleTrial;
+
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+extern int CurrentBead;       
+extern int CurrentGroup;      
+
+extern int NumberOfPreviousBeads;  
+
+extern int PreviousBead;           
+extern int PreviousGroup;          
+
+extern int NumberOfBeadsToBePlaced;
+extern int *BeadsToBePlaced;
+
+extern int NumberOfBeadsAlreadyPlaced; 
+extern int *BeadsAlreadyPlaced; 
+
+extern int NumberOfBranches;           
+extern int *NumberOfBranchAtoms;       
+extern int **BranchAtoms; 
+//-------------------------------------------------------------------
+
 extern VECTOR **NewPosition;
 extern VECTOR *OldPosition;
 extern VECTOR **NewVelocity;
@@ -160,6 +223,13 @@ extern REAL *CFChargeScaling;
 extern REAL **CFChargeScalingRXMC;
 extern int OVERLAP;
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+int Rosen(void);
+//-------------------------------------------------------------------
+
+extern int **MoleculeTodoConnectivity;
+
 void CalculateAnisotropicTrialPositions(int TypeMolA,VECTOR *TrialPosition,VECTOR *TrialAnisotropicPosition);
 
 REAL GrowMolecule(int Iicode);
diff --git a/src/constants.c b/src/constants.c
index 07b6bc6..d30744f 100644
--- a/src/constants.c
+++ b/src/constants.c
@@ -74,6 +74,11 @@ REAL VOLUMETRIC_EXPANSION_COEFFICIENT_CONVERSION_FACTOR;
 REAL FH_CONVERSION_FACTOR;
 
 REAL ENERGY_TO_KELVIN;
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+REAL KJ_PER_MOL_TO_ENERGY;
+//-------------------------------------------------------------------
+
 REAL KELVIN_TO_ENERGY;
 REAL ENERGY_TO_KJ_PER_MOL;
 REAL ENERGY_TO_EV;
@@ -123,6 +128,10 @@ void SetSimulationUnits(void)
     FH_CONVERSION_FACTOR=1.0;
 
     ENERGY_TO_KELVIN=1.0;
+    // Added by Ambroise de Izarra
+    //------------------------------------------------------------------
+    KJ_PER_MOL_TO_ENERGY=1.0;
+   //-------------------------------------------------------------------
     KELVIN_TO_ENERGY=1.0;
     ENERGY_TO_KJ_PER_MOL=1.0;
     ENERGY_TO_EV=1.0;
@@ -172,6 +181,10 @@ void SetSimulationUnits(void)
     ENERGY_TO_KELVIN=((ENERGY_CONVERSION_FACTOR*AVOGADRO_CONSTANT)/MOLAR_GAS_CONSTANT);
     KELVIN_TO_ENERGY=(MOLAR_GAS_CONSTANT/(ENERGY_CONVERSION_FACTOR*AVOGADRO_CONSTANT));
     ENERGY_TO_KJ_PER_MOL=((ENERGY_CONVERSION_FACTOR*AVOGADRO_CONSTANT)/1000.0);
+    // Added by Ambroise de Izarra
+    //-------------------------------------------------------------------
+    KJ_PER_MOL_TO_ENERGY=(1000.0/(ENERGY_CONVERSION_FACTOR*AVOGADRO_CONSTANT));
+    //-------------------------------------------------------------------
     ENERGY_TO_EV=(ENERGY_TO_KELVIN/11604.23);
     ENERGY_TO_KCAL_PER_MOL=((ENERGY_CONVERSION_FACTOR*AVOGADRO_CONSTANT)/4184.0);
     ENERGY_TO_KCAL15_PER_MOL=((ENERGY_CONVERSION_FACTOR*AVOGADRO_CONSTANT)/4185.5);
@@ -221,6 +234,10 @@ void WriteRestartConstants(FILE *FilePtr)
   fwrite(&FH_CONVERSION_FACTOR,sizeof(REAL),1,FilePtr);
 
   fwrite(&ENERGY_TO_KELVIN,sizeof(REAL),1,FilePtr);
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  fwrite(&KJ_PER_MOL_TO_ENERGY,sizeof(REAL),1,FilePtr);
+  //-------------------------------------------------------------------
   fwrite(&KELVIN_TO_ENERGY,sizeof(REAL),1,FilePtr);
   fwrite(&ENERGY_TO_KJ_PER_MOL,sizeof(REAL),1,FilePtr);
   fwrite(&ENERGY_TO_EV,sizeof(REAL),1,FilePtr);
@@ -279,6 +296,10 @@ void ReadRestartConstants(FILE *FilePtr)
   fread(&FH_CONVERSION_FACTOR,sizeof(REAL),1,FilePtr);
 
   fread(&ENERGY_TO_KELVIN,sizeof(REAL),1,FilePtr);
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  fread(&KJ_PER_MOL_TO_ENERGY,sizeof(REAL),1,FilePtr);
+  //-------------------------------------------------------------------
   fread(&KELVIN_TO_ENERGY,sizeof(REAL),1,FilePtr);
   fread(&ENERGY_TO_KJ_PER_MOL,sizeof(REAL),1,FilePtr);
   fread(&ENERGY_TO_EV,sizeof(REAL),1,FilePtr);
diff --git a/src/constants.h b/src/constants.h
index 17844c5..bba7d0d 100644
--- a/src/constants.h
+++ b/src/constants.h
@@ -141,6 +141,10 @@ extern REAL FH_CONVERSION_FACTOR;
 
 extern REAL ENERGY_TO_KELVIN;
 extern REAL KELVIN_TO_ENERGY;
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+extern REAL KJ_PER_MOL_TO_ENERGY;
+//-------------------------------------------------------------------
 extern REAL ENERGY_TO_KJ_PER_MOL;
 extern REAL ENERGY_TO_EV;
 extern REAL ENERGY_TO_KCAL_PER_MOL;
diff --git a/src/framework.c b/src/framework.c
index 726447b..7eae0aa 100644
--- a/src/framework.c
+++ b/src/framework.c
@@ -6731,6 +6731,7 @@ int ReturnDipoleIndex(int f1,int A,int B)
 
 void AddBondTypeToDefinitions(int TypeA,int TypeB,int BondType,REAL *parms)
 {
+
   int i,j,index;
   int AlreadyPresent;
   int NumberOfArguments;
@@ -6749,7 +6750,7 @@ void AddBondTypeToDefinitions(int TypeA,int TypeB,int BondType,REAL *parms)
     parameters[0]=parms[0]*ENERGY_TO_KELVIN;
     parameters[1]=parms[1];
   }
-
+  
   if(Framework[CurrentSystem].NumberOfBondsDefinitions==0)
   {
     index=0;
@@ -6831,6 +6832,7 @@ void AddBondTypeToDefinitions(int TypeA,int TypeB,int BondType,REAL *parms)
     }
 
   }
+
 }
 
 void AddBendTypeToDefinitions(int TypeA,int TypeB,int TypeC,int BendType,REAL *parms)
@@ -8302,6 +8304,7 @@ int ReadFrameworkDefinition(void)
     ReadLine(line,1024,FilePtr); // skip line
     for(i=0;i<Framework[CurrentSystem].NumberOfBondsDefinitions;i++)
     {
+	  
       ReadLine(line,1024,FilePtr);
       arg_pointer=line;
       sscanf(line,"%s%s%s%n",TypeNameA,TypeNameB,buffer,&n);
@@ -8343,14 +8346,15 @@ int ReadFrameworkDefinition(void)
             {
               Framework[CurrentSystem].Bonds[CurrentFramework][index].A=A;
               Framework[CurrentSystem].Bonds[CurrentFramework][index].B=B;
-
+				
               Framework[CurrentSystem].BondType[CurrentFramework][index]=BondType;
-
+			  
               Framework[CurrentSystem].NumberOfBondsPerType[i]++;
 
               for(j=0;j<BondTypes[BondType].nr_args;j++)
+              {
                 Framework[CurrentSystem].BondArguments[CurrentFramework][index][j]=arguments[j];
-
+			  }
               // set to appropriate bond-distance
               switch(BondType)
               {
@@ -11243,6 +11247,194 @@ int IsDefinedImproperTorsion(int system,int f1,int A,int B,int C,int D)
   return FALSE;
 }
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+
+/*********************************************************************************************************
+ * Name       | AllocateList14atomsVDWandEwald    (Added by A. de Izarra)                          *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Create a 2D list indicating which atoms are 1-4 to assign scaling parameter for VDW and  *
+ *            | Ewald calculation. 																		 *
+ * Note       | Read the connectivity and establish 1-4 pair  											 *
+ *********************************************************************************************************/
+
+void AllocateList14atomsVDWandEwald(int system)
+{
+  int i,j,f1;
+
+  // First initialization of the size of tab for each framework.
+  Framework[system].pair14VDW_size=(int*)calloc(Framework[system].NumberOfFrameworks,sizeof(int));
+  Framework[system].pair14ChargeCharge_size=(int*)calloc(Framework[system].NumberOfFrameworks,sizeof(int));
+  
+
+  // Initialization of storage of intravalues for each 14 pair for VDW and Ewald for each framework.
+  Framework[system].scaling_pair14VDW=(REAL***)calloc(Framework[system].NumberOfFrameworks,sizeof(REAL**));
+  Framework[system].scaling_pair14ChargeCharge=(REAL***)calloc(Framework[system].NumberOfFrameworks,sizeof(REAL**));
+    
+  for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
+  {
+		Framework[system].scaling_pair14VDW[f1]=(REAL**)calloc(TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1],sizeof(REAL*));
+		Framework[system].scaling_pair14ChargeCharge[f1]=(REAL**)calloc(TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1],sizeof(REAL*)); 
+		
+		for(i=0;i<TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1];i++)
+		{
+			
+			Framework[system].scaling_pair14VDW[f1][i]=(REAL*)calloc(TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1],sizeof(REAL));
+			Framework[system].scaling_pair14ChargeCharge[f1][i]=(REAL*)calloc(TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1],sizeof(REAL));
+			 
+			for(j=0;j<TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1];j++)
+			{
+				Framework[system].scaling_pair14VDW[f1][i][j]=1.0;
+				Framework[system].scaling_pair14ChargeCharge[f1][i][j]=1.0;
+			}
+		
+		}
+
+		Framework[system].pair14VDW_size[f1] = TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1];			
+		Framework[system].pair14ChargeCharge_size[f1] = TotalNumberOfReplicaCells[system]*Framework[system].NumberOfAtoms[f1];	
+   }
+
+   
+  // VDW-VDW && electrostatic scaling 1-4 pairs.
+  // ============================================================
+  // set general 1-4 index for scaling 1-4 VDW parameter
+  // VDW is based on replica-method using 'GetReplicaNeighbour'
+  
+  int A,B,C,D,k,l,m;
+  
+  for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
+  {
+	
+    for(A=0;A<Framework[system].NumberOfAtoms[f1];A++)
+    {
+     
+      for(k=0;k<Framework[system].Connectivity[f1][A];k++)
+      {
+		
+        B=GetReplicaNeighbour(system,f1,A,k);
+	
+        for(l=0;l<Framework[system].Connectivity[f1][B];l++)
+        {
+          C=GetReplicaNeighbour(system,f1,B,l);
+
+          for(m=0;m<Framework[system].Connectivity[f1][C];m++)
+          {
+            D=GetReplicaNeighbour(system,f1,C,m);
+            if((D!=B)&&(D!=A))
+            {
+              // we now have 4 connected atoms: A, B, C, D
+              if(IsDefinedTorsion(system,f1,A,B,C,D))
+              {
+				Framework[system].scaling_pair14VDW[f1][A][D]= Framework[system].Intra14VDWScalingValue; 
+				Framework[system].scaling_pair14ChargeCharge[f1][A][D]= Framework[system].Intra14ChargeChargeScalingValue; 
+				
+                if(D<Framework[system].NumberOfAtoms[f1])
+                {
+				  Framework[system].scaling_pair14VDW[f1][D][A]= Framework[system].Intra14VDWScalingValue; ; 
+				  Framework[system].scaling_pair14ChargeCharge[f1][D][A]= Framework[system].Intra14ChargeChargeScalingValue; 
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  } 
+  
+
+
+  // Count the number of 1-4 pairs for each framework.
+  Framework[system].list14pair_size=(int*)calloc(Framework[system].NumberOfFrameworks,sizeof(int));
+  
+  // Count 1-4 pairs to retrieve number and index of 1-4 pairs.
+  // ==============================================================================================
+  for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
+  {
+	Framework[system].list14pair_size[f1] = 0;
+
+    for(A=0;A<Framework[system].NumberOfAtoms[f1];A++)
+    {
+      for(k=0;k<Framework[system].Connectivity[f1][A];k++)
+      {
+        B=GetNeighbour(system,f1,A,k);
+
+        for(l=0;l<Framework[system].Connectivity[f1][B];l++)
+        {
+          C=GetNeighbour(system,f1,B,l);
+          if((A!=C)&&(C!=B))
+          {
+
+            for(m=0;m<Framework[system].Connectivity[f1][C];m++)
+            {
+              D=GetNeighbour(system,f1,C,m);
+              if((D!=B)&&(D!=A)&&(D!=C))
+              {
+				
+                if(A<D && IsDefinedTorsion(system,f1,A,B,C,D) && (!BITVAL(Framework[CurrentSystem].ExclusionMatrix[f1][A][D],1)))
+                {		
+                  Framework[system].list14pair_size[f1]++;
+                } 
+              }
+            }
+          }
+        }
+      }
+    }
+  }	
+ 
+  // Store in a table all the 1-4 pair for ewald summation, for scaling parameter.
+  Framework[system].list14pair=(PAIR**)calloc(Framework[system].NumberOfFrameworks,sizeof(PAIR*));
+  for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
+  {
+	    Framework[system].list14pair[f1]=(PAIR*)calloc(Framework[system].list14pair_size[f1],sizeof(PAIR));
+	    
+	    for(i=0;i<Framework[system].list14pair_size[f1];i++)
+	    {
+			Framework[system].list14pair[f1][i].A=0;
+			Framework[system].list14pair[f1][i].B=0;
+		}
+  }  
+  
+  int count = 0;
+  
+  for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
+  {
+
+    for(A=0;A<Framework[system].NumberOfAtoms[f1];A++)
+    {
+      for(k=0;k<Framework[system].Connectivity[f1][A];k++)
+      {
+        B=GetNeighbour(system,f1,A,k);
+
+        for(l=0;l<Framework[system].Connectivity[f1][B];l++)
+        {
+          C=GetNeighbour(system,f1,B,l);
+          if((A!=C)&&(C!=B))
+          {
+
+            for(m=0;m<Framework[system].Connectivity[f1][C];m++)
+            {
+              D=GetNeighbour(system,f1,C,m);
+              if((D!=B)&&(D!=A)&&(D!=C))
+              {
+                if(A<D && IsDefinedTorsion(system,f1,A,B,C,D) && (!BITVAL(Framework[CurrentSystem].ExclusionMatrix[f1][A][D],1)))
+                {
+					
+					Framework[system].list14pair[f1][count].A=A;
+					Framework[system].list14pair[f1][count].B=D;	
+					count++;		
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }	
+  
+}
+//-------------------------------------------------------------------
+
 /*********************************************************************************************************
  * Name       | MakeExclusionMatrix                                                                      *
  * ----------------------------------------------------------------------------------------------------- *
@@ -11257,11 +11449,14 @@ int IsDefinedImproperTorsion(int system,int f1,int A,int B,int C,int D)
 
 void MakeExclusionMatrix(int system)
 {
+
+
   int i,j,k,l,m,f1;
   int A,B,C,D;
   int index1,index2;
   int largest_size;
 
+
   // allocate memory for the exclusion-matrix
   Framework[system].ExclusionMatrix=(char***)calloc(Framework[system].NumberOfFrameworks,sizeof(char**));
   for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
@@ -11330,9 +11525,9 @@ void MakeExclusionMatrix(int system)
         }
       }
     }
-  }
-
+  }	
 
+  
   // VDW-VDW
   // ==============================================================================================
   // set general 1-2, 1-3, 1-4 exclusions for VDW
@@ -11371,21 +11566,28 @@ void MakeExclusionMatrix(int system)
               SETBIT(Framework[system].ExclusionMatrix[f1][A][C],7);
               if(C<Framework[system].NumberOfAtoms[f1])
               {
-                SETBIT(Framework[system].ExclusionMatrix[f1][C][A],0);
+                SETBIT(Framework[system].ExclusionMatrix[f1][C][A],0);              
                 SETBIT(Framework[system].ExclusionMatrix[f1][C][A],7);
+
               }
             }
           }
 
           for(m=0;m<Framework[system].Connectivity[f1][C];m++)
           {
+			    
             D=GetReplicaNeighbour(system,f1,C,m);
             if((D!=B)&&(D!=A))
             {
-              // we now have 4 connected atoms: A, B, C, D
+			  // we now have 4 connected atoms: A, B, C, D
+			  // Le if n'est jamais vérifié car: RemoveTorsionNeighboursFromLongRangeInteraction no
+			  // toujours un Bit 0 donc VDW bien présente de par l'initialisation de ExclusionMatrix
+
               if(Remove14NeighboursFromVDWInteraction||(RemoveTorsionNeighboursFromLongRangeInteraction&&IsDefinedTorsion(system,f1,A,B,C,D)))
               {
+
                 SETBIT(Framework[system].ExclusionMatrix[f1][A][D],0);
+                
                 if(D<Framework[system].NumberOfAtoms[f1])
                   SETBIT(Framework[system].ExclusionMatrix[f1][D][A],0);
               }
@@ -11414,6 +11616,7 @@ void MakeExclusionMatrix(int system)
         if(Remove12NeighboursFromChargeChargeInteraction||(RemoveBondNeighboursFromLongRangeInteraction&&IsDefinedBond(system,f1,A,B)))
         {
           SETBIT(Framework[system].ExclusionMatrix[f1][A][B],1);
+          
           if(B<Framework[system].NumberOfAtoms[f1])
             SETBIT(Framework[system].ExclusionMatrix[f1][B][A],1);
         }
@@ -11435,11 +11638,11 @@ void MakeExclusionMatrix(int system)
           {
             D=GetReplicaNeighbour(system,f1,C,m);
             if((D!=B)&&(D!=A))
-            {
-              // we now have 4 connected atoms: A, B, C, D
+            {			
+			  // we now have 4 connected atoms: A, B, C, D
               if(Remove14NeighboursFromChargeChargeInteraction||(RemoveTorsionNeighboursFromLongRangeInteraction&&IsDefinedTorsion(system,f1,A,B,C,D)))
               {
-                SETBIT(Framework[system].ExclusionMatrix[f1][A][D],1);
+				 SETBIT(Framework[system].ExclusionMatrix[f1][A][D],1);
                 if(D<Framework[system].NumberOfAtoms[f1])
                   SETBIT(Framework[system].ExclusionMatrix[f1][D][A],1);
               }
@@ -11450,6 +11653,8 @@ void MakeExclusionMatrix(int system)
     }
   }
 
+
+
   // set general 1-2, 1-3, 1-4 exclusions for charge-charge exclusion-list
   // charge exclusion in Fourier-space is based on the unit-cell using 'GetNeighbour'
   for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
@@ -11465,6 +11670,7 @@ void MakeExclusionMatrix(int system)
         if(Remove12NeighboursFromChargeChargeInteraction||(RemoveBondNeighboursFromLongRangeInteraction&&IsDefinedBond(system,f1,A,B)))
         {
           SETBIT(Framework[system].ExclusionMatrix[f1][A][B],4);
+          
           if(B<Framework[system].NumberOfAtoms[f1])
             SETBIT(Framework[system].ExclusionMatrix[f1][B][A],4);
         }
@@ -13993,6 +14199,12 @@ void ReadRestartFramework(FILE *FilePtr)
       // rather then store the exclusion matrix, recompute it when all required information is read
       CurrentSystem=i;
       MakeExclusionMatrix(i);
+      // Add by Ambroise de Izarra
+      //-------------------------------------------------------------------
+      //AllocateList14atomsVDWandEwald(i);
+      //printInteractionIndexAtoms(i);
+      //-------------------------------------------------------------------
+      
     }
   }
 
@@ -14053,3 +14265,109 @@ void ReadRestartFramework(FILE *FilePtr)
   }
 
 }
+
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+/*********************************************************************************************************
+ * Name       | printInteractionIndexAtoms    (Added by A. de Izarra)                              	     *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | print a list of bonds, bends, torsions (dihedrals)	of a flexible framework				 *
+ * Note       | int system => index of the system.														 *
+ *********************************************************************************************************/
+void printInteractionIndexAtoms(int system)
+{
+	int f1,i,j,index;
+	
+	FILE *FilePtr;
+	char buffer[256];
+	
+	
+	for(f1=0;f1<Framework[system].NumberOfFrameworks;f1++)
+    {   
+		
+		
+		if(Framework[system].PrintInteractionIndex[f1]) 
+		{
+			if(f1 == 0) 
+			{
+				mkdir("PrintInteractionIndexAtoms",S_IRWXU);
+				sprintf(buffer,"PrintInteractionIndexAtoms/System_%d",system);
+				mkdir(buffer,S_IRWXU);
+			}
+			
+			  sprintf(buffer,"PrintInteractionIndexAtoms/System_%d/InteractionIndexAtoms_framework_%d.txt",system,f1);
+			  FilePtr=fopen(buffer,"w");
+			  
+			  if(FilePtr)
+			  {
+				  if(Framework[system].FrameworkModel==FLEXIBLE)
+				  {
+					    
+						//Output the bond index atoms.
+						
+						index = 0;
+						
+						fprintf(FilePtr,"[\tBonds\t]\n");
+						for(i=0;i<Framework[system].NumberOfBondsDefinitions;i++) //Nomber of different bond types
+						{
+							fprintf(FilePtr,"\t[\t%s\t%s\t]\n",PseudoAtoms[Framework[system].BondDefinitions[i].A].Name,PseudoAtoms[Framework[system].BondDefinitions[i].B].Name);
+							
+							for(j=0;j<Framework[system].NumberOfBondsPerType[i];j++) // In a given type, give the number of bond
+							{
+								fprintf(FilePtr,"\t\t%i\t%i\n",Framework[system].Bonds[f1][index].A,Framework[system].Bonds[f1][index].B);
+								index++;
+							}
+						}	
+	
+						
+						//Output the angle index atoms.
+						
+						index = 0;
+						
+						fprintf(FilePtr,"[\tangle\t]\n");
+						for(i=0;i<Framework[system].NumberOfBendDefinitions;i++) //Nomber of different bend types
+						{                                 
+							fprintf(FilePtr,"\t[\t%s\t%s\t%s\t]\n",PseudoAtoms[Framework[system].BendDefinitions[i].A].Name,PseudoAtoms[Framework[system].BendDefinitions[i].B].Name,PseudoAtoms[Framework[system].BendDefinitions[i].C].Name);
+							
+							for(j=0;j<Framework[system].NumberOfBendsPerType[i];j++) // In a given type, give the number of bend
+							{
+								fprintf(FilePtr,"\t\t%i\t%i\t%i\n",Framework[system].Bends[f1][index].A,Framework[system].Bends[f1][index].B,Framework[system].Bends[f1][index].C);
+								index++;
+							}
+						}
+						
+		
+						
+						//Output the dihedrals index atoms.
+						
+						index = 0;
+						
+						fprintf(FilePtr,"[\tdihedrals\t]\n");
+						for(i=0;i<Framework[system].NumberOfTorsionDefinitions;i++) //Nomber of different Torsion types
+						{                                   
+							fprintf(FilePtr,"\t[\t%s\t%s\t%s\t%s\t]\n",PseudoAtoms[Framework[system].TorsionDefinitions[i].A].Name,PseudoAtoms[Framework[system].TorsionDefinitions[i].B].Name,PseudoAtoms[Framework[system].TorsionDefinitions[i].C].Name,PseudoAtoms[Framework[system].TorsionDefinitions[i].D].Name);
+							
+							for(j=0;j<Framework[system].NumberOfTorsionsPerType[i];j++) // In a given type, give the number of Torsion 
+							{
+								fprintf(FilePtr,"\t\t%i\t%i\t%i\t%i\n",Framework[system].Torsions[f1][index].A,Framework[system].Torsions[f1][index].B,Framework[system].Torsions[f1][index].C,Framework[system].Torsions[f1][index].D);
+								index++;
+							}
+						}
+						
+					}
+			  }
+			  
+			  else
+			  {
+				printf(stderr,"Cannot open %s",buffer);
+				
+			  }
+			  
+			  fclose(FilePtr);
+		}
+	}
+	
+}
+
+	  
+//-------------------------------------------------------------------
diff --git a/src/framework.h b/src/framework.h
index 50de2f1..d3d42b0 100644
--- a/src/framework.h
+++ b/src/framework.h
@@ -202,6 +202,18 @@ typedef struct FrameworkComponent
   int **CellListHead;                        // the starting atom per cell
   int **CellList;                            // linked list of framework atoms
 
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  REAL ***scaling_pair14VDW;							// Store 14 atoms in the box for VDW.
+  REAL ***scaling_pair14ChargeCharge;                 // Store 14 atoms in the box for chargecharge.
+  PAIR **list14pair;							// Store 14 atom pairs for Ewald summation.
+   
+   
+  int *pair14VDW_size;			 
+  int *pair14ChargeCharge_size; 
+  int *list14pair_size;			
+  //-------------------------------------------------------------------
+
   REAL *FrameworkProbability;
   int FrameworkExclusion;
   int RemoveHydrogenDisorder;
@@ -253,6 +265,11 @@ typedef struct FrameworkComponent
 
   int ReadCIFAsCartesian;
 
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  int * PrintInteractionIndex;
+  //-------------------------------------------------------------------
+  
   char ***ExclusionMatrix;
 
   int **Connectivity;
@@ -490,6 +507,8 @@ void QuenchCoreSHellVelocities(void);
 int ClosestCrystallographicPosition(VECTOR pos);
 void ClosestCrystallographicPosition2(VECTOR pos,int *closest,REAL *minimum_distance);
 
+void AllocateList14atomsVDWandEwald(int system);
+
 void MakeExclusionMatrix(int system);
 void MakeExcludedInteractionLists(int system);
 
@@ -532,4 +551,8 @@ void WriteFrameworkDefinitionMOL(char *string);
 
 void PutNoiseOnFrameworkAtomicPositions(void);
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+void printInteractionIndexAtoms(int system);
+//-------------------------------------------------------------------
 #endif
diff --git a/src/input.c b/src/input.c
index c131c8c..485b6ce 100644
--- a/src/input.c
+++ b/src/input.c
@@ -161,6 +161,7 @@ void CheckConstraintInputCation(CATION_MOLECULE** cations,int molecule_nr,int at
 // more characters then the line are discarded
 char *ReadLine(char *buffer, size_t length, FILE *file)
 {
+	
   char *p;
   size_t last;
 
@@ -234,11 +235,19 @@ int ReadInput(char *input)
   int NumberOfCFBiasingFactors;
   REAL OverlapDistance;
   int CurrentReaction;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  int CurrentAlchReaction;
+  //-------------------------------------------------------------------
   int typeA,typeB;
   int atom1,atom2;
   int CFMoleculePresent=FALSE;
 
   CurrentReaction=0;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  CurrentAlchReaction=0;
+  //-------------------------------------------------------------------
   RXMCLambdaHistogramSize=21;
   MeasureLambdaBelow=10.0;
   RemoveFractionalMoleculesFromRestartFile=FALSE;
@@ -479,7 +488,11 @@ int ReadInput(char *input)
   ComputePrincipleMomentsOfInertia=FALSE;
 
   CFWangLandauEvery=5000;
-
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  RelaxationStepsAlchemicalTransformationMove = 5;
+  ChemicalPotentialAlchemical = 0.0;
+  //-------------------------------------------------------------------
   NumberOfHybridNVESteps=5;
   NumberOfHybridNPHSteps=5;
   NumberOfHybridNPHPRSteps=5;
@@ -543,6 +556,11 @@ int ReadInput(char *input)
   ProbabilityParallelMolFractionMove=0.0;
   ProbabilityGibbsVolumeChangeMove=0.0;
   ProbabilityHybridNVEMove=0.0;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  ProbabilityAlchemicalTransformationMove=0.0;
+  ProbabilityWidomOsmostatCalculationMove=0.0;
+  //-------------------------------------------------------------------
   ProbabilityHybridNPHMove=0.0;
   ProbabilityHybridNPHPRMove=0.0;
   ProbabilityFrameworkChangeMove=0.0;
@@ -640,7 +658,12 @@ int ReadInput(char *input)
   NumberOfSystems=0;
   NumberOfComponents=0;
   NumberOfReactions=0;
-
+  
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  NumberAlchemicalReactions=0;
+  //-------------------------------------------------------------------
+  
   // This loops through the string line-by-line, using the reentrant form of
   // `strtok` to be less ambiguous about the state of things
   tmp = strdup(input);
@@ -732,6 +755,7 @@ int ReadInput(char *input)
     if(strcasecmp("Reaction",keyword)==0) NumberOfReactions++;
     //-------------------------------------------------------------------------------------------------------------------------------------------------------
 
+
     // if restarted from a binary restart file we  can skip everything, and read
     // the full system status from that binary restart-file
     if(strcasecmp("ContinueAfterCrash",keyword)==0)
@@ -746,8 +770,29 @@ int ReadInput(char *input)
         if(ContinueAfterCrash) return 0;
       }
     }
+    
+   
+   // Added by Ambroise de Izarra
+   //------------------------------------------------------------------- 
+   if(strcasecmp("AlchemicalTransformation",keyword)==0) NumberAlchemicalReactions++;
+   
+   // store the index of salt ions.
+   if(NumberAlchemicalReactions>0)
+   {
+		SaltIndex								 =(int**)calloc(NumberAlchemicalReactions,sizeof(int*));
+		MultiplicitySalt			 			 =(int**)calloc(NumberAlchemicalReactions,sizeof(int*));
+		ChosenMoleculeAlchemicalTransformation   =(int**)calloc(NumberAlchemicalReactions,sizeof(int*));
+		NumberTransientMoities	       		 	 =(int*)calloc(NumberAlchemicalReactions,sizeof(int));
+		
+		for(i=0;i<NumberAlchemicalReactions;i++)
+		{
+			SaltIndex[i]=(int*)calloc(2,sizeof(int));
+			MultiplicitySalt[i]=(int*)calloc(2,sizeof(int));
+		}
+   }   
+   //-------------------------------------------------------------------
   }
-
+  
   // set units, either reduced or real units
   SetSimulationUnits();
 
@@ -986,13 +1031,13 @@ int ReadInput(char *input)
   {
     ReactantsStoichiometry[i]=(int*)calloc(NumberOfComponents,sizeof(int));
     ProductsStoichiometry[i]=(int*)calloc(NumberOfComponents,sizeof(int));
-
   }
 
   for(i=0;i<NumberOfSystems;i++)
     for(l=0;l<NumberOfReactions;l++)
       CFRXMCWangLandauScalingFactor[i][l]=0.01;
-
+      
+ 
   // second pass to get the number of frameworks per system
   CurrentSystem=0;
   CurrentComponent=0;
@@ -1410,7 +1455,7 @@ int ReadInput(char *input)
       Framework[i].ExcludedIntraBondDipoleBondDipole=(PAIR**)calloc(Framework[i].NumberOfFrameworks,sizeof(PAIR*));
 
       FrameworkFixedInitialization[i]=(int*)calloc(Framework[i].NumberOfFrameworks,sizeof(int));
-
+      
       NumberOfFixedFrameworkAtoms[i]=(int*)calloc(Framework[i].NumberOfFrameworks,sizeof(int));
       NumberOfFixedFrameworkAtomsX[i]=(int*)calloc(Framework[i].NumberOfFrameworks,sizeof(int));
       NumberOfFixedFrameworkAtomsY[i]=(int*)calloc(Framework[i].NumberOfFrameworks,sizeof(int));
@@ -1446,7 +1491,18 @@ int ReadInput(char *input)
       Framework[i].AnisotropicType=ANISOTROPIC_MID_POINT;
       Framework[i].ForceSpaceGroupDetection=FALSE;
       Framework[i].ReadCIFAsCartesian=FALSE;
-
+      
+      // Added by Ambroise de Izarra 
+      //-------------------------------------------------------------------
+      // Print Interaction index for bond, bend and dihedral analysis.
+      Framework[i].PrintInteractionIndex=(int*)calloc(Framework[i].NumberOfFrameworks,sizeof(int));
+      for(j=0;j<Framework[i].NumberOfFrameworks;j++)
+      {
+			Framework[i].PrintInteractionIndex[j]=FALSE;
+	  }
+      //-------------------------------------------------------------------
+      
+	  Framework[i].ReadCIFAsCartesian=FALSE;
       Framework[i].Intra14VDWScalingValue=1.0;
       Framework[i].Intra14ChargeChargeScalingValue=1.0;
     }
@@ -1479,6 +1535,10 @@ int ReadInput(char *input)
   // final pass, most memory is now already allocated
   CurrentComponent=0;
   CurrentReaction=0;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  CurrentAlchReaction=0;
+  //-------------------------------------------------------------------
   LineNumber=0;
   tmp = strdup(input);
   tokptr = 0;
@@ -2229,13 +2289,15 @@ int ReadInput(char *input)
       }
     }
 
-
+	
     //-----------------------------------------------------------------------------------------------------
     // CFC-RXMC : read reactions
     //-----------------------------------------------------------------------------------------------------
     if(strcasecmp("Reaction",keyword)==0)
     {
+	
       arg_pointer=arguments;
+      
       for(i=0;i<NumberOfComponents;i++)
       {
         sscanf(arg_pointer,"%d%n",&ReactantsStoichiometry[CurrentReaction][i],&n);
@@ -2249,6 +2311,28 @@ int ReadInput(char *input)
       CurrentReaction++;
     }
 
+	
+	// Added by Ambroise de Izarra
+	//-------------------------------------------------------------------
+    // Alchemical transformation : read cation and anion indexes.
+    if(strcasecmp("AlchemicalTransformation",keyword)==0)
+    {
+		
+      arg_pointer=arguments;
+
+	  // Read the index of the solvent in which salt must be introduced.
+	  sscanf(arg_pointer,"%d%n",&SolventIndex,&n);
+      arg_pointer+=n;
+	  // Read the index of the salt, to be appeared in the component section.
+      for(i=0;i<2;i++)
+      {	 
+        sscanf(arg_pointer,"%d%n",&SaltIndex[CurrentAlchReaction][i],&n);
+        arg_pointer+=n;
+      }
+	  
+      CurrentAlchReaction++;
+    }
+    //-------------------------------------------------------------------
 
     // read MD ensembles
     if(strcasecmp("Ensemble",keyword)==0)
@@ -2514,7 +2598,15 @@ int ReadInput(char *input)
     {
       if(strcasecmp("yes",firstargument)==0) Framework[CurrentSystem].ReadCIFAsCartesian=TRUE;
       if(strcasecmp("no",firstargument)==0) Framework[CurrentSystem].ReadCIFAsCartesian=FALSE;
+   }
+    // Added by Ambroise de Izarra
+    //-------------------------------------------------------------------
+    if(strcasecmp("PrintInteractionIndexAtoms",keyword)==0)
+    {
+      if(strcasecmp("yes",firstargument)==0) Framework[CurrentSystem].PrintInteractionIndex[CurrentFramework]=TRUE;
+      if(strcasecmp("no",firstargument)==0) Framework[CurrentSystem].PrintInteractionIndex[CurrentFramework]=FALSE;
     }
+    //-------------------------------------------------------------------
     if(strcasecmp("RestrictFrameworkAtomsToBox",keyword)==0)
     {
       if(strcasecmp("yes",firstargument)==0) Framework[CurrentSystem].RestrictFrameworkAtomsToBox=TRUE;
@@ -2782,6 +2874,14 @@ int ReadInput(char *input)
     if(strcasecmp("ReinsertionInPlaceProbability",keyword)==0) sscanf(arguments,"%lf",&Components[CurrentComponent].ProbabilityReinsertionInPlaceMove);
     if(strcasecmp("HybridMCMDMoveProbability",keyword)==0) sscanf(arguments,"%lf",&ProbabilityHybridNVEMove);
     if(strcasecmp("HybridNVEMoveProbability",keyword)==0) sscanf(arguments,"%lf",&ProbabilityHybridNVEMove);
+    // Added by Ambroise de Izarra
+    //-------------------------------------------------------------------
+    if(strcasecmp("ProbabilityAlchemicalTransformationMove",keyword)==0) sscanf(arguments,"%lf",&ProbabilityAlchemicalTransformationMove);
+    if(strcasecmp("LambdaStepsAlchemicalTransformationMove",keyword)==0) sscanf(arguments,"%d",&AlchReacLambda);
+    if(strcasecmp("ChemicalPotentialAlchemical",keyword)==0) sscanf(arguments,"%lf",&ChemicalPotentialAlchemical);
+    if(strcasecmp("RelaxationStepsAlchemicalTransformationMove",keyword)==0) sscanf(arguments,"%d",&RelaxationStepsAlchemicalTransformationMove);
+    if(strcasecmp("ProbabilityWidomOsmostatCalculationMove",keyword)==0) sscanf(arguments,"%lf",&ProbabilityWidomOsmostatCalculationMove);
+    //-------------------------------------------------------------------
     if(strcasecmp("HybridNPHMoveProbability",keyword)==0) sscanf(arguments,"%lf",&ProbabilityHybridNPHMove);
     if(strcasecmp("HybridNPHPRMoveProbability",keyword)==0) sscanf(arguments,"%lf",&ProbabilityHybridNPHPRMove);
     if(strcasecmp("NumberOfHybridNVESteps",keyword)==0) sscanf(arguments,"%d",&NumberOfHybridNVESteps);
@@ -6056,7 +6156,6 @@ int ReadInput(char *input)
       PrintFrameworkCationBondDipoleBondDipoleStatus=TRUE;
     }
 
-
     // create frameworks
     if(strcasecmp("FrameworkProbability",keyword)==0) sscanf(arguments,"%lf",&Framework[CurrentSystem].FrameworkProbability[CurrentFramework]);
     if(strcasecmp("FrameworkExclusion",keyword)==0)
@@ -6285,10 +6384,14 @@ int ReadInput(char *input)
         // read the flexible framework model definitions
         ReadFrameworkDefinition();
         ReadFrameworkSpecificDefinition();
-
+        
         MakeExclusionMatrix(CurrentSystem);
         MakeExcludedInteractionLists(CurrentSystem);
-
+        // Added by Ambroise de Izarra
+        //-------------------------------------------------------------------
+        AllocateList14atomsVDWandEwald(CurrentSystem);
+        printInteractionIndexAtoms(CurrentSystem);
+		//-------------------------------------------------------------------
         ReadBlockingPockets();
       }
 
@@ -6379,7 +6482,7 @@ int ReadInput(char *input)
   ReadForceFieldDefinitions();
   ComputeDummyInteractions();
   ComputePotentialShifts();
-
+  
   if(ChargeFromChargeEquilibration)
   {
     for(CurrentSystem=0;CurrentSystem<NumberOfSystems;CurrentSystem++)
@@ -7533,7 +7636,7 @@ int ReadInput(char *input)
 
   InitializeEwald(EwaldPrecision,EwaldAutomatic);
   AllocateEwaldMemory();
-
+  
   for(CurrentSystem=0;CurrentSystem<NumberOfSystems;CurrentSystem++)
   {
 
@@ -9709,6 +9812,7 @@ void ReadRestartFile(void)
 
 void ReadRestartFileOld(void)
 {
+	printf("READ_restart_old");
   int i;
   int NumberOfComponentsRead;
   int extra_framework_boolean;
@@ -9913,6 +10017,7 @@ void ReadRestartFileOld(void)
 
 void ReadBinaryRestartFiles(void)
 {
+  
   FILE *FilePtr;
   char buffer[1024];
 
@@ -9948,5 +10053,6 @@ void ReadBinaryRestartFiles(void)
     ContinueAfterCrash=FALSE;
     fprintf(stderr, "Crash set to false\n");
   }
+ 
 }
 
diff --git a/src/mc_moves.c b/src/mc_moves.c
index 4bcdd2d..8b9cdf6 100644
--- a/src/mc_moves.c
+++ b/src/mc_moves.c
@@ -42,6 +42,7 @@
 #include "framework_force.h"
 #include "framework.h"
 #include "simulation.h"
+#include "Alchemical_transformation.h"
 #include "cbmc.h"
 #include "ewald.h"
 #include "utils.h"
@@ -104,17 +105,19 @@ VECTOR **ReferenceElectricFieldAtTrialPosition;
 VECTOR **InducedDipoleAtTrialPosition;
 static VECTOR *cord;
 
-// delta energies
-static REAL UDeltaPolarization;
-static REAL *UHostPolarizationNew;
-static REAL *UAdsorbatePolarizationNew;
-static REAL *UCationPolarizationNew;
-static REAL *UPolarizationNew;
+// Modified by Ambroise de Izarra
+//------------------------------------------------------------------- 
+// switched from static to extern for use in alchemical transformation.
+REAL UDeltaPolarization;
+REAL *UHostPolarizationNew;
+REAL *UAdsorbatePolarizationNew;
+REAL *UCationPolarizationNew;
+REAL *UPolarizationNew;
 
-static REAL *UHostBackPolarizationNew;
-static REAL *UAdsorbateBackPolarizationNew;
-static REAL *UCationBackPolarizationNew;
-static REAL *UBackPolarizationNew;
+REAL *UHostBackPolarizationNew;
+REAL *UAdsorbateBackPolarizationNew;
+REAL *UCationBackPolarizationNew;
+//-------------------------------------------------------------------
 
 REAL *UHostVDWDelta;
 REAL *UHostChargeChargeRealDelta;
@@ -215,6 +218,14 @@ static REAL (**ReinsertionInPlaceAccepted)[2];
 static REAL ***IdentityChangeAttempts;
 static REAL (***IdentityChangeAccepted)[2];
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+REAL **AlchemicalChangeAttempts;
+REAL (**AlchemicalChangeAccepted)[2];
+
+REAL **WidomOsmostat;
+//-------------------------------------------------------------------
+
 static REAL **ParallelTemperingAttempts;
 static REAL **ParallelTemperingAccepted;
 
@@ -391,7 +402,6 @@ static REAL ***CFLambdaHistogram;
 static REAL ***RXMCLambdaHistogram;
 static int **LambdaRetraceMolecules;
 
-
 static REAL **ExchangeFractionalParticleAttempts;
 static REAL **ExchangeFractionalParticleAccepted;
 
@@ -554,7 +564,7 @@ void InitializeMCMovesStatisticsAllSystems(void)
         IdentityChangeAttempts[j][i][k]=0.0;
         IdentityChangeAccepted[j][i][k][0]=0.0;
         IdentityChangeAccepted[j][i][k][1]=0.0;
-
+		
         GibbsIdentityChangeAttempts[j][i][k]=0.0;
         GibbsIdentityChangeAccepted[j][i][k][0]=0.0;
         GibbsIdentityChangeAccepted[j][i][k][1]=0.0;
@@ -696,6 +706,20 @@ void InitializeMCMovesStatisticsAllSystems(void)
     HybridNPHPREndTemperatureFrameworkCount[j]=0.0;
     HybridNPHPREndTemperatureAdsorbateCount[j]=0.0;
     HybridNPHPREndTemperatureCationCount[j]=0.0;
+    
+    // Added by Ambroise de Izarra
+    //-------------------------------------------------------------------
+    for(k=0;k<NumberAlchemicalReactions;k++)
+    {
+		//(statistics for MC move alchemical transformation). 
+		AlchemicalChangeAttempts[j][k]=0.0;
+		AlchemicalChangeAccepted[j][k][0]=0.0;
+		AlchemicalChangeAccepted[j][k][1]=0.0;
+		// statistics for widom osmostat move.
+		WidomOsmostat[j][k]=0.0;
+	}
+	//-------------------------------------------------------------------
+	
   }
 }
 
@@ -1546,6 +1570,7 @@ int TranslationMoveAdsorbate(void)
   // calculate a random displacement
   vNew=2.0*RandomNumber()-1.0;
 
+
   // choose a possible displacement
   displacement=GetDisplacementVector(vNew);
 
@@ -1737,7 +1762,7 @@ int TranslationMoveAdsorbate(void)
       if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
         AcceptEwaldAdsorbateMove(0);
     }
-
+    
     nr_atoms=Adsorbates[CurrentSystem][CurrentAdsorbateMolecule].NumberOfAtoms;
     for(i=0;i<nr_atoms;i++)
     {
@@ -1746,7 +1771,6 @@ int TranslationMoveAdsorbate(void)
     }
 
     UpdateGroupCenterOfMassAdsorbate(CurrentAdsorbateMolecule);
-
     UTotal[CurrentSystem]+=DeltaU;
   }
   else
@@ -2892,7 +2916,6 @@ int RotationMoveAdsorbate(void)
     for(i=0;i<NumberOfCationMolecules[CurrentSystem];i++)
       UpdateGroupCenterOfMassCation(i);
 
-
   return 0;
 }
 
@@ -6205,89 +6228,1634 @@ void OptimizeTranslationInPlaneAcceptence(void)
     if(MaximumTranslationInPlane[CurrentSystem][i].y>CutOffVDW)
        MaximumTranslationInPlane[CurrentSystem][i].y=CutOffVDW;
 
-    vandr.z=ratio.z/TargetAccRatioTranslation;
-     if(vandr.z>1.5) vandr.z=1.5;
-    else if(vandr.z<0.5) vandr.z=0.5;
-    MaximumTranslationInPlane[CurrentSystem][i].z*=vandr.z;
-    if(MaximumTranslationInPlane[CurrentSystem][i].z<0.01)
-       MaximumTranslationInPlane[CurrentSystem][i].z=0.01;
-    if(MaximumTranslationInPlane[CurrentSystem][i].z>CutOffVDW)
-       MaximumTranslationInPlane[CurrentSystem][i].z=CutOffVDW;
+    vandr.z=ratio.z/TargetAccRatioTranslation;
+     if(vandr.z>1.5) vandr.z=1.5;
+    else if(vandr.z<0.5) vandr.z=0.5;
+    MaximumTranslationInPlane[CurrentSystem][i].z*=vandr.z;
+    if(MaximumTranslationInPlane[CurrentSystem][i].z<0.01)
+       MaximumTranslationInPlane[CurrentSystem][i].z=0.01;
+    if(MaximumTranslationInPlane[CurrentSystem][i].z>CutOffVDW)
+       MaximumTranslationInPlane[CurrentSystem][i].z=CutOffVDW;
+
+    TotalTranslationInPlaneAttempts[CurrentSystem][i].x+=TranslationInPlaneAttempts[CurrentSystem][i].x;
+    TotalTranslationInPlaneAccepted[CurrentSystem][i].x+=TranslationInPlaneAccepted[CurrentSystem][i].x;
+    TranslationInPlaneAttempts[CurrentSystem][i].x=TranslationInPlaneAccepted[CurrentSystem][i].x=0.0;
+
+    TotalTranslationInPlaneAttempts[CurrentSystem][i].y+=TranslationInPlaneAttempts[CurrentSystem][i].y;
+    TotalTranslationInPlaneAccepted[CurrentSystem][i].y+=TranslationInPlaneAccepted[CurrentSystem][i].y;
+    TranslationInPlaneAttempts[CurrentSystem][i].y=TranslationInPlaneAccepted[CurrentSystem][i].y=0.0;
+
+    TotalTranslationInPlaneAttempts[CurrentSystem][i].z+=TranslationInPlaneAttempts[CurrentSystem][i].z;
+    TotalTranslationInPlaneAccepted[CurrentSystem][i].z+=TranslationInPlaneAccepted[CurrentSystem][i].z;
+    TranslationInPlaneAttempts[CurrentSystem][i].z=TranslationInPlaneAccepted[CurrentSystem][i].z=0.0;
+  }
+}
+
+void PrintReinsertionInPlaneStatistics(FILE *FilePtr)
+{
+  int i,MoveUsed;
+
+  MoveUsed=FALSE;
+  for(i=0;i<NumberOfComponents;i++)
+  {
+    if(Components[i].FractionOfReinsertionInPlaneMove>0.0)
+    {
+      MoveUsed=TRUE;
+      break;
+    }
+  }
+
+  if(MoveUsed)
+  {
+    fprintf(FilePtr,"Performance of the reinsertion in plane move:\n");
+    fprintf(FilePtr,"=============================================\n");
+    for(i=0;i<NumberOfComponents;i++)
+    {
+      if(ReinsertionInPlaneAttempts[CurrentSystem][i]>0.0)
+      {
+        fprintf(FilePtr,"Component [%s] total tried: %lf succesfull growth: %lf (%lf [%%]) accepted: %lf (%lf [%%])\n",
+          Components[i].Name,
+          (double)ReinsertionInPlaneAttempts[CurrentSystem][i],
+          (double)ReinsertionInPlaneAccepted[CurrentSystem][i][0],
+          (double)(ReinsertionInPlaneAttempts[CurrentSystem][i]>(REAL)0.0?
+            100.0*ReinsertionInPlaneAccepted[CurrentSystem][i][0]/ReinsertionInPlaneAttempts[CurrentSystem][i]:(REAL)0.0),
+          (double)ReinsertionInPlaneAccepted[CurrentSystem][i][1],
+          (double)(ReinsertionInPlaneAttempts[CurrentSystem][i]>(REAL)0.0?
+            100.0*ReinsertionInPlaneAccepted[CurrentSystem][i][1]/ReinsertionInPlaneAttempts[CurrentSystem][i]:(REAL)0.0));
+      }
+      fprintf(FilePtr,"\ttotal        %lf %lf %lf\n",
+        (double)TotalTranslationInPlaneAttempts[CurrentSystem][i].x,
+        (double)TotalTranslationInPlaneAttempts[CurrentSystem][i].y,
+        (double)TotalTranslationInPlaneAttempts[CurrentSystem][i].z);
+      fprintf(FilePtr,"\tsuccesfull   %lf %lf %lf\n",
+        (double)TotalTranslationInPlaneAccepted[CurrentSystem][i].x,
+        (double)TotalTranslationInPlaneAccepted[CurrentSystem][i].y,
+        (double)TotalTranslationInPlaneAccepted[CurrentSystem][i].z);
+      fprintf(FilePtr,"\taccepted   %lf %lf %lf\n",
+        (double)(TotalTranslationInPlaneAttempts[CurrentSystem][i].x>(REAL)0.0?
+          TotalTranslationInPlaneAccepted[CurrentSystem][i].x/TotalTranslationInPlaneAttempts[CurrentSystem][i].x:(REAL)0.0),
+        (double)(TotalTranslationInPlaneAttempts[CurrentSystem][i].y>(REAL)0.0?
+          TotalTranslationInPlaneAccepted[CurrentSystem][i].y/TotalTranslationInPlaneAttempts[CurrentSystem][i].y:(REAL)0.0),
+        (double)(TotalTranslationInPlaneAttempts[CurrentSystem][i].z>(REAL)0.0?
+          TotalTranslationInPlaneAccepted[CurrentSystem][i].z/TotalTranslationInPlaneAttempts[CurrentSystem][i].z:(REAL)0.0));
+      fprintf(FilePtr,"\tdisplacement %lf %lf %lf\n",
+        (double)MaximumTranslationInPlane[CurrentSystem][i].x,
+        (double)MaximumTranslationInPlane[CurrentSystem][i].y,
+        (double)MaximumTranslationInPlane[CurrentSystem][i].z);
+      fprintf(FilePtr,"\n");
+    }
+    fprintf(FilePtr,"\n");
+  }
+  else
+   fprintf(FilePtr,"Reinsertion-in-plane move was OFF for all components\n\n");
+}
+
+
+// Added by Ambroise de Izarra
+
+/*********************************************************************************************************
+ * Name       | AlchemicalChangeAdsorbateMove     (Added by A. de Izarra)                                *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | NCMC move to perform alchemical transformation				                         	 *
+ * Parameters | No parameters																			 *
+ * Note		  |	The move is called semi-grand ensemble, but is also a special case of the Gibbs ensemble.*
+ *            | The move is described in Ross G et al., J. Phys. Chem. B 2018, 122, 5466-5486			 *
+ *********************************************************************************************************/
+// !!! Not used in this patch of RASPA  !!!//
+/*
+int AlchemicalChangeAdsorbateMove(void)
+{ 	
+  int i,j,f1,m;
+  int Type;
+  REAL Drift;
+  REAL ReferenceEnergy;
+  
+  // Declare the component index of old and new
+  int CurrentAlchemicalReaction;
+  int * OldComponent; 
+  int * NewComponent; 
+  int NumberOldComponent;
+  int NumberNewComponent;
+  
+  int NumberOfMolecules;
+  int InitialSaltIons;
+  int InitialCation;
+  int InitialAnion;
+  int InitialWater; 
+  
+  REAL ProbaInsertIons;
+  REAL Acceptance;
+  
+  REAL AlchemicalWork=0;
+  REAL Ubefore=0.0;
+  REAL Uafter=0.0;
+  
+  // We will store the energy of the system before performing the alchemical transformation
+  REAL StoredUHostBond,StoredUHostUreyBradley,StoredUHostBend,StoredUHostInversionBend;
+  REAL StoredUHostTorsion,StoredUHostImproperTorsion,StoredUHostBondBond;
+  REAL StoredUHostBendBend,StoredUHostBondBend,StoredUHostBondTorsion,StoredUHostBendTorsion;
+
+  REAL StoredUAdsorbateBond,StoredUAdsorbateUreyBradley,StoredUAdsorbateBend,StoredUAdsorbateInversionBend;
+  REAL StoredUAdsorbateTorsion,StoredUAdsorbateImproperTorsion,StoredUAdsorbateBondBond;
+  REAL StoredUAdsorbateBendBend,StoredUAdsorbateBondBend,StoredUAdsorbateBondTorsion,StoredUAdsorbateBendTorsion;
+  REAL StoredUAdsorbateIntraVDW,StoredUAdsorbateIntraChargeCharge;
+  REAL StoredUAdsorbateIntraChargeBondDipole,StoredUAdsorbateIntraBondDipoleBondDipole;
+
+  REAL StoredUCationBond,StoredUCationUreyBradley,StoredUCationBend,StoredUCationInversionBend;
+  REAL StoredUCationTorsion,StoredUCationImproperTorsion,StoredUCationBondBond;
+  REAL StoredUCationBendBend,StoredUCationBondBend,StoredUCationBondTorsion,StoredUCationBendTorsion;
+  REAL StoredUCationIntraVDW,StoredUCationIntraChargeCharge;
+  REAL StoredUCationIntraChargeBondDipole,StoredUCationIntraBondDipoleBondDipole;
+
+  REAL StoredUHostHost,StoredUHostHostVDW,StoredUHostHostChargeChargeReal;
+  REAL StoredUHostHostChargeBondDipoleReal,StoredUHostHostBondDipoleBondDipoleReal;
+  REAL StoredUHostHostChargeChargeFourier,StoredUHostHostCoulomb;
+  REAL StoredUHostHostChargeBondDipoleFourier,StoredUHostHostBondDipoleBondDipoleFourier;
+  REAL StoredUHostAdsorbate,StoredUHostAdsorbateVDW,StoredUHostAdsorbateChargeChargeReal;
+  REAL StoredUHostAdsorbateChargeBondDipoleReal,StoredUHostAdsorbateBondDipoleBondDipoleReal;
+  REAL StoredUHostAdsorbateChargeChargeFourier,StoredUHostAdsorbateCoulomb;
+  REAL StoredUHostAdsorbateChargeBondDipoleFourier,StoredUHostAdsorbateBondDipoleBondDipoleFourier;
+  REAL StoredUHostCation,StoredUHostCationVDW,StoredUHostCationChargeChargeReal;
+  REAL StoredUHostCationChargeBondDipoleReal,StoredUHostCationBondDipoleBondDipoleReal;
+  REAL StoredUHostCationChargeChargeFourier,StoredUHostCationCoulomb;
+  REAL StoredUHostCationChargeBondDipoleFourier,StoredUHostCationBondDipoleBondDipoleFourier;
+
+  REAL StoredUAdsorbateAdsorbate,StoredUAdsorbateAdsorbateVDW,StoredUAdsorbateAdsorbateChargeChargeReal;
+  REAL StoredUAdsorbateAdsorbateChargeBondDipoleReal,StoredUAdsorbateAdsorbateBondDipoleBondDipoleReal;
+  REAL StoredUAdsorbateAdsorbateChargeChargeFourier,StoredUAdsorbateAdsorbateCoulomb;
+  REAL StoredUAdsorbateAdsorbateChargeBondDipoleFourier,StoredUAdsorbateAdsorbateBondDipoleBondDipoleFourier;
+  REAL StoredUAdsorbateCation,StoredUAdsorbateCationVDW,StoredUAdsorbateCationChargeChargeReal;
+  REAL StoredUAdsorbateCationChargeBondDipoleReal,StoredUAdsorbateCationBondDipoleBondDipoleReal;
+  REAL StoredUAdsorbateCationChargeChargeFourier,StoredUAdsorbateCationCoulomb;
+  REAL StoredUAdsorbateCationChargeBondDipoleFourier,StoredUAdsorbateCationBondDipoleBondDipoleFourier;
+  REAL StoredUCationCation,StoredUCationCationVDW,StoredUCationCationChargeChargeReal;
+  REAL StoredUCationCationChargeBondDipoleReal,StoredUCationCationBondDipoleBondDipoleReal;
+  REAL StoredUCationCationChargeChargeFourier,StoredUCationCationCoulomb;
+  REAL StoredUCationCationChargeBondDipoleFourier,StoredUCationCationBondDipoleBondDipoleFourier;
+  REAL StoredUTotal,StoredUTailCorrection;
+
+  REAL UHostPolarizationStored,UAdsorbatePolarizationStored,UCationPolarizationStored;
+  REAL UHostBackPolarizationStored,UAdsorbateBackPolarizationStored,UCationBackPolarizationStored;
+
+  REAL StoredUKinetic,StoredUHostKinetic,StoredUAdsorbateTranslationalKinetic;
+  REAL StoredUCationTranslationalKinetic,StoredUAdsorbateRotationalKinetic;
+  REAL StoredUCationRotationalKinetic,StoredUAdsorbateKinetic,StoredUCationKinetic;
+
+  // Test if there is any molecules in the system, other than those belonging to the framework.
+  NumberOfMolecules=NumberOfAdsorbateMolecules[CurrentSystem];
+ 
+  if(NumberOfMolecules==0) return -1;
+ 
+  StoredUTotal=UTotal[CurrentSystem];
+  StoredUTailCorrection=UTailCorrection[CurrentSystem];
+
+  StoredUHostBond=UHostBond[CurrentSystem];
+  StoredUHostUreyBradley=UHostUreyBradley[CurrentSystem];
+  StoredUHostBend=UHostBend[CurrentSystem];
+  StoredUHostInversionBend=UHostInversionBend[CurrentSystem];
+  StoredUHostTorsion=UHostTorsion[CurrentSystem];
+  StoredUHostImproperTorsion=UHostImproperTorsion[CurrentSystem];
+  StoredUHostBondBond=UHostBondBond[CurrentSystem];
+  StoredUHostBendBend=UHostBendBend[CurrentSystem];
+  StoredUHostBondBend=UHostBondBend[CurrentSystem];
+  StoredUHostBondTorsion=UHostBondTorsion[CurrentSystem];
+  StoredUHostBendTorsion=UHostBendTorsion[CurrentSystem];
+
+  StoredUAdsorbateBond=UAdsorbateBond[CurrentSystem];
+  StoredUAdsorbateUreyBradley=UAdsorbateUreyBradley[CurrentSystem];
+  StoredUAdsorbateBend=UAdsorbateBend[CurrentSystem];
+  StoredUAdsorbateInversionBend=UAdsorbateInversionBend[CurrentSystem];
+  StoredUAdsorbateTorsion=UAdsorbateTorsion[CurrentSystem];
+  StoredUAdsorbateImproperTorsion=UAdsorbateImproperTorsion[CurrentSystem];
+  StoredUAdsorbateBondBond=UAdsorbateBondBond[CurrentSystem];
+  StoredUAdsorbateBendBend=UAdsorbateBendBend[CurrentSystem];
+  StoredUAdsorbateBondBend=UAdsorbateBondBend[CurrentSystem];
+  StoredUAdsorbateBondTorsion=UAdsorbateBondTorsion[CurrentSystem];
+  StoredUAdsorbateBendTorsion=UAdsorbateBendTorsion[CurrentSystem];
+  StoredUAdsorbateIntraVDW=UAdsorbateIntraVDW[CurrentSystem];
+  StoredUAdsorbateIntraChargeCharge=UAdsorbateIntraChargeCharge[CurrentSystem];
+  StoredUAdsorbateIntraChargeBondDipole=UAdsorbateIntraChargeBondDipole[CurrentSystem];
+  StoredUAdsorbateIntraBondDipoleBondDipole=UAdsorbateIntraBondDipoleBondDipole[CurrentSystem];
+
+  StoredUCationBond=UCationBond[CurrentSystem];
+  StoredUCationUreyBradley=UCationUreyBradley[CurrentSystem];
+  StoredUCationBend=UCationBend[CurrentSystem];
+  StoredUCationInversionBend=UCationInversionBend[CurrentSystem];
+  StoredUCationTorsion=UCationTorsion[CurrentSystem];
+  StoredUCationImproperTorsion=UCationImproperTorsion[CurrentSystem];
+  StoredUCationBondBond=UCationBondBond[CurrentSystem];
+  StoredUCationBendBend=UCationBendBend[CurrentSystem];
+  StoredUCationBondBend=UCationBondBend[CurrentSystem];
+  StoredUCationBondTorsion=UCationBondTorsion[CurrentSystem];
+  StoredUCationBendTorsion=UCationBendTorsion[CurrentSystem];
+  StoredUCationIntraVDW=UCationIntraVDW[CurrentSystem];
+  StoredUCationIntraChargeCharge=UCationIntraChargeCharge[CurrentSystem];
+  StoredUCationIntraChargeBondDipole=UCationIntraChargeBondDipole[CurrentSystem];
+  StoredUCationIntraBondDipoleBondDipole=UCationIntraBondDipoleBondDipole[CurrentSystem];
+
+  StoredUHostHost=UHostHost[CurrentSystem];
+  StoredUHostHostVDW=UHostHostVDW[CurrentSystem];
+  StoredUHostHostChargeChargeReal=UHostHostChargeChargeReal[CurrentSystem];
+  StoredUHostHostChargeChargeFourier=UHostHostChargeChargeFourier[CurrentSystem];
+  StoredUHostHostChargeBondDipoleReal=UHostHostChargeBondDipoleReal[CurrentSystem];
+  StoredUHostHostChargeBondDipoleFourier=UHostHostChargeBondDipoleFourier[CurrentSystem];
+  StoredUHostHostBondDipoleBondDipoleReal=UHostHostBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUHostHostBondDipoleBondDipoleFourier=UHostHostBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUHostHostCoulomb=UHostHostCoulomb[CurrentSystem];
+
+  StoredUHostAdsorbate=UHostAdsorbate[CurrentSystem];
+  StoredUHostAdsorbateVDW=UHostAdsorbateVDW[CurrentSystem];
+  StoredUHostAdsorbateChargeChargeReal=UHostAdsorbateChargeChargeReal[CurrentSystem];
+  StoredUHostAdsorbateChargeBondDipoleReal=UHostAdsorbateChargeBondDipoleReal[CurrentSystem];
+  StoredUHostAdsorbateBondDipoleBondDipoleReal=UHostAdsorbateBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUHostAdsorbateChargeChargeFourier=UHostAdsorbateChargeChargeFourier[CurrentSystem];
+  StoredUHostAdsorbateChargeBondDipoleFourier=UHostAdsorbateChargeBondDipoleFourier[CurrentSystem];
+  StoredUHostAdsorbateBondDipoleBondDipoleFourier=UHostAdsorbateBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUHostAdsorbateCoulomb=UHostAdsorbateCoulomb[CurrentSystem];
+
+  StoredUHostCation=UHostCation[CurrentSystem];
+  StoredUHostCationVDW=UHostCationVDW[CurrentSystem];
+  StoredUHostCationChargeChargeReal=UHostCationChargeChargeReal[CurrentSystem];
+  StoredUHostCationChargeBondDipoleReal=UHostCationChargeBondDipoleReal[CurrentSystem];
+  StoredUHostCationBondDipoleBondDipoleReal=UHostCationBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUHostCationChargeChargeFourier=UHostCationChargeChargeFourier[CurrentSystem];
+  StoredUHostCationChargeBondDipoleFourier=UHostCationChargeBondDipoleFourier[CurrentSystem];
+  StoredUHostCationBondDipoleBondDipoleFourier=UHostCationBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUHostCationCoulomb=UHostCationCoulomb[CurrentSystem];
+
+  StoredUAdsorbateAdsorbate=UAdsorbateAdsorbate[CurrentSystem];
+  StoredUAdsorbateAdsorbateVDW=UAdsorbateAdsorbateVDW[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeChargeReal=UAdsorbateAdsorbateChargeChargeReal[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeBondDipoleReal=UAdsorbateAdsorbateChargeBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateAdsorbateBondDipoleBondDipoleReal=UAdsorbateAdsorbateBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeChargeFourier=UAdsorbateAdsorbateChargeChargeFourier[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeBondDipoleFourier=UAdsorbateAdsorbateChargeBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateAdsorbateBondDipoleBondDipoleFourier=UAdsorbateAdsorbateBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateAdsorbateCoulomb=UAdsorbateAdsorbateCoulomb[CurrentSystem];
+
+  StoredUAdsorbateCation=UAdsorbateCation[CurrentSystem];
+  StoredUAdsorbateCationVDW=UAdsorbateCationVDW[CurrentSystem];
+  StoredUAdsorbateCationChargeChargeReal=UAdsorbateCationChargeChargeReal[CurrentSystem];
+  StoredUAdsorbateCationChargeBondDipoleReal=UAdsorbateCationChargeBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateCationBondDipoleBondDipoleReal=UAdsorbateCationBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateCationChargeChargeFourier=UAdsorbateCationChargeChargeFourier[CurrentSystem];
+  StoredUAdsorbateCationChargeBondDipoleFourier=UAdsorbateCationChargeBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateCationBondDipoleBondDipoleFourier=UAdsorbateCationBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateCationCoulomb=UAdsorbateCationCoulomb[CurrentSystem];
+
+  StoredUCationCation=UCationCation[CurrentSystem];
+  StoredUCationCationVDW=UCationCationVDW[CurrentSystem];
+  StoredUCationCationChargeChargeReal=UCationCationChargeChargeReal[CurrentSystem];
+  StoredUCationCationChargeBondDipoleReal=UCationCationChargeBondDipoleReal[CurrentSystem];
+  StoredUCationCationBondDipoleBondDipoleReal=UCationCationBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUCationCationChargeChargeFourier=UCationCationChargeChargeFourier[CurrentSystem];
+  StoredUCationCationChargeBondDipoleFourier=UCationCationChargeBondDipoleFourier[CurrentSystem];
+  StoredUCationCationBondDipoleBondDipoleFourier=UCationCationBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUCationCationCoulomb=UCationCationCoulomb[CurrentSystem];
+
+  UHostPolarizationStored=UHostPolarization[CurrentSystem];
+  UAdsorbatePolarizationStored=UAdsorbatePolarization[CurrentSystem];
+  UCationPolarizationStored=UCationPolarization[CurrentSystem];
+
+  UHostBackPolarizationStored=UHostBackPolarization[CurrentSystem];
+  UAdsorbateBackPolarizationStored=UAdsorbateBackPolarization[CurrentSystem];
+  UCationBackPolarizationStored=UCationBackPolarization[CurrentSystem];
+  
+  // Store the degrees of freedom of the system.
+  DegreesOfFreedomReferenceAdsorbates = DegreesOfFreedomAdsorbates[CurrentSystem];
+  DegreesOfFreedomReferenceTranslation = DegreesOfFreedomTranslation[CurrentSystem];
+  DegreesOfFreedomReferenceTranslationalAdsorbates = DegreesOfFreedomTranslationalAdsorbates[CurrentSystem];
+  DegreesOfFreedomReference = DegreesOfFreedom[CurrentSystem];
+  							
+  DegreesOfFreedomReferenceRotation = DegreesOfFreedomRotation[CurrentSystem];
+  DegreesOfFreedomReferenceAdsorbates = DegreesOfFreedomAdsorbates[CurrentSystem];
+  DegreesOfFreedomReferenceRotationalAdsorbates = DegreesOfFreedomRotationalAdsorbates[CurrentSystem];
+  
+  
+  // store the positions of the framework
+  for(f1=0;f1<Framework[CurrentSystem].NumberOfFrameworks;f1++)
+    for(i=0;i<Framework[CurrentSystem].NumberOfAtoms[f1];i++)
+      Framework[CurrentSystem].Atoms[f1][i].ReferencePosition=Framework[CurrentSystem].Atoms[f1][i].Position;
+  
+  // Store the NumberOfPseudoAtom pointer.
+  NumberOfPseudoAtomsReferenceTypeNew=(int*)calloc(NumberOfPseudoAtoms,sizeof(int));
+  NumberOfPseudoAtomsReferenceTypeOld=(int*)calloc(NumberOfPseudoAtoms,sizeof(int));
+  NumberOfPseudoAtomsReferenceType=(int**)calloc(NumberOfSystems,sizeof(int*));
+	
+  for(i=0;i<NumberOfSystems;i++)
+  {
+	  NumberOfPseudoAtomsReferenceType[i]=(int*)calloc(NumberOfPseudoAtoms,sizeof(int));
+  }
+  
+  for(i=0;i<NumberOfPseudoAtoms;i++)
+  {
+	  NumberOfPseudoAtomsReferenceTypeNew[i]=0;
+	  NumberOfPseudoAtomsReferenceTypeOld[i]=0;
+	  NumberOfPseudoAtomsReferenceType[CurrentSystem][i]=NumberOfPseudoAtomsType[CurrentSystem][i];
+  }
+
+  // store the structure-factors for the Ewald-summations
+  if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+    SaveCurrentEwaldStructureFactors(0,CurrentSystem);
+    
+  if (NumberAlchemicalReactions<=0) return 0;
+
+  //CurrentAlchemicalReaction=(int)(RandomNumber()*NumberAlchemicalReactions);
+  CurrentAlchemicalReaction=0;
+  
+  InitialSaltIons = Components[SaltIndex[CurrentAlchemicalReaction][0]].NumberOfMolecules[CurrentSystem]+
+					Components[SaltIndex[CurrentAlchemicalReaction][1]].NumberOfMolecules[CurrentSystem];
+  
+  InitialCation   = Components[SaltIndex[CurrentAlchemicalReaction][0]].NumberOfMolecules[CurrentSystem];
+  InitialAnion	  = Components[SaltIndex[CurrentAlchemicalReaction][1]].NumberOfMolecules[CurrentSystem];
+  InitialWater    =	Components[SolventIndex].NumberOfMolecules[CurrentSystem];
+  
+  
+  
+  if(InitialSaltIons == 0)
+  {
+		OldComponent = (int*)calloc(1,sizeof(int)); // This is water
+		NewComponent = (int*)calloc(2,sizeof(int)); // This is the salt.
+		
+		OldComponent[0] = SolventIndex;
+		
+		NewComponent[0] = SaltIndex[CurrentAlchemicalReaction][0];
+		NewComponent[1] = SaltIndex[CurrentAlchemicalReaction][1];
+		
+		NumberOldComponent = 1;
+		NumberNewComponent = 2;
+		
+		// If the number of water is inferior to the number of transient, return 0;
+		if(InitialWater<NumberTransientMoities[CurrentAlchemicalReaction]) return 0;  
+  }
+  else
+  {
+		if(InitialWater == 0)
+		{
+			// We choose to remove salt and insert water
+			OldComponent = (int*)calloc(2,sizeof(int)); // This is the salt
+			NewComponent = (int*)calloc(1,sizeof(int)); // This is water.
+			
+			OldComponent[0] = SaltIndex[CurrentAlchemicalReaction][0];
+			OldComponent[1] = SaltIndex[CurrentAlchemicalReaction][1];
+			
+			NewComponent[0] = SolventIndex;  
+			
+			NumberOldComponent = 2;
+			NumberNewComponent = 1;
+		}	
+		else
+		{
+			  ProbaInsertIons = RandomNumber();
+		  
+			  if(ProbaInsertIons<0.5)
+			  {
+				// Remove water and insert ions
+				OldComponent = (int*)calloc(1,sizeof(int)); // This is water
+				NewComponent = (int*)calloc(2,sizeof(int)); // This is the salt.
+				
+				OldComponent[0] = SolventIndex;
+				
+				NewComponent[0] = SaltIndex[CurrentAlchemicalReaction][0];
+				NewComponent[1] = SaltIndex[CurrentAlchemicalReaction][1];
+				
+				NumberOldComponent = 1;
+				NumberNewComponent = 2;
+				
+				// If the number of water is inferior to the number of transient, return 0;
+				if(InitialWater<NumberTransientMoities[CurrentAlchemicalReaction]) return 0;
+			  }
+			  else
+			  {
+				// We choose to remove salt and insert water
+				OldComponent = (int*)calloc(2,sizeof(int)); // This is the salt
+				NewComponent = (int*)calloc(1,sizeof(int)); // This is water.
+				
+				OldComponent[0] = SaltIndex[CurrentAlchemicalReaction][0];
+				OldComponent[1] = SaltIndex[CurrentAlchemicalReaction][1];
+				
+				NewComponent[0] = SolventIndex;  
+				
+				NumberOldComponent = 2;
+				NumberNewComponent = 1;
+			  }
+		}	
+  }
+  
+  // Select random particules.
+  SelectRandomMoleculeAlchemicalTransformation(OldComponent, NumberOldComponent, CurrentAlchemicalReaction);
+
+  // Extra memory for the new 2 transient components
+  AddExtraPseudoAtoms();
+  AllocateTransientComponentMemory();
+  ReallocateMemoryParameterTab();
+
+  // Store position of Chosen moities, before removing the chosen moities from the old system.
+  StoreChosenMoitiesCoordinates(NumberOldComponent);
+  
+  // Set up the mass of the new transient, according to the choice of components
+  InitializeMassTransientMoities(NumberOldComponent);
+  InitializeVDWTransientMoities(NumberOldComponent);
+  InitializeChargeTransientMoities(NumberOldComponent);
+  
+  // Delete chosen adsorbates and add intial transient adsorbates
+  DeleteChosenMoities();
+  
+  // store the positions of the Adsorbates
+  for(m=0;m<NumberOfAdsorbateMolecules[CurrentSystem];m++)
+  {
+    Type=Adsorbates[CurrentSystem][m].Type;
+    for(i=0;i<Components[Type].NumberOfGroups;i++)
+      Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition=Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassPosition;
+    for(i=0;i<Adsorbates[CurrentSystem][m].NumberOfAtoms;i++)
+    {
+      Adsorbates[CurrentSystem][m].Atoms[i].ReferencePosition=Adsorbates[CurrentSystem][m].Atoms[i].Position;
+    }
+  }
+
+  // store the positions of the cation.
+  for(m=0;m<NumberOfCationMolecules[CurrentSystem];m++)
+  {
+    Type=Cations[CurrentSystem][m].Type;
+    for(i=0;i<Components[Type].NumberOfGroups;i++)
+      Cations[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition=Cations[CurrentSystem][m].Groups[i].CenterOfMassPosition;
+    for(i=0;i<Cations[CurrentSystem][m].NumberOfAtoms;i++)
+      Cations[CurrentSystem][m].Atoms[i].ReferencePosition=Cations[CurrentSystem][m].Atoms[i].Position;
+  }
+  
+  MakeInitialTransient(NumberOldComponent);
+  
+  Ensemble[CurrentSystem]=NVE;
+  
+  // register an attempt to change the 'Old'-components to the 'New'-components.
+  AlchemicalChangeAttempts[CurrentSystem][CurrentAlchemicalReaction]+=1.0;	
+
+  for(i=1;i<=AlchReacLambda;i++)
+  {	  
+	// get the energy before perturbation at i^th step.
+	if(i>0)Ubefore = UTotal[CurrentSystem];
+
+	// interpolate non-bonded parameters.
+	UpdateMixingRuleVDWInterpolationAlchemicalTransformation(NumberOldComponent, Lambda[i]);  
+	UpdateChargeInterpolationAlchemicalTransformation(NumberOldComponent, Lambda[i]);
+	  
+	// Then prepare for NVE simulation.
+    for(j=0;j<NumberOfAdsorbateMolecules[CurrentSystem];j++)
+		InitializeVelocityAdsorbate(j);
+	
+	for(j=0;j<NumberOfCationMolecules[CurrentSystem];j++)
+		InitializeVelocityCation(j);
+
+	if(Framework[CurrentSystem].FrameworkModel==FLEXIBLE)
+		InitializeFrameworkVelocities();
+
+	InitializeForces();
+	
+	// Catch energy after interpolation
+    if(i>0)Uafter=UTotal[CurrentSystem];
+    
+	// Save the energy before the transformation move.
+	if(i>0) AlchemicalWork += Uafter - Ubefore;
+
+	StoredUKinetic=UKinetic[CurrentSystem];
+	StoredUHostKinetic=UHostKinetic[CurrentSystem];
+	StoredUAdsorbateTranslationalKinetic=UAdsorbateTranslationalKinetic[CurrentSystem];
+	StoredUCationTranslationalKinetic=UCationTranslationalKinetic[CurrentSystem];
+	StoredUAdsorbateRotationalKinetic=UAdsorbateRotationalKinetic[CurrentSystem];
+	StoredUCationRotationalKinetic=UCationRotationalKinetic[CurrentSystem];
+	StoredUAdsorbateKinetic=UAdsorbateKinetic[CurrentSystem];
+	StoredUCationKinetic=UCationKinetic[CurrentSystem];
+	
+	// register the starting temperatures
+    if(DegreesOfFreedom[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperature[CurrentSystem]+=2.0*StoredUKinetic/(K_B*DegreesOfFreedom[CurrentSystem]);
+      HybridNVEAlchStartTemperatureCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomTranslation[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTranslationalTemperature[CurrentSystem]+=2.0*(StoredUHostKinetic+
+         StoredUAdsorbateTranslationalKinetic+StoredUCationTranslationalKinetic)/
+                                                (K_B*DegreesOfFreedomTranslation[CurrentSystem]);
+      HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomRotation[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartRotationalTemperature[CurrentSystem]+=2.0*(StoredUAdsorbateRotationalKinetic+
+            StoredUCationRotationalKinetic)/(K_B*DegreesOfFreedomRotation[CurrentSystem]);
+      HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomFramework[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureFramework[CurrentSystem]+=2.0*StoredUHostKinetic/(K_B*DegreesOfFreedomFramework[CurrentSystem]);
+      HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomAdsorbates[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureAdsorbate[CurrentSystem]+=2.0*StoredUAdsorbateKinetic/(K_B*DegreesOfFreedomAdsorbates[CurrentSystem]);
+      HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]+=1.0;
+    }
+
+    if(DegreesOfFreedomCations[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureCation[CurrentSystem]+=2.0*StoredUCationKinetic/(K_B*DegreesOfFreedomCations[CurrentSystem]);
+      HybridNVEAlchStartTemperatureCationCount[CurrentSystem]+=1.0;
+    }
+
+    ReferenceEnergy=ConservedEnergy[CurrentSystem];
+    Drift=0.0;
+ 
+    // integrated the system 'NumberOfHybridNVESteps' steps
+	for(j=0;j<RelaxationStepsAlchemicalTransformationMove;j++)
+	{
+		// evolve the system a full time-step
+		Integration();
+
+		// update the drift in the energy
+		Drift+=fabs((ConservedEnergy[CurrentSystem]-ReferenceEnergy)/ReferenceEnergy);
+	}
+  }
+
+  // Calculate acceptance depending on water of ions has been chosen.
+  if(NumberOldComponent==1)
+  {
+	// water->ions 
+    
+    REAL RatioSpecies=1.00;
+  
+	for(int i=0;i<=(MultiplicitySalt[CurrentAlchemicalReaction][0]+MultiplicitySalt[CurrentAlchemicalReaction][1]-1);i++)
+		RatioSpecies *= (InitialWater-i);
+	
+	for(int i=1;i<=MultiplicitySalt[CurrentAlchemicalReaction][0];i++)	 
+		RatioSpecies *= 1.0/(InitialCation+i);
+
+	for(int i=1;i<=MultiplicitySalt[CurrentAlchemicalReaction][1];i++)
+		RatioSpecies *= 1.0/(InitialAnion+i);
+      
+	Acceptance = RatioSpecies * exp(Beta[CurrentSystem]*(-AlchemicalWork+ChemicalPotentialAlchemical));
+  }
+  else
+  { 
+	// ions->water   
+
+    REAL RatioSpecies=1.00;
+    
+    for(int i=0;i<=MultiplicitySalt[CurrentAlchemicalReaction][0]-1;i++)	  
+		RatioSpecies *= (InitialCation-i);
+	
+	for(int i=0;i<=MultiplicitySalt[CurrentAlchemicalReaction][1]-1;i++)
+		RatioSpecies *= (InitialAnion-i);
+  
+	for(int i=1;i<=(MultiplicitySalt[CurrentAlchemicalReaction][0]+MultiplicitySalt[CurrentAlchemicalReaction][1]);i++)
+		RatioSpecies *= 1.0/(InitialWater+i);
+
+	Acceptance = RatioSpecies * exp(Beta[CurrentSystem]*(-AlchemicalWork-ChemicalPotentialAlchemical));
+  }
+  
+
+  //Manage acceptation or rejection of the step.
+  if(RandomNumber() < Acceptance)
+  {  
+	   if(NumberOldComponent==1)
+			AlchemicalChangeAccepted[CurrentSystem][CurrentAlchemicalReaction][0]+=1.0;
+	   else
+		    AlchemicalChangeAccepted[CurrentSystem][CurrentAlchemicalReaction][1]+=1.0;
+
+		// register the end temperatures
+		HybridNVEAlchDrift[CurrentSystem]+=Drift;
+		HybridNVEAlchDriftCount[CurrentSystem]+=1.0;
+		
+		if(DegreesOfFreedom[CurrentSystem]>0)
+		{
+			HybridNVEAlchEndTemperature[CurrentSystem]+=2.0*UKinetic[CurrentSystem]/(K_B*DegreesOfFreedom[CurrentSystem]);
+			HybridNVEAlchEndTemperatureCount[CurrentSystem]+=1.0;
+		}
+		
+		if(DegreesOfFreedomTranslation[CurrentSystem]>0)
+		{
+			HybridNVEAlchEndTranslationalTemperature[CurrentSystem]+=2.0*(UHostKinetic[CurrentSystem]+
+				UAdsorbateTranslationalKinetic[CurrentSystem]+UCationTranslationalKinetic[CurrentSystem])/
+													(K_B*DegreesOfFreedomTranslation[CurrentSystem]);
+			HybridNVEAlchEndTemperatureTranslationCount[CurrentSystem]+=1.0;
+		}
+		
+		if(DegreesOfFreedomRotation[CurrentSystem]>0)
+		{
+			HybridNVEAlchEndRotationalTemperature[CurrentSystem]+=2.0*(UAdsorbateRotationalKinetic[CurrentSystem]+
+					UCationRotationalKinetic[CurrentSystem])/(K_B*DegreesOfFreedomRotation[CurrentSystem]);
+			HybridNVEAlchEndTemperatureRotationCount[CurrentSystem]+=1.0;
+		}
+		
+		if(DegreesOfFreedomFramework[CurrentSystem]>0)
+		{
+			HybridNVEAlchEndTemperatureFramework[CurrentSystem]+=2.0*UHostKinetic[CurrentSystem]/(K_B*DegreesOfFreedomFramework[CurrentSystem]);
+			HybridNVEAlchEndTemperatureFrameworkCount[CurrentSystem]+=1.0;
+		}
+		
+		if(DegreesOfFreedomAdsorbates[CurrentSystem]>0)
+		{
+			HybridNVEAlchEndTemperatureAdsorbate[CurrentSystem]+=2.0*UAdsorbateKinetic[CurrentSystem]/(K_B*DegreesOfFreedomAdsorbates[CurrentSystem]);
+			HybridNVEAlchEndTemperatureAdsorbateCount[CurrentSystem]+=1.0;
+		}
+		
+		if(DegreesOfFreedomCations[CurrentSystem]>0)
+		{
+			HybridNVEAlchEndTemperatureCation[CurrentSystem]+=2.0*UCationKinetic[CurrentSystem]/(K_B*DegreesOfFreedomCations[CurrentSystem]);
+			HybridNVEAlchEndTemperatureCationCount[CurrentSystem]+=1.0;
+		}
+		
+		// register the changes in the stored structure factors
+		if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+			PrecomputeTotalEwaldContributions();
+		
+		// If water->ions, update the mass to the mass of the ions.
+		EndMassTransientMoities(NumberOldComponent);
+		
+		// Put the transient moities into the appropriate components.	
+		SwitchMoietiestoRegularComponents(NumberNewComponent);		
+  }
+  else
+  {	  	  
+	  // restore all the energy to the Old state
+	  UHostBond[CurrentSystem]=StoredUHostBond;
+      UHostUreyBradley[CurrentSystem]=StoredUHostUreyBradley;
+      UHostBend[CurrentSystem]=StoredUHostBend;
+      UHostInversionBend[CurrentSystem]=StoredUHostInversionBend;
+      UHostTorsion[CurrentSystem]=StoredUHostTorsion;
+      UHostImproperTorsion[CurrentSystem]=StoredUHostImproperTorsion;
+      UHostBondBond[CurrentSystem]=StoredUHostBondBond;
+      UHostBendBend[CurrentSystem]=StoredUHostBendBend;
+      UHostBondBend[CurrentSystem]=StoredUHostBondBend;
+      UHostBondTorsion[CurrentSystem]=StoredUHostBondTorsion;
+      UHostBendTorsion[CurrentSystem]=StoredUHostBendTorsion;
+
+      UAdsorbateBond[CurrentSystem]=StoredUAdsorbateBond;
+      UAdsorbateUreyBradley[CurrentSystem]=StoredUAdsorbateUreyBradley;
+      UAdsorbateBend[CurrentSystem]=StoredUAdsorbateBend;
+      UAdsorbateInversionBend[CurrentSystem]=StoredUAdsorbateInversionBend;
+      UAdsorbateTorsion[CurrentSystem]=StoredUAdsorbateTorsion;
+      UAdsorbateImproperTorsion[CurrentSystem]=StoredUAdsorbateImproperTorsion;
+      UAdsorbateBondBond[CurrentSystem]=StoredUAdsorbateBondBond;
+      UAdsorbateBendBend[CurrentSystem]=StoredUAdsorbateBendBend;
+      UAdsorbateBondTorsion[CurrentSystem]=StoredUAdsorbateBondTorsion;
+      UAdsorbateBondBend[CurrentSystem]=StoredUAdsorbateBondBend;
+      UAdsorbateBendTorsion[CurrentSystem]=StoredUAdsorbateBendTorsion;
+      UAdsorbateIntraVDW[CurrentSystem]=StoredUAdsorbateIntraVDW;
+      UAdsorbateIntraChargeCharge[CurrentSystem]=StoredUAdsorbateIntraChargeCharge;
+      UAdsorbateIntraChargeBondDipole[CurrentSystem]=StoredUAdsorbateIntraChargeBondDipole;
+      UAdsorbateIntraBondDipoleBondDipole[CurrentSystem]=StoredUAdsorbateIntraBondDipoleBondDipole;
+	  
+      UCationBond[CurrentSystem]=StoredUCationBond;
+      UCationUreyBradley[CurrentSystem]=StoredUCationUreyBradley;
+      UCationBend[CurrentSystem]=StoredUCationBend;
+      UCationInversionBend[CurrentSystem]=StoredUCationInversionBend;
+      UCationTorsion[CurrentSystem]=StoredUCationTorsion;
+      UCationImproperTorsion[CurrentSystem]=StoredUCationImproperTorsion;
+      UCationBondBond[CurrentSystem]=StoredUCationBondBond;
+      UCationBendBend[CurrentSystem]=StoredUCationBendBend;
+      UCationBondBend[CurrentSystem]=StoredUCationBondBend;
+      UCationBondTorsion[CurrentSystem]=StoredUCationBondTorsion;
+      UCationBendTorsion[CurrentSystem]=StoredUCationBendTorsion;
+      UCationIntraVDW[CurrentSystem]=StoredUCationIntraVDW;
+      UCationIntraChargeCharge[CurrentSystem]=StoredUCationIntraChargeCharge;
+      UCationIntraChargeBondDipole[CurrentSystem]=StoredUCationIntraChargeBondDipole;
+      UCationIntraBondDipoleBondDipole[CurrentSystem]=StoredUCationIntraBondDipoleBondDipole;
+
+      UHostHost[CurrentSystem]=StoredUHostHost;
+      UHostHostVDW[CurrentSystem]=StoredUHostHostVDW;
+      UHostHostChargeChargeReal[CurrentSystem]=StoredUHostHostChargeChargeReal;
+      UHostHostChargeBondDipoleReal[CurrentSystem]=StoredUHostHostChargeBondDipoleReal;
+      UHostHostBondDipoleBondDipoleReal[CurrentSystem]=StoredUHostHostBondDipoleBondDipoleReal;
+      UHostHostChargeChargeFourier[CurrentSystem]=StoredUHostHostChargeChargeFourier;
+      UHostHostChargeBondDipoleFourier[CurrentSystem]=StoredUHostHostChargeBondDipoleFourier;
+      UHostHostBondDipoleBondDipoleFourier[CurrentSystem]=StoredUHostHostBondDipoleBondDipoleFourier;
+      UHostHostCoulomb[CurrentSystem]=StoredUHostHostCoulomb;
+	  
+      UHostAdsorbate[CurrentSystem]=StoredUHostAdsorbate;
+      UHostAdsorbateVDW[CurrentSystem]=StoredUHostAdsorbateVDW;
+      UHostAdsorbateChargeChargeReal[CurrentSystem]=StoredUHostAdsorbateChargeChargeReal;
+      UHostAdsorbateChargeBondDipoleReal[CurrentSystem]=StoredUHostAdsorbateChargeBondDipoleReal;
+      UHostAdsorbateBondDipoleBondDipoleReal[CurrentSystem]=StoredUHostAdsorbateBondDipoleBondDipoleReal;
+      UHostAdsorbateChargeChargeFourier[CurrentSystem]=StoredUHostAdsorbateChargeChargeFourier;
+      UHostAdsorbateChargeBondDipoleFourier[CurrentSystem]=StoredUHostAdsorbateChargeBondDipoleFourier;
+      UHostAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]=StoredUHostAdsorbateBondDipoleBondDipoleFourier;
+      UHostAdsorbateCoulomb[CurrentSystem]=StoredUHostAdsorbateCoulomb;
+
+      UHostCation[CurrentSystem]=StoredUHostCation;
+      UHostCationVDW[CurrentSystem]=StoredUHostCationVDW;
+      UHostCationChargeChargeReal[CurrentSystem]=StoredUHostCationChargeChargeReal;
+      UHostCationChargeBondDipoleReal[CurrentSystem]=StoredUHostCationChargeBondDipoleReal;
+      UHostCationBondDipoleBondDipoleReal[CurrentSystem]=StoredUHostCationBondDipoleBondDipoleReal;
+      UHostCationChargeChargeFourier[CurrentSystem]=StoredUHostCationChargeChargeFourier;
+      UHostCationChargeBondDipoleFourier[CurrentSystem]=StoredUHostCationChargeBondDipoleFourier;
+      UHostCationBondDipoleBondDipoleFourier[CurrentSystem]=StoredUHostCationBondDipoleBondDipoleFourier;
+      UHostCationCoulomb[CurrentSystem]=StoredUHostCationCoulomb;
+	  
+      UAdsorbateAdsorbate[CurrentSystem]=StoredUAdsorbateAdsorbate;
+      UAdsorbateAdsorbateVDW[CurrentSystem]=StoredUAdsorbateAdsorbateVDW;
+      UAdsorbateAdsorbateChargeChargeReal[CurrentSystem]=StoredUAdsorbateAdsorbateChargeChargeReal;
+      UAdsorbateAdsorbateChargeBondDipoleReal[CurrentSystem]=StoredUAdsorbateAdsorbateChargeBondDipoleReal;
+      UAdsorbateAdsorbateBondDipoleBondDipoleReal[CurrentSystem]=StoredUAdsorbateAdsorbateBondDipoleBondDipoleReal;
+      UAdsorbateAdsorbateChargeChargeFourier[CurrentSystem]=StoredUAdsorbateAdsorbateChargeChargeFourier;
+      UAdsorbateAdsorbateChargeBondDipoleFourier[CurrentSystem]=StoredUAdsorbateAdsorbateChargeBondDipoleFourier;
+      UAdsorbateAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]=StoredUAdsorbateAdsorbateBondDipoleBondDipoleFourier;
+      UAdsorbateAdsorbateCoulomb[CurrentSystem]=StoredUAdsorbateAdsorbateCoulomb;
+	  
+      UAdsorbateCation[CurrentSystem]=StoredUAdsorbateCation;
+      UAdsorbateCationVDW[CurrentSystem]=StoredUAdsorbateCationVDW;
+      UAdsorbateCationChargeChargeReal[CurrentSystem]=StoredUAdsorbateCationChargeChargeReal;
+      UAdsorbateCationChargeBondDipoleReal[CurrentSystem]=StoredUAdsorbateCationChargeBondDipoleReal;
+      UAdsorbateCationBondDipoleBondDipoleReal[CurrentSystem]=StoredUAdsorbateCationBondDipoleBondDipoleReal;
+      UAdsorbateCationChargeChargeFourier[CurrentSystem]=StoredUAdsorbateCationChargeChargeFourier;
+      UAdsorbateCationChargeBondDipoleFourier[CurrentSystem]=StoredUAdsorbateCationChargeBondDipoleFourier;
+      UAdsorbateCationBondDipoleBondDipoleFourier[CurrentSystem]=StoredUAdsorbateCationBondDipoleBondDipoleFourier;
+      UAdsorbateCationCoulomb[CurrentSystem]=StoredUAdsorbateCationCoulomb;
+	  
+      UCationCation[CurrentSystem]=StoredUCationCation;
+      UCationCationVDW[CurrentSystem]=StoredUCationCationVDW;
+      UCationCationChargeChargeReal[CurrentSystem]=StoredUCationCationChargeChargeReal;
+      UCationCationChargeBondDipoleReal[CurrentSystem]=StoredUCationCationChargeBondDipoleReal;
+      UCationCationBondDipoleBondDipoleReal[CurrentSystem]=StoredUCationCationBondDipoleBondDipoleReal;
+      UCationCationChargeChargeFourier[CurrentSystem]=StoredUCationCationChargeChargeFourier;
+      UCationCationChargeBondDipoleFourier[CurrentSystem]=StoredUCationCationChargeBondDipoleFourier;
+      UCationCationBondDipoleBondDipoleFourier[CurrentSystem]=StoredUCationCationBondDipoleBondDipoleFourier;
+      UCationCationCoulomb[CurrentSystem]=StoredUCationCationCoulomb;
+      UTailCorrection[CurrentSystem]=StoredUTailCorrection;
+	  
+      UHostPolarization[CurrentSystem]=UHostPolarizationStored;
+      UAdsorbatePolarization[CurrentSystem]=UHostPolarizationStored;
+      UCationPolarization[CurrentSystem]=UCationPolarizationStored;
+	  
+      UHostBackPolarization[CurrentSystem]=UHostBackPolarizationStored;
+      UAdsorbateBackPolarization[CurrentSystem]=UAdsorbateBackPolarizationStored;
+      UCationBackPolarization[CurrentSystem]=UCationBackPolarizationStored;
+	  
+      UTotal[CurrentSystem]=StoredUTotal;
+      UTailCorrection[CurrentSystem]=StoredUTailCorrection;
+      
+      // restore all the positions to the Old state
+      for(f1=0;f1<Framework[CurrentSystem].NumberOfFrameworks;f1++)
+        for(i=0;i<Framework[CurrentSystem].NumberOfAtoms[f1];i++)
+          Framework[CurrentSystem].Atoms[f1][i].Position=Framework[CurrentSystem].Atoms[f1][i].ReferencePosition;
+	  
+	  // Restore the NumberOfPseudoAtom pointer.
+	  for(i=0;i<NumberOfPseudoAtoms;i++)
+	  {
+		NumberOfPseudoAtomsTypeNew[i]=NumberOfPseudoAtomsReferenceTypeNew[i];
+		NumberOfPseudoAtomsTypeOld[i]=NumberOfPseudoAtomsReferenceTypeOld[i];
+		NumberOfPseudoAtomsType[CurrentSystem][i]=NumberOfPseudoAtomsReferenceType[CurrentSystem][i];
+	  }  
+
+	  // Retrieve the number of non-alchemed molecules.
+	  int UntouchedAdsorbates=NumberOfAdsorbateMolecules[CurrentSystem]-NumberTransientMoities[CurrentAlchemicalReaction];
+	
+	  // Copy the former molecule that has not been chosen for ion exchange.
+      for(m=0;m<UntouchedAdsorbates;m++)
+	  {
+		Type=Adsorbates[CurrentSystem][m].Type;
+		
+		for(i=0;i<Components[Type].NumberOfGroups;i++)
+		  Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassPosition=Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition;
+
+		for(i=0;i<Adsorbates[CurrentSystem][m].NumberOfAtoms;i++)
+		  Adsorbates[CurrentSystem][m].Atoms[i].Position=Adsorbates[CurrentSystem][m].Atoms[i].ReferencePosition; 
+	  }
+      
+      // Copy the former molecule candidate for the ions exchange: restore initial
+      int n;
+	  
+      for(n=0;n<NumberTransientMoities[CurrentAlchemicalReaction];n++)
+      {
+			// We add the candidates molecules at the top of the pile of adsorbate.
+			m=n+UntouchedAdsorbates;
+			Type=AdsorbatesReferenceChosen[n].Type;
+			
+			// Update number of transient
+			Components[Type].NumberOfMolecules[CurrentSystem]++;
+			
+			// Update Adsorabtes
+			Adsorbates[CurrentSystem][m].Type=Type;
+			Adsorbates[CurrentSystem][m].NumberOfAtoms=AdsorbatesReferenceChosen[n].NumberOfAtoms;
+				Adsorbates[CurrentSystem][m].Atoms=(ATOM*)realloc(Adsorbates[CurrentSystem][m].Atoms,(Components[Type].NumberOfAtoms)*sizeof(ATOM));
+			if(Components[Type].NumberOfGroups>0)
+				Adsorbates[CurrentSystem][m].Groups=(GROUP*)realloc(Adsorbates[CurrentSystem][m].Groups,(Components[Type].NumberOfGroups)*sizeof(GROUP));
+			
+			for(i=0;i<Components[Type].NumberOfGroups;i++)
+			  Adsorbates[CurrentSystem][m].Groups[i]=AdsorbatesReferenceChosen[n].Groups[i];
+			
+			for(i=0;i<AdsorbatesReferenceChosen[n].NumberOfAtoms;i++)
+			  Adsorbates[CurrentSystem][m].Atoms[i]=AdsorbatesReferenceChosen[n].Atoms[i]; 
+	   }
+	   
+	  // The cation are not modified in the alchemical transformation.
+      for(m=0;m<NumberOfCationMolecules[CurrentSystem];m++)
+      {
+        Type=Cations[CurrentSystem][m].Type;
+        for(i=0;i<Components[Type].NumberOfGroups;i++)
+          Cations[CurrentSystem][m].Groups[i].CenterOfMassPosition=Cations[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition;
+        for(i=0;i<Cations[CurrentSystem][m].NumberOfAtoms;i++)
+          Cations[CurrentSystem][m].Atoms[i].Position=Cations[CurrentSystem][m].Atoms[i].ReferencePosition;
+      }
+
+	  // Restore the initial degrees of freedom.
+	  DegreesOfFreedomAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceAdsorbates;
+	  DegreesOfFreedomTranslation[CurrentSystem]=DegreesOfFreedomReferenceTranslation;
+	  DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceTranslationalAdsorbates;
+	  DegreesOfFreedom[CurrentSystem]=DegreesOfFreedomReference;
+	  							
+	  DegreesOfFreedomRotation[CurrentSystem]=DegreesOfFreedomReferenceRotation;
+	  DegreesOfFreedomAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceAdsorbates;
+	  DegreesOfFreedomRotationalAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceRotationalAdsorbates;
+
+      if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+        RetrieveStoredEwaldStructureFactors(0,CurrentSystem);
+
+      CalculateAnisotropicSites();
+  }
+  
+  // deallocate memory
+  RemoveExtraPseudoAtoms();
+  DeallocateTransientComponentMemory();
+  DeallocateMemoryParameterTab();
+  
+  // restore the initial memory of components, pseudoatom and and other vectors.
+  DeallocateChosenMoitiesCoordinates();
+ 
+  InitializeForces();
+  * 
+  // Let's free the used pointer.
+  free(OldComponent);
+  free(NewComponent); 
+  
+  return 0;
+}
+*/
+
+// Added by Ambroise de Izarra
+/*********************************************************************************************************
+ * Name       | WidomOsmostatCalculation     (Added by A. de Izarra)                                  	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | NCMC move to perform calculation of alchemical work.			                    	 *
+ * Parameters | No parameters																			 *
+ * Note		  |	In this RASPA patch, two water molecules are inserted through NCMC move to calculated	 *
+ * 			  | alchemical work													 						 *
+ *********************************************************************************************************/
+
+int WidomOsmostatCalculation(void)
+{ 		
+  int i,j,f1,m;
+  int Type;
+  REAL Drift;
+  REAL ReferenceEnergy;
+  
+  // Declare the component index of old and new
+  int CurrentAlchemicalReaction;
+  int * OldComponent; 
+  int * NewComponent; 
+  int NumberOldComponent;
+  int NumberNewComponent;
+  
+  int NumberOfMolecules;
+  int InitialSaltIons;
+  int InitialWater; 
+  
+  REAL AlchemicalWork_vdw=0.0;
+  REAL AlchemicalWork_elec=0.0;
+  REAL Ubefore=0.0;
+  REAL Uafter=0.0;
+
+  REAL *NCMCWorkStore= (REAL*)calloc(AlchReacLambda,sizeof(REAL)); 
+  
+  // We will store the energy of the system before performing the alchemical transformation
+  REAL StoredUHostBond,StoredUHostUreyBradley,StoredUHostBend,StoredUHostInversionBend;
+  REAL StoredUHostTorsion,StoredUHostImproperTorsion,StoredUHostBondBond;
+  REAL StoredUHostBendBend,StoredUHostBondBend,StoredUHostBondTorsion,StoredUHostBendTorsion;
+
+  REAL StoredUAdsorbateBond,StoredUAdsorbateUreyBradley,StoredUAdsorbateBend,StoredUAdsorbateInversionBend;
+  REAL StoredUAdsorbateTorsion,StoredUAdsorbateImproperTorsion,StoredUAdsorbateBondBond;
+  REAL StoredUAdsorbateBendBend,StoredUAdsorbateBondBend,StoredUAdsorbateBondTorsion,StoredUAdsorbateBendTorsion;
+  REAL StoredUAdsorbateIntraVDW,StoredUAdsorbateIntraChargeCharge;
+  REAL StoredUAdsorbateIntraChargeBondDipole,StoredUAdsorbateIntraBondDipoleBondDipole;
+
+  REAL StoredUCationBond,StoredUCationUreyBradley,StoredUCationBend,StoredUCationInversionBend;
+  REAL StoredUCationTorsion,StoredUCationImproperTorsion,StoredUCationBondBond;
+  REAL StoredUCationBendBend,StoredUCationBondBend,StoredUCationBondTorsion,StoredUCationBendTorsion;
+  REAL StoredUCationIntraVDW,StoredUCationIntraChargeCharge;
+  REAL StoredUCationIntraChargeBondDipole,StoredUCationIntraBondDipoleBondDipole;
+
+  REAL StoredUHostHost,StoredUHostHostVDW,StoredUHostHostChargeChargeReal;
+  REAL StoredUHostHostChargeBondDipoleReal,StoredUHostHostBondDipoleBondDipoleReal;
+  REAL StoredUHostHostChargeChargeFourier,StoredUHostHostCoulomb;
+  REAL StoredUHostHostChargeBondDipoleFourier,StoredUHostHostBondDipoleBondDipoleFourier;
+  REAL StoredUHostAdsorbate,StoredUHostAdsorbateVDW,StoredUHostAdsorbateChargeChargeReal;
+  REAL StoredUHostAdsorbateChargeBondDipoleReal,StoredUHostAdsorbateBondDipoleBondDipoleReal;
+  REAL StoredUHostAdsorbateChargeChargeFourier,StoredUHostAdsorbateCoulomb;
+  REAL StoredUHostAdsorbateChargeBondDipoleFourier,StoredUHostAdsorbateBondDipoleBondDipoleFourier;
+  REAL StoredUHostCation,StoredUHostCationVDW,StoredUHostCationChargeChargeReal;
+  REAL StoredUHostCationChargeBondDipoleReal,StoredUHostCationBondDipoleBondDipoleReal;
+  REAL StoredUHostCationChargeChargeFourier,StoredUHostCationCoulomb;
+  REAL StoredUHostCationChargeBondDipoleFourier,StoredUHostCationBondDipoleBondDipoleFourier;
+
+  REAL StoredUAdsorbateAdsorbate,StoredUAdsorbateAdsorbateVDW,StoredUAdsorbateAdsorbateChargeChargeReal;
+  REAL StoredUAdsorbateAdsorbateChargeBondDipoleReal,StoredUAdsorbateAdsorbateBondDipoleBondDipoleReal;
+  REAL StoredUAdsorbateAdsorbateChargeChargeFourier,StoredUAdsorbateAdsorbateCoulomb;
+  REAL StoredUAdsorbateAdsorbateChargeBondDipoleFourier,StoredUAdsorbateAdsorbateBondDipoleBondDipoleFourier;
+  REAL StoredUAdsorbateCation,StoredUAdsorbateCationVDW,StoredUAdsorbateCationChargeChargeReal;
+  REAL StoredUAdsorbateCationChargeBondDipoleReal,StoredUAdsorbateCationBondDipoleBondDipoleReal;
+  REAL StoredUAdsorbateCationChargeChargeFourier,StoredUAdsorbateCationCoulomb;
+  REAL StoredUAdsorbateCationChargeBondDipoleFourier,StoredUAdsorbateCationBondDipoleBondDipoleFourier;
+  REAL StoredUCationCation,StoredUCationCationVDW,StoredUCationCationChargeChargeReal;
+  REAL StoredUCationCationChargeBondDipoleReal,StoredUCationCationBondDipoleBondDipoleReal;
+  REAL StoredUCationCationChargeChargeFourier,StoredUCationCationCoulomb;
+  REAL StoredUCationCationChargeBondDipoleFourier,StoredUCationCationBondDipoleBondDipoleFourier;
+  REAL StoredUTotal,StoredUTailCorrection;
+
+  REAL UHostPolarizationStored,UAdsorbatePolarizationStored,UCationPolarizationStored;
+  REAL UHostBackPolarizationStored,UAdsorbateBackPolarizationStored,UCationBackPolarizationStored;
+
+  REAL StoredUKinetic,StoredUHostKinetic,StoredUAdsorbateTranslationalKinetic;
+  REAL StoredUCationTranslationalKinetic,StoredUAdsorbateRotationalKinetic;
+  REAL StoredUCationRotationalKinetic,StoredUAdsorbateKinetic,StoredUCationKinetic;
+
+  // Test if there is any molecules in the system, other than those belonging to the framework.
+  NumberOfMolecules=NumberOfAdsorbateMolecules[CurrentSystem];
+
+  if(NumberOfMolecules==0) return -1;
+ 
+  StoredUTotal=UTotal[CurrentSystem];
+  StoredUTailCorrection=UTailCorrection[CurrentSystem];
+
+  StoredUHostBond=UHostBond[CurrentSystem];
+  StoredUHostUreyBradley=UHostUreyBradley[CurrentSystem];
+  StoredUHostBend=UHostBend[CurrentSystem];
+  StoredUHostInversionBend=UHostInversionBend[CurrentSystem];
+  StoredUHostTorsion=UHostTorsion[CurrentSystem];
+  StoredUHostImproperTorsion=UHostImproperTorsion[CurrentSystem];
+  StoredUHostBondBond=UHostBondBond[CurrentSystem];
+  StoredUHostBendBend=UHostBendBend[CurrentSystem];
+  StoredUHostBondBend=UHostBondBend[CurrentSystem];
+  StoredUHostBondTorsion=UHostBondTorsion[CurrentSystem];
+  StoredUHostBendTorsion=UHostBendTorsion[CurrentSystem];
+
+  StoredUAdsorbateBond=UAdsorbateBond[CurrentSystem];
+  StoredUAdsorbateUreyBradley=UAdsorbateUreyBradley[CurrentSystem];
+  StoredUAdsorbateBend=UAdsorbateBend[CurrentSystem];
+  StoredUAdsorbateInversionBend=UAdsorbateInversionBend[CurrentSystem];
+  StoredUAdsorbateTorsion=UAdsorbateTorsion[CurrentSystem];
+  StoredUAdsorbateImproperTorsion=UAdsorbateImproperTorsion[CurrentSystem];
+  StoredUAdsorbateBondBond=UAdsorbateBondBond[CurrentSystem];
+  StoredUAdsorbateBendBend=UAdsorbateBendBend[CurrentSystem];
+  StoredUAdsorbateBondBend=UAdsorbateBondBend[CurrentSystem];
+  StoredUAdsorbateBondTorsion=UAdsorbateBondTorsion[CurrentSystem];
+  StoredUAdsorbateBendTorsion=UAdsorbateBendTorsion[CurrentSystem];
+  StoredUAdsorbateIntraVDW=UAdsorbateIntraVDW[CurrentSystem];
+  StoredUAdsorbateIntraChargeCharge=UAdsorbateIntraChargeCharge[CurrentSystem];
+  StoredUAdsorbateIntraChargeBondDipole=UAdsorbateIntraChargeBondDipole[CurrentSystem];
+  StoredUAdsorbateIntraBondDipoleBondDipole=UAdsorbateIntraBondDipoleBondDipole[CurrentSystem];
+
+  StoredUCationBond=UCationBond[CurrentSystem];
+  StoredUCationUreyBradley=UCationUreyBradley[CurrentSystem];
+  StoredUCationBend=UCationBend[CurrentSystem];
+  StoredUCationInversionBend=UCationInversionBend[CurrentSystem];
+  StoredUCationTorsion=UCationTorsion[CurrentSystem];
+  StoredUCationImproperTorsion=UCationImproperTorsion[CurrentSystem];
+  StoredUCationBondBond=UCationBondBond[CurrentSystem];
+  StoredUCationBendBend=UCationBendBend[CurrentSystem];
+  StoredUCationBondBend=UCationBondBend[CurrentSystem];
+  StoredUCationBondTorsion=UCationBondTorsion[CurrentSystem];
+  StoredUCationBendTorsion=UCationBendTorsion[CurrentSystem];
+  StoredUCationIntraVDW=UCationIntraVDW[CurrentSystem];
+  StoredUCationIntraChargeCharge=UCationIntraChargeCharge[CurrentSystem];
+  StoredUCationIntraChargeBondDipole=UCationIntraChargeBondDipole[CurrentSystem];
+  StoredUCationIntraBondDipoleBondDipole=UCationIntraBondDipoleBondDipole[CurrentSystem];
+
+  StoredUHostHost=UHostHost[CurrentSystem];
+  StoredUHostHostVDW=UHostHostVDW[CurrentSystem];
+  StoredUHostHostChargeChargeReal=UHostHostChargeChargeReal[CurrentSystem];
+  StoredUHostHostChargeChargeFourier=UHostHostChargeChargeFourier[CurrentSystem];
+  StoredUHostHostChargeBondDipoleReal=UHostHostChargeBondDipoleReal[CurrentSystem];
+  StoredUHostHostChargeBondDipoleFourier=UHostHostChargeBondDipoleFourier[CurrentSystem];
+  StoredUHostHostBondDipoleBondDipoleReal=UHostHostBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUHostHostBondDipoleBondDipoleFourier=UHostHostBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUHostHostCoulomb=UHostHostCoulomb[CurrentSystem];
+
+  StoredUHostAdsorbate=UHostAdsorbate[CurrentSystem];
+  StoredUHostAdsorbateVDW=UHostAdsorbateVDW[CurrentSystem];
+  StoredUHostAdsorbateChargeChargeReal=UHostAdsorbateChargeChargeReal[CurrentSystem];
+  StoredUHostAdsorbateChargeBondDipoleReal=UHostAdsorbateChargeBondDipoleReal[CurrentSystem];
+  StoredUHostAdsorbateBondDipoleBondDipoleReal=UHostAdsorbateBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUHostAdsorbateChargeChargeFourier=UHostAdsorbateChargeChargeFourier[CurrentSystem];
+  StoredUHostAdsorbateChargeBondDipoleFourier=UHostAdsorbateChargeBondDipoleFourier[CurrentSystem];
+  StoredUHostAdsorbateBondDipoleBondDipoleFourier=UHostAdsorbateBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUHostAdsorbateCoulomb=UHostAdsorbateCoulomb[CurrentSystem];
+
+  StoredUHostCation=UHostCation[CurrentSystem];
+  StoredUHostCationVDW=UHostCationVDW[CurrentSystem];
+  StoredUHostCationChargeChargeReal=UHostCationChargeChargeReal[CurrentSystem];
+  StoredUHostCationChargeBondDipoleReal=UHostCationChargeBondDipoleReal[CurrentSystem];
+  StoredUHostCationBondDipoleBondDipoleReal=UHostCationBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUHostCationChargeChargeFourier=UHostCationChargeChargeFourier[CurrentSystem];
+  StoredUHostCationChargeBondDipoleFourier=UHostCationChargeBondDipoleFourier[CurrentSystem];
+  StoredUHostCationBondDipoleBondDipoleFourier=UHostCationBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUHostCationCoulomb=UHostCationCoulomb[CurrentSystem];
+
+  StoredUAdsorbateAdsorbate=UAdsorbateAdsorbate[CurrentSystem];
+  StoredUAdsorbateAdsorbateVDW=UAdsorbateAdsorbateVDW[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeChargeReal=UAdsorbateAdsorbateChargeChargeReal[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeBondDipoleReal=UAdsorbateAdsorbateChargeBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateAdsorbateBondDipoleBondDipoleReal=UAdsorbateAdsorbateBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeChargeFourier=UAdsorbateAdsorbateChargeChargeFourier[CurrentSystem];
+  StoredUAdsorbateAdsorbateChargeBondDipoleFourier=UAdsorbateAdsorbateChargeBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateAdsorbateBondDipoleBondDipoleFourier=UAdsorbateAdsorbateBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateAdsorbateCoulomb=UAdsorbateAdsorbateCoulomb[CurrentSystem];
+
+  StoredUAdsorbateCation=UAdsorbateCation[CurrentSystem];
+  StoredUAdsorbateCationVDW=UAdsorbateCationVDW[CurrentSystem];
+  StoredUAdsorbateCationChargeChargeReal=UAdsorbateCationChargeChargeReal[CurrentSystem];
+  StoredUAdsorbateCationChargeBondDipoleReal=UAdsorbateCationChargeBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateCationBondDipoleBondDipoleReal=UAdsorbateCationBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUAdsorbateCationChargeChargeFourier=UAdsorbateCationChargeChargeFourier[CurrentSystem];
+  StoredUAdsorbateCationChargeBondDipoleFourier=UAdsorbateCationChargeBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateCationBondDipoleBondDipoleFourier=UAdsorbateCationBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUAdsorbateCationCoulomb=UAdsorbateCationCoulomb[CurrentSystem];
 
-    TotalTranslationInPlaneAttempts[CurrentSystem][i].x+=TranslationInPlaneAttempts[CurrentSystem][i].x;
-    TotalTranslationInPlaneAccepted[CurrentSystem][i].x+=TranslationInPlaneAccepted[CurrentSystem][i].x;
-    TranslationInPlaneAttempts[CurrentSystem][i].x=TranslationInPlaneAccepted[CurrentSystem][i].x=0.0;
+  StoredUCationCation=UCationCation[CurrentSystem];
+  StoredUCationCationVDW=UCationCationVDW[CurrentSystem];
+  StoredUCationCationChargeChargeReal=UCationCationChargeChargeReal[CurrentSystem];
+  StoredUCationCationChargeBondDipoleReal=UCationCationChargeBondDipoleReal[CurrentSystem];
+  StoredUCationCationBondDipoleBondDipoleReal=UCationCationBondDipoleBondDipoleReal[CurrentSystem];
+  StoredUCationCationChargeChargeFourier=UCationCationChargeChargeFourier[CurrentSystem];
+  StoredUCationCationChargeBondDipoleFourier=UCationCationChargeBondDipoleFourier[CurrentSystem];
+  StoredUCationCationBondDipoleBondDipoleFourier=UCationCationBondDipoleBondDipoleFourier[CurrentSystem];
+  StoredUCationCationCoulomb=UCationCationCoulomb[CurrentSystem];
 
-    TotalTranslationInPlaneAttempts[CurrentSystem][i].y+=TranslationInPlaneAttempts[CurrentSystem][i].y;
-    TotalTranslationInPlaneAccepted[CurrentSystem][i].y+=TranslationInPlaneAccepted[CurrentSystem][i].y;
-    TranslationInPlaneAttempts[CurrentSystem][i].y=TranslationInPlaneAccepted[CurrentSystem][i].y=0.0;
+  UHostPolarizationStored=UHostPolarization[CurrentSystem];
+  UAdsorbatePolarizationStored=UAdsorbatePolarization[CurrentSystem];
+  UCationPolarizationStored=UCationPolarization[CurrentSystem];
 
-    TotalTranslationInPlaneAttempts[CurrentSystem][i].z+=TranslationInPlaneAttempts[CurrentSystem][i].z;
-    TotalTranslationInPlaneAccepted[CurrentSystem][i].z+=TranslationInPlaneAccepted[CurrentSystem][i].z;
-    TranslationInPlaneAttempts[CurrentSystem][i].z=TranslationInPlaneAccepted[CurrentSystem][i].z=0.0;
+  UHostBackPolarizationStored=UHostBackPolarization[CurrentSystem];
+  UAdsorbateBackPolarizationStored=UAdsorbateBackPolarization[CurrentSystem];
+  UCationBackPolarizationStored=UCationBackPolarization[CurrentSystem];
+  
+  // Store the degrees of freedom of the system.
+  DegreesOfFreedomReferenceAdsorbates = DegreesOfFreedomAdsorbates[CurrentSystem];
+  DegreesOfFreedomReferenceTranslation = DegreesOfFreedomTranslation[CurrentSystem];
+  DegreesOfFreedomReferenceTranslationalAdsorbates = DegreesOfFreedomTranslationalAdsorbates[CurrentSystem];
+  DegreesOfFreedomReference = DegreesOfFreedom[CurrentSystem];
+  							
+  DegreesOfFreedomReferenceRotation = DegreesOfFreedomRotation[CurrentSystem];
+  DegreesOfFreedomReferenceAdsorbates = DegreesOfFreedomAdsorbates[CurrentSystem];
+  DegreesOfFreedomReferenceRotationalAdsorbates = DegreesOfFreedomRotationalAdsorbates[CurrentSystem];
+  
+  
+  // store the positions of the framework
+  for(f1=0;f1<Framework[CurrentSystem].NumberOfFrameworks;f1++)
+    for(i=0;i<Framework[CurrentSystem].NumberOfAtoms[f1];i++)
+      Framework[CurrentSystem].Atoms[f1][i].ReferencePosition=Framework[CurrentSystem].Atoms[f1][i].Position;
+  
+  // Store the NumberOfPseudoAtom pointer.
+  NumberOfPseudoAtomsReferenceTypeNew=(int*)calloc(NumberOfPseudoAtoms,sizeof(int));
+  NumberOfPseudoAtomsReferenceTypeOld=(int*)calloc(NumberOfPseudoAtoms,sizeof(int));
+  NumberOfPseudoAtomsReferenceType=(int**)calloc(NumberOfSystems,sizeof(int*));
+	
+  for(i=0;i<NumberOfSystems;i++)
+  {
+	  NumberOfPseudoAtomsReferenceType[i]=(int*)calloc(NumberOfPseudoAtoms,sizeof(int));
   }
-}
 
-void PrintReinsertionInPlaneStatistics(FILE *FilePtr)
-{
-  int i,MoveUsed;
+  for(i=0;i<NumberOfPseudoAtoms;i++)
+  {
+	  NumberOfPseudoAtomsReferenceTypeNew[i]=NumberOfPseudoAtomsTypeNew[i];
+	  NumberOfPseudoAtomsReferenceTypeOld[i]=NumberOfPseudoAtomsTypeOld[i];
+	  NumberOfPseudoAtomsReferenceType[CurrentSystem][i]=NumberOfPseudoAtomsType[CurrentSystem][i];
+  }
 
-  MoveUsed=FALSE;
-  for(i=0;i<NumberOfComponents;i++)
+  // store the structure-factors for the Ewald-summations
+  if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+    SaveCurrentEwaldStructureFactors(0,CurrentSystem);
+    
+  if (NumberAlchemicalReactions<=0) return 0;
+
+  CurrentAlchemicalReaction=0;
+  
+  InitialSaltIons = Components[SaltIndex[CurrentAlchemicalReaction][0]].NumberOfMolecules[CurrentSystem]+
+					Components[SaltIndex[CurrentAlchemicalReaction][1]].NumberOfMolecules[CurrentSystem];
+  	
+  InitialWater    =	Components[SolventIndex].NumberOfMolecules[CurrentSystem];
+  
+  // Remove water and insert ions, for calculation of osmostat.
+  OldComponent = (int*)calloc(2,sizeof(int)); // This is the salt
+  NewComponent = (int*)calloc(1,sizeof(int)); // This is water.
+  
+  OldComponent[0] = SaltIndex[CurrentAlchemicalReaction][0];
+  OldComponent[1] = SaltIndex[CurrentAlchemicalReaction][1];
+  
+  NewComponent[0] = SolventIndex;  
+  
+  NumberOldComponent = 2;
+  NumberNewComponent = 1;
+  
+  // Select random particules.
+  SelectRandomMoleculeAlchemicalTransformation(OldComponent, NumberOldComponent, CurrentAlchemicalReaction);
+
+  // Extra memory for the new 2 transient components
+  AddExtraPseudoAtoms();	
+  AllocateTransientComponentMemory();	
+  ReallocateMemoryParameterTab();
+  
+  // Store position of Chosen moities, before removing the chosen moities from the old system.
+  StoreChosenMoitiesCoordinates(NumberOldComponent);
+	
+  // Set up the mass of the new transient, according to the choice of components
+  InitializeMassTransientMoities(NumberOldComponent);
+  InitializeVDWTransientMoities(NumberOldComponent);
+  InitializeChargeTransientMoities(NumberOldComponent);
+    
+  // Delete chosen adsorbates and add intial transient adsorbates
+  DeleteChosenMoities();
+  
+  // store the positions of the Adsorbates
+  for(m=0;m<NumberOfAdsorbateMolecules[CurrentSystem];m++)
   {
-    if(Components[i].FractionOfReinsertionInPlaneMove>0.0)
+    Type=Adsorbates[CurrentSystem][m].Type;
+    for(i=0;i<Components[Type].NumberOfGroups;i++)
+      Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition=Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassPosition;
+    for(i=0;i<Adsorbates[CurrentSystem][m].NumberOfAtoms;i++)
     {
-      MoveUsed=TRUE;
-      break;
+      Adsorbates[CurrentSystem][m].Atoms[i].ReferencePosition=Adsorbates[CurrentSystem][m].Atoms[i].Position;
     }
   }
 
-  if(MoveUsed)
+  // store the positions of the cation.
+  for(m=0;m<NumberOfCationMolecules[CurrentSystem];m++)
   {
-    fprintf(FilePtr,"Performance of the reinsertion in plane move:\n");
-    fprintf(FilePtr,"=============================================\n");
-    for(i=0;i<NumberOfComponents;i++)
+    Type=Cations[CurrentSystem][m].Type;
+    for(i=0;i<Components[Type].NumberOfGroups;i++)
+      Cations[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition=Cations[CurrentSystem][m].Groups[i].CenterOfMassPosition;
+    for(i=0;i<Cations[CurrentSystem][m].NumberOfAtoms;i++)
+      Cations[CurrentSystem][m].Atoms[i].ReferencePosition=Cations[CurrentSystem][m].Atoms[i].Position;
+  }
+  
+  MakeInitialTransient(NumberOldComponent);
+  
+  Ensemble[CurrentSystem]=NVE;
+
+  // register an attempt to change the 'Old'-components to the 'New'-components.
+  WidomOsmostat[CurrentSystem][CurrentAlchemicalReaction]+=1.0;	
+
+  // Only do the vdw contribution
+  for(i=1;i<=AlchReacLambda;i++)
+  {	  
+	// get the energy before perturbation at i^th step.
+	if(i>0)Ubefore = UTotal[CurrentSystem];
+
+	// interpolate vdw parameters.
+	UpdateMixingRuleVDWInterpolationAlchemicalTransformation(NumberOldComponent, Lambda[i]);  
+
+	// Then prepare for NVE simulation.
+    for(j=0;j<NumberOfAdsorbateMolecules[CurrentSystem];j++)
+		InitializeVelocityAdsorbate(j);
+	
+	for(j=0;j<NumberOfCationMolecules[CurrentSystem];j++)
+		InitializeVelocityCation(j);
+
+	if(Framework[CurrentSystem].FrameworkModel==FLEXIBLE)
+		InitializeFrameworkVelocities();
+
+	InitializeForces();
+
+	// get the energy after perturbation at i^th step.
+	if(i>0)Uafter = UTotal[CurrentSystem];
+
+	// Update Alchemical work
+	if(i>0)AlchemicalWork_vdw += Uafter - Ubefore;
+
+	StoredUKinetic=UKinetic[CurrentSystem];
+	StoredUHostKinetic=UHostKinetic[CurrentSystem];
+	StoredUAdsorbateTranslationalKinetic=UAdsorbateTranslationalKinetic[CurrentSystem];
+	StoredUCationTranslationalKinetic=UCationTranslationalKinetic[CurrentSystem];
+	StoredUAdsorbateRotationalKinetic=UAdsorbateRotationalKinetic[CurrentSystem];
+	StoredUCationRotationalKinetic=UCationRotationalKinetic[CurrentSystem];
+	StoredUAdsorbateKinetic=UAdsorbateKinetic[CurrentSystem];
+	StoredUCationKinetic=UCationKinetic[CurrentSystem];
+	
+	// register the starting temperatures
+    if(DegreesOfFreedom[CurrentSystem]>0)
     {
-      if(ReinsertionInPlaneAttempts[CurrentSystem][i]>0.0)
-      {
-        fprintf(FilePtr,"Component [%s] total tried: %lf succesfull growth: %lf (%lf [%%]) accepted: %lf (%lf [%%])\n",
-          Components[i].Name,
-          (double)ReinsertionInPlaneAttempts[CurrentSystem][i],
-          (double)ReinsertionInPlaneAccepted[CurrentSystem][i][0],
-          (double)(ReinsertionInPlaneAttempts[CurrentSystem][i]>(REAL)0.0?
-            100.0*ReinsertionInPlaneAccepted[CurrentSystem][i][0]/ReinsertionInPlaneAttempts[CurrentSystem][i]:(REAL)0.0),
-          (double)ReinsertionInPlaneAccepted[CurrentSystem][i][1],
-          (double)(ReinsertionInPlaneAttempts[CurrentSystem][i]>(REAL)0.0?
-            100.0*ReinsertionInPlaneAccepted[CurrentSystem][i][1]/ReinsertionInPlaneAttempts[CurrentSystem][i]:(REAL)0.0));
-      }
-      fprintf(FilePtr,"\ttotal        %lf %lf %lf\n",
-        (double)TotalTranslationInPlaneAttempts[CurrentSystem][i].x,
-        (double)TotalTranslationInPlaneAttempts[CurrentSystem][i].y,
-        (double)TotalTranslationInPlaneAttempts[CurrentSystem][i].z);
-      fprintf(FilePtr,"\tsuccesfull   %lf %lf %lf\n",
-        (double)TotalTranslationInPlaneAccepted[CurrentSystem][i].x,
-        (double)TotalTranslationInPlaneAccepted[CurrentSystem][i].y,
-        (double)TotalTranslationInPlaneAccepted[CurrentSystem][i].z);
-      fprintf(FilePtr,"\taccepted   %lf %lf %lf\n",
-        (double)(TotalTranslationInPlaneAttempts[CurrentSystem][i].x>(REAL)0.0?
-          TotalTranslationInPlaneAccepted[CurrentSystem][i].x/TotalTranslationInPlaneAttempts[CurrentSystem][i].x:(REAL)0.0),
-        (double)(TotalTranslationInPlaneAttempts[CurrentSystem][i].y>(REAL)0.0?
-          TotalTranslationInPlaneAccepted[CurrentSystem][i].y/TotalTranslationInPlaneAttempts[CurrentSystem][i].y:(REAL)0.0),
-        (double)(TotalTranslationInPlaneAttempts[CurrentSystem][i].z>(REAL)0.0?
-          TotalTranslationInPlaneAccepted[CurrentSystem][i].z/TotalTranslationInPlaneAttempts[CurrentSystem][i].z:(REAL)0.0));
-      fprintf(FilePtr,"\tdisplacement %lf %lf %lf\n",
-        (double)MaximumTranslationInPlane[CurrentSystem][i].x,
-        (double)MaximumTranslationInPlane[CurrentSystem][i].y,
-        (double)MaximumTranslationInPlane[CurrentSystem][i].z);
-      fprintf(FilePtr,"\n");
+      HybridNVEAlchStartTemperature[CurrentSystem]+=2.0*StoredUKinetic/(K_B*DegreesOfFreedom[CurrentSystem]);
+      HybridNVEAlchStartTemperatureCount[CurrentSystem]+=1.0;
     }
-    fprintf(FilePtr,"\n");
+    
+    if(DegreesOfFreedomTranslation[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTranslationalTemperature[CurrentSystem]+=2.0*(StoredUHostKinetic+
+         StoredUAdsorbateTranslationalKinetic+StoredUCationTranslationalKinetic)/
+                                                (K_B*DegreesOfFreedomTranslation[CurrentSystem]);
+      HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomRotation[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartRotationalTemperature[CurrentSystem]+=2.0*(StoredUAdsorbateRotationalKinetic+
+            StoredUCationRotationalKinetic)/(K_B*DegreesOfFreedomRotation[CurrentSystem]);
+      HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomFramework[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureFramework[CurrentSystem]+=2.0*StoredUHostKinetic/(K_B*DegreesOfFreedomFramework[CurrentSystem]);
+      HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomAdsorbates[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureAdsorbate[CurrentSystem]+=2.0*StoredUAdsorbateKinetic/(K_B*DegreesOfFreedomAdsorbates[CurrentSystem]);
+      HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]+=1.0;
+    }
+
+    if(DegreesOfFreedomCations[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureCation[CurrentSystem]+=2.0*StoredUCationKinetic/(K_B*DegreesOfFreedomCations[CurrentSystem]);
+      HybridNVEAlchStartTemperatureCationCount[CurrentSystem]+=1.0;
+    }
+
+    ReferenceEnergy=ConservedEnergy[CurrentSystem];
+    Drift=0.0;
+	
+    // integrated the system 'NumberOfHybridNVESteps' steps
+	for(j=0;j<RelaxationStepsAlchemicalTransformationMove;j++)
+	{
+		// evolve the system a full time-step
+		Integration();
+
+		// update the drift in the energy
+		Drift+=fabs((ConservedEnergy[CurrentSystem]-ReferenceEnergy)/ReferenceEnergy);
+	}
+	
+  }
+  
+  // Then do the electrostat contribution.
+  for(i=0;i<=AlchReacLambda;i++)
+  {	  
+	// get the energy before perturbation at i^th step.
+	if(i>0)Ubefore = UTotal[CurrentSystem];
+
+	// interpolate charge parameter
+	UpdateChargeInterpolationAlchemicalTransformation(NumberOldComponent, Lambda[i]);
+
+	// Then prepare for NVE simulation.
+    for(j=0;j<NumberOfAdsorbateMolecules[CurrentSystem];j++)
+		InitializeVelocityAdsorbate(j);
+	
+	for(j=0;j<NumberOfCationMolecules[CurrentSystem];j++)
+		InitializeVelocityCation(j);
+
+	if(Framework[CurrentSystem].FrameworkModel==FLEXIBLE)
+		InitializeFrameworkVelocities();
+
+	InitializeForces();
+	
+	// get the energy after perturbation at i^th step.
+	if(i>0)Uafter = UTotal[CurrentSystem];
+
+	// Update Alchemical work
+	if(i>0)AlchemicalWork_elec += Uafter - Ubefore;
+
+	StoredUKinetic=UKinetic[CurrentSystem];
+	StoredUHostKinetic=UHostKinetic[CurrentSystem];
+	StoredUAdsorbateTranslationalKinetic=UAdsorbateTranslationalKinetic[CurrentSystem];
+	StoredUCationTranslationalKinetic=UCationTranslationalKinetic[CurrentSystem];
+	StoredUAdsorbateRotationalKinetic=UAdsorbateRotationalKinetic[CurrentSystem];
+	StoredUCationRotationalKinetic=UCationRotationalKinetic[CurrentSystem];
+	StoredUAdsorbateKinetic=UAdsorbateKinetic[CurrentSystem];
+	StoredUCationKinetic=UCationKinetic[CurrentSystem];
+	
+	// register the starting temperatures
+    if(DegreesOfFreedom[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperature[CurrentSystem]+=2.0*StoredUKinetic/(K_B*DegreesOfFreedom[CurrentSystem]);
+      HybridNVEAlchStartTemperatureCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomTranslation[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTranslationalTemperature[CurrentSystem]+=2.0*(StoredUHostKinetic+
+         StoredUAdsorbateTranslationalKinetic+StoredUCationTranslationalKinetic)/
+                                                (K_B*DegreesOfFreedomTranslation[CurrentSystem]);
+      HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomRotation[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartRotationalTemperature[CurrentSystem]+=2.0*(StoredUAdsorbateRotationalKinetic+
+            StoredUCationRotationalKinetic)/(K_B*DegreesOfFreedomRotation[CurrentSystem]);
+      HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomFramework[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureFramework[CurrentSystem]+=2.0*StoredUHostKinetic/(K_B*DegreesOfFreedomFramework[CurrentSystem]);
+      HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]+=1.0;
+    }
+    
+    if(DegreesOfFreedomAdsorbates[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureAdsorbate[CurrentSystem]+=2.0*StoredUAdsorbateKinetic/(K_B*DegreesOfFreedomAdsorbates[CurrentSystem]);
+      HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]+=1.0;
+    }
+
+    if(DegreesOfFreedomCations[CurrentSystem]>0)
+    {
+      HybridNVEAlchStartTemperatureCation[CurrentSystem]+=2.0*StoredUCationKinetic/(K_B*DegreesOfFreedomCations[CurrentSystem]);
+      HybridNVEAlchStartTemperatureCationCount[CurrentSystem]+=1.0;
+    }
+
+    ReferenceEnergy=ConservedEnergy[CurrentSystem];
+    Drift=0.0;
+	
+    // integrated the system 'NumberOfHybridNVESteps' steps
+	for(j=0;j<RelaxationStepsAlchemicalTransformationMove;j++)
+	{
+		// evolve the system a full time-step
+		Integration();
+
+		// update the drift in the energy
+		Drift+=fabs((ConservedEnergy[CurrentSystem]-ReferenceEnergy)/ReferenceEnergy);
+	}
+  }
+  
+  // Manage registration of Alchemical work.
+  SizeAlchemicalWorkStore++;
+  IncreaseSizeAlchemicalWork();
+  AlchemicalWorkStore[SizeAlchemicalWorkStore-1] = AlchemicalWork_vdw + AlchemicalWork_elec;
+  AlchemicalWorkStore_vdw[SizeAlchemicalWorkStore-1] = AlchemicalWork_vdw;
+  AlchemicalWorkStore_elec[SizeAlchemicalWorkStore-1] = AlchemicalWork_elec;
+  
+  // Print in the output file the Alchemical work.
+  UpdateFileAlchemicalWork(SizeAlchemicalWorkStore-1, OutputOsmostatFilePtr);
+
+  // register the end temperatures
+  HybridNVEAlchDrift[CurrentSystem]+=Drift;
+  HybridNVEAlchDriftCount[CurrentSystem]+=1.0;
+  
+  if(DegreesOfFreedom[CurrentSystem]>0)
+  {
+  	HybridNVEAlchEndTemperature[CurrentSystem]+=2.0*UKinetic[CurrentSystem]/(K_B*DegreesOfFreedom[CurrentSystem]);
+  	HybridNVEAlchEndTemperatureCount[CurrentSystem]+=1.0;
   }
-  else
-   fprintf(FilePtr,"Reinsertion-in-plane move was OFF for all components\n\n");
+  
+  if(DegreesOfFreedomTranslation[CurrentSystem]>0)
+  {
+  	HybridNVEAlchEndTranslationalTemperature[CurrentSystem]+=2.0*(UHostKinetic[CurrentSystem]+
+  		UAdsorbateTranslationalKinetic[CurrentSystem]+UCationTranslationalKinetic[CurrentSystem])/
+  											(K_B*DegreesOfFreedomTranslation[CurrentSystem]);
+  	HybridNVEAlchEndTemperatureTranslationCount[CurrentSystem]+=1.0;
+  }
+  
+  if(DegreesOfFreedomRotation[CurrentSystem]>0)
+  {
+  	HybridNVEAlchEndRotationalTemperature[CurrentSystem]+=2.0*(UAdsorbateRotationalKinetic[CurrentSystem]+
+  			UCationRotationalKinetic[CurrentSystem])/(K_B*DegreesOfFreedomRotation[CurrentSystem]);
+  	HybridNVEAlchEndTemperatureRotationCount[CurrentSystem]+=1.0;
+  }
+  
+  if(DegreesOfFreedomFramework[CurrentSystem]>0)
+  {
+  	HybridNVEAlchEndTemperatureFramework[CurrentSystem]+=2.0*UHostKinetic[CurrentSystem]/(K_B*DegreesOfFreedomFramework[CurrentSystem]);
+  	HybridNVEAlchEndTemperatureFrameworkCount[CurrentSystem]+=1.0;
+  }
+  
+  if(DegreesOfFreedomAdsorbates[CurrentSystem]>0)
+  {
+  	HybridNVEAlchEndTemperatureAdsorbate[CurrentSystem]+=2.0*UAdsorbateKinetic[CurrentSystem]/(K_B*DegreesOfFreedomAdsorbates[CurrentSystem]);
+  	HybridNVEAlchEndTemperatureAdsorbateCount[CurrentSystem]+=1.0;
+  }
+  
+  if(DegreesOfFreedomCations[CurrentSystem]>0)
+  {
+  	HybridNVEAlchEndTemperatureCation[CurrentSystem]+=2.0*UCationKinetic[CurrentSystem]/(K_B*DegreesOfFreedomCations[CurrentSystem]);
+  	HybridNVEAlchEndTemperatureCationCount[CurrentSystem]+=1.0;
+  }
+
+  // restore all the energy to the Old state
+  UHostBond[CurrentSystem]=StoredUHostBond;
+  UHostUreyBradley[CurrentSystem]=StoredUHostUreyBradley;
+  UHostBend[CurrentSystem]=StoredUHostBend;
+  UHostInversionBend[CurrentSystem]=StoredUHostInversionBend;
+  UHostTorsion[CurrentSystem]=StoredUHostTorsion;
+  UHostImproperTorsion[CurrentSystem]=StoredUHostImproperTorsion;
+  UHostBondBond[CurrentSystem]=StoredUHostBondBond;
+  UHostBendBend[CurrentSystem]=StoredUHostBendBend;
+  UHostBondBend[CurrentSystem]=StoredUHostBondBend;
+  UHostBondTorsion[CurrentSystem]=StoredUHostBondTorsion;
+  UHostBendTorsion[CurrentSystem]=StoredUHostBendTorsion;
+
+  UAdsorbateBond[CurrentSystem]=StoredUAdsorbateBond;
+  UAdsorbateUreyBradley[CurrentSystem]=StoredUAdsorbateUreyBradley;
+  UAdsorbateBend[CurrentSystem]=StoredUAdsorbateBend;
+  UAdsorbateInversionBend[CurrentSystem]=StoredUAdsorbateInversionBend;
+  UAdsorbateTorsion[CurrentSystem]=StoredUAdsorbateTorsion;
+  UAdsorbateImproperTorsion[CurrentSystem]=StoredUAdsorbateImproperTorsion;
+  UAdsorbateBondBond[CurrentSystem]=StoredUAdsorbateBondBond;
+  UAdsorbateBendBend[CurrentSystem]=StoredUAdsorbateBendBend;
+  UAdsorbateBondTorsion[CurrentSystem]=StoredUAdsorbateBondTorsion;
+  UAdsorbateBondBend[CurrentSystem]=StoredUAdsorbateBondBend;
+  UAdsorbateBendTorsion[CurrentSystem]=StoredUAdsorbateBendTorsion;
+  UAdsorbateIntraVDW[CurrentSystem]=StoredUAdsorbateIntraVDW;
+  UAdsorbateIntraChargeCharge[CurrentSystem]=StoredUAdsorbateIntraChargeCharge;
+  UAdsorbateIntraChargeBondDipole[CurrentSystem]=StoredUAdsorbateIntraChargeBondDipole;
+  UAdsorbateIntraBondDipoleBondDipole[CurrentSystem]=StoredUAdsorbateIntraBondDipoleBondDipole;
+	
+  UCationBond[CurrentSystem]=StoredUCationBond;
+  UCationUreyBradley[CurrentSystem]=StoredUCationUreyBradley;
+  UCationBend[CurrentSystem]=StoredUCationBend;
+  UCationInversionBend[CurrentSystem]=StoredUCationInversionBend;
+  UCationTorsion[CurrentSystem]=StoredUCationTorsion;
+  UCationImproperTorsion[CurrentSystem]=StoredUCationImproperTorsion;
+  UCationBondBond[CurrentSystem]=StoredUCationBondBond;
+  UCationBendBend[CurrentSystem]=StoredUCationBendBend;
+  UCationBondBend[CurrentSystem]=StoredUCationBondBend;
+  UCationBondTorsion[CurrentSystem]=StoredUCationBondTorsion;
+  UCationBendTorsion[CurrentSystem]=StoredUCationBendTorsion;
+  UCationIntraVDW[CurrentSystem]=StoredUCationIntraVDW;
+  UCationIntraChargeCharge[CurrentSystem]=StoredUCationIntraChargeCharge;
+  UCationIntraChargeBondDipole[CurrentSystem]=StoredUCationIntraChargeBondDipole;
+  UCationIntraBondDipoleBondDipole[CurrentSystem]=StoredUCationIntraBondDipoleBondDipole;
+
+  UHostHost[CurrentSystem]=StoredUHostHost;
+  UHostHostVDW[CurrentSystem]=StoredUHostHostVDW;
+  UHostHostChargeChargeReal[CurrentSystem]=StoredUHostHostChargeChargeReal;
+  UHostHostChargeBondDipoleReal[CurrentSystem]=StoredUHostHostChargeBondDipoleReal;
+  UHostHostBondDipoleBondDipoleReal[CurrentSystem]=StoredUHostHostBondDipoleBondDipoleReal;
+  UHostHostChargeChargeFourier[CurrentSystem]=StoredUHostHostChargeChargeFourier;
+  UHostHostChargeBondDipoleFourier[CurrentSystem]=StoredUHostHostChargeBondDipoleFourier;
+  UHostHostBondDipoleBondDipoleFourier[CurrentSystem]=StoredUHostHostBondDipoleBondDipoleFourier;
+  UHostHostCoulomb[CurrentSystem]=StoredUHostHostCoulomb;
+	
+  UHostAdsorbate[CurrentSystem]=StoredUHostAdsorbate;
+  UHostAdsorbateVDW[CurrentSystem]=StoredUHostAdsorbateVDW;
+  UHostAdsorbateChargeChargeReal[CurrentSystem]=StoredUHostAdsorbateChargeChargeReal;
+  UHostAdsorbateChargeBondDipoleReal[CurrentSystem]=StoredUHostAdsorbateChargeBondDipoleReal;
+  UHostAdsorbateBondDipoleBondDipoleReal[CurrentSystem]=StoredUHostAdsorbateBondDipoleBondDipoleReal;
+  UHostAdsorbateChargeChargeFourier[CurrentSystem]=StoredUHostAdsorbateChargeChargeFourier;
+  UHostAdsorbateChargeBondDipoleFourier[CurrentSystem]=StoredUHostAdsorbateChargeBondDipoleFourier;
+  UHostAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]=StoredUHostAdsorbateBondDipoleBondDipoleFourier;
+  UHostAdsorbateCoulomb[CurrentSystem]=StoredUHostAdsorbateCoulomb;
+
+  UHostCation[CurrentSystem]=StoredUHostCation;
+  UHostCationVDW[CurrentSystem]=StoredUHostCationVDW;
+  UHostCationChargeChargeReal[CurrentSystem]=StoredUHostCationChargeChargeReal;
+  UHostCationChargeBondDipoleReal[CurrentSystem]=StoredUHostCationChargeBondDipoleReal;
+  UHostCationBondDipoleBondDipoleReal[CurrentSystem]=StoredUHostCationBondDipoleBondDipoleReal;
+  UHostCationChargeChargeFourier[CurrentSystem]=StoredUHostCationChargeChargeFourier;
+  UHostCationChargeBondDipoleFourier[CurrentSystem]=StoredUHostCationChargeBondDipoleFourier;
+  UHostCationBondDipoleBondDipoleFourier[CurrentSystem]=StoredUHostCationBondDipoleBondDipoleFourier;
+  UHostCationCoulomb[CurrentSystem]=StoredUHostCationCoulomb;
+	
+  UAdsorbateAdsorbate[CurrentSystem]=StoredUAdsorbateAdsorbate;
+  UAdsorbateAdsorbateVDW[CurrentSystem]=StoredUAdsorbateAdsorbateVDW;
+  UAdsorbateAdsorbateChargeChargeReal[CurrentSystem]=StoredUAdsorbateAdsorbateChargeChargeReal;
+  UAdsorbateAdsorbateChargeBondDipoleReal[CurrentSystem]=StoredUAdsorbateAdsorbateChargeBondDipoleReal;
+  UAdsorbateAdsorbateBondDipoleBondDipoleReal[CurrentSystem]=StoredUAdsorbateAdsorbateBondDipoleBondDipoleReal;
+  UAdsorbateAdsorbateChargeChargeFourier[CurrentSystem]=StoredUAdsorbateAdsorbateChargeChargeFourier;
+  UAdsorbateAdsorbateChargeBondDipoleFourier[CurrentSystem]=StoredUAdsorbateAdsorbateChargeBondDipoleFourier;
+  UAdsorbateAdsorbateBondDipoleBondDipoleFourier[CurrentSystem]=StoredUAdsorbateAdsorbateBondDipoleBondDipoleFourier;
+  UAdsorbateAdsorbateCoulomb[CurrentSystem]=StoredUAdsorbateAdsorbateCoulomb;
+	
+  UAdsorbateCation[CurrentSystem]=StoredUAdsorbateCation;
+  UAdsorbateCationVDW[CurrentSystem]=StoredUAdsorbateCationVDW;
+  UAdsorbateCationChargeChargeReal[CurrentSystem]=StoredUAdsorbateCationChargeChargeReal;
+  UAdsorbateCationChargeBondDipoleReal[CurrentSystem]=StoredUAdsorbateCationChargeBondDipoleReal;
+  UAdsorbateCationBondDipoleBondDipoleReal[CurrentSystem]=StoredUAdsorbateCationBondDipoleBondDipoleReal;
+  UAdsorbateCationChargeChargeFourier[CurrentSystem]=StoredUAdsorbateCationChargeChargeFourier;
+  UAdsorbateCationChargeBondDipoleFourier[CurrentSystem]=StoredUAdsorbateCationChargeBondDipoleFourier;
+  UAdsorbateCationBondDipoleBondDipoleFourier[CurrentSystem]=StoredUAdsorbateCationBondDipoleBondDipoleFourier;
+  UAdsorbateCationCoulomb[CurrentSystem]=StoredUAdsorbateCationCoulomb;
+	
+  UCationCation[CurrentSystem]=StoredUCationCation;
+  UCationCationVDW[CurrentSystem]=StoredUCationCationVDW;
+  UCationCationChargeChargeReal[CurrentSystem]=StoredUCationCationChargeChargeReal;
+  UCationCationChargeBondDipoleReal[CurrentSystem]=StoredUCationCationChargeBondDipoleReal;
+  UCationCationBondDipoleBondDipoleReal[CurrentSystem]=StoredUCationCationBondDipoleBondDipoleReal;
+  UCationCationChargeChargeFourier[CurrentSystem]=StoredUCationCationChargeChargeFourier;
+  UCationCationChargeBondDipoleFourier[CurrentSystem]=StoredUCationCationChargeBondDipoleFourier;
+  UCationCationBondDipoleBondDipoleFourier[CurrentSystem]=StoredUCationCationBondDipoleBondDipoleFourier;
+  UCationCationCoulomb[CurrentSystem]=StoredUCationCationCoulomb;
+  UTailCorrection[CurrentSystem]=StoredUTailCorrection;
+	
+  UHostPolarization[CurrentSystem]=UHostPolarizationStored;
+  UAdsorbatePolarization[CurrentSystem]=UHostPolarizationStored;
+  UCationPolarization[CurrentSystem]=UCationPolarizationStored;
+	
+  UHostBackPolarization[CurrentSystem]=UHostBackPolarizationStored;
+  UAdsorbateBackPolarization[CurrentSystem]=UAdsorbateBackPolarizationStored;
+  UCationBackPolarization[CurrentSystem]=UCationBackPolarizationStored;
+	
+  UTotal[CurrentSystem]=StoredUTotal;
+  UTailCorrection[CurrentSystem]=StoredUTailCorrection;
+  
+  // restore all the positions to the Old state
+  for(f1=0;f1<Framework[CurrentSystem].NumberOfFrameworks;f1++)
+    for(i=0;i<Framework[CurrentSystem].NumberOfAtoms[f1];i++)
+      Framework[CurrentSystem].Atoms[f1][i].Position=Framework[CurrentSystem].Atoms[f1][i].ReferencePosition;
+	
+	// Restore the NumberOfPseudoAtom pointer.
+	for(i=0;i<NumberOfPseudoAtoms;i++)
+	{
+	NumberOfPseudoAtomsTypeNew[i]=NumberOfPseudoAtomsReferenceTypeNew[i];
+	NumberOfPseudoAtomsTypeOld[i]=NumberOfPseudoAtomsReferenceTypeOld[i];
+	NumberOfPseudoAtomsType[CurrentSystem][i]=NumberOfPseudoAtomsReferenceType[CurrentSystem][i];
+	}  
+
+	// Retrieve the number of non-alchemed molecules.
+	int UntouchedAdsorbates=NumberOfAdsorbateMolecules[CurrentSystem]-NumberTransientMoities[CurrentAlchemicalReaction];
+	
+	// Copy the former molecule that has not been chosen for ion exchange.
+  for(m=0;m<UntouchedAdsorbates;m++)
+  {
+    Type=Adsorbates[CurrentSystem][m].Type;
+    for(i=0;i<Components[Type].NumberOfGroups;i++)
+      Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassPosition=Adsorbates[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition;
+
+    for(i=0;i<Adsorbates[CurrentSystem][m].NumberOfAtoms;i++)
+      Adsorbates[CurrentSystem][m].Atoms[i].Position=Adsorbates[CurrentSystem][m].Atoms[i].ReferencePosition; 
+  }
+
+  // Copy the former molecule candidate for the ions exchange: restore initial
+  int n;
+	
+  for(n=0;n<NumberTransientMoities[CurrentAlchemicalReaction];n++)
+  {
+		// We add the candidates molecules at the top of the pile of adsorbate.
+		m=n+UntouchedAdsorbates;
+		Type=AdsorbatesReferenceChosen[n].Type;
+		
+		// Update number of transient
+		Components[Type].NumberOfMolecules[CurrentSystem]++;
+		
+		// Update Adsorabtes
+		Adsorbates[CurrentSystem][m].Type=Type;
+		Adsorbates[CurrentSystem][m].NumberOfAtoms=AdsorbatesReferenceChosen[n].NumberOfAtoms;
+			Adsorbates[CurrentSystem][m].Atoms=(ATOM*)realloc(Adsorbates[CurrentSystem][m].Atoms,(Components[Type].NumberOfAtoms)*sizeof(ATOM));
+		if(Components[Type].NumberOfGroups>0)
+			Adsorbates[CurrentSystem][m].Groups=(GROUP*)realloc(Adsorbates[CurrentSystem][m].Groups,(Components[Type].NumberOfGroups)*sizeof(GROUP));
+		
+		for(i=0;i<Components[Type].NumberOfGroups;i++)
+		  Adsorbates[CurrentSystem][m].Groups[i]=AdsorbatesReferenceChosen[n].Groups[i];
+		
+		for(i=0;i<AdsorbatesReferenceChosen[n].NumberOfAtoms;i++)
+		  Adsorbates[CurrentSystem][m].Atoms[i]=AdsorbatesReferenceChosen[n].Atoms[i]; 
+  }
+	 
+	// The cation are not modified in the alchemical transformation.
+  for(m=0;m<NumberOfCationMolecules[CurrentSystem];m++)
+  {
+    Type=Cations[CurrentSystem][m].Type;
+    for(i=0;i<Components[Type].NumberOfGroups;i++)
+      Cations[CurrentSystem][m].Groups[i].CenterOfMassPosition=Cations[CurrentSystem][m].Groups[i].CenterOfMassReferencePosition;
+    for(i=0;i<Cations[CurrentSystem][m].NumberOfAtoms;i++)
+      Cations[CurrentSystem][m].Atoms[i].Position=Cations[CurrentSystem][m].Atoms[i].ReferencePosition;
+  }
+	// Restore the initial degrees of freedom.
+	DegreesOfFreedomAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceAdsorbates;
+	DegreesOfFreedomTranslation[CurrentSystem]=DegreesOfFreedomReferenceTranslation;
+	DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceTranslationalAdsorbates;
+	DegreesOfFreedom[CurrentSystem]=DegreesOfFreedomReference;
+								
+	DegreesOfFreedomRotation[CurrentSystem]=DegreesOfFreedomReferenceRotation;
+	DegreesOfFreedomAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceAdsorbates;
+	DegreesOfFreedomRotationalAdsorbates[CurrentSystem]=DegreesOfFreedomReferenceRotationalAdsorbates;
+
+  if((ChargeMethod==EWALD)&&(!OmitEwaldFourier))
+    RetrieveStoredEwaldStructureFactors(0,CurrentSystem);
+
+  CalculateAnisotropicSites();
+  
+  // deallocate memory
+  RemoveExtraPseudoAtoms();
+  DeallocateTransientComponentMemory();
+  DeallocateMemoryParameterTab();
+  
+  // restore the initial memory of components, pseudoatom and and other vectors.
+  DeallocateChosenMoitiesCoordinates();
+
+  // Reinitialize force and energy to recompute the good vector for fourier ewald.
+  InitializeForces();
+
+  // Let's free the used pointer.
+  free(OldComponent);
+  free(NewComponent); 
+  free(NCMCWorkStore);
+  
+  return 0;
 }
 
 
+
 // Identity-switch Monte-Carlo move in the grand-canonical ensemble (Adsorbate-version)
 // A molecule of type 'A' is randomly selected and an attempt is made to change its identity to 'B'
 // The move is called semi-grand ensemble, but is also a special case of the Gibbs ensemble.
@@ -6306,6 +7874,7 @@ int IdentityChangeAdsorbateMove(void)
   int StoredNumberOfTrialPositions;
   int StoredNumberOfTrialPositionsFirstBead;
 
+  // Trial position to reconstruct molecules
   StoredNumberOfTrialPositions=NumberOfTrialPositions;
   StoredNumberOfTrialPositionsFirstBead=NumberOfTrialPositionsForTheFirstBead;
 
@@ -6595,12 +8164,14 @@ int IdentityChangeAdsorbateMove(void)
   return 0;
 }
 
+
 // Identity-switch Monte-Carlo move in the grand-canonical ensemble (Cation-version)
 // A molecule of type 'A' is randomly selected and an attempt is made to change its identity to 'B'
 // The move is called semi-grand ensemble, but is also a special case of the Gibbs ensemble.
 // The move is called 'swotch' in original paper of M. G. Martin and J. I. Siepmann
 // JACS, 1997, 8921-8924
 
+
 int IdentityChangeCationMove(void)
 {
   int i,d;
@@ -6930,6 +8501,213 @@ void PrintIdentityChangeStatistics(FILE *FilePtr)
 }
 
 
+// Added by Ambroise de Izarra
+
+/*********************************************************************************************************
+ * Name       | PrintAlchemicalChangeStatistics     (Added by A. de Izarra)                              *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Print statistics of the alchemical transformation move			                    	 *
+ * Parameters | FILE *FilePtr => pointer to output file.												 *
+ *********************************************************************************************************/
+
+/*
+void PrintAlchemicalChangeStatistics(FILE *FilePtr)
+{
+  int i,j,MoveUsed;
+  int CurrentAlchReaction;
+
+  MoveUsed=FALSE;
+  if(AlchemicalChangeAttempts[CurrentSystem][0]>0.0)
+  {
+	  MoveUsed=TRUE;
+  }	
+
+  if(MoveUsed)
+  {
+    fprintf(FilePtr,"Performance of the alchemical transformation move:\n");
+    fprintf(FilePtr,"======================================\n");
+    for(CurrentAlchReaction=0;CurrentAlchReaction<NumberAlchemicalReactions;CurrentAlchReaction++)
+    {
+        if(AlchemicalChangeAttempts[CurrentSystem][CurrentAlchReaction]>0.0)
+        {
+          fprintf(FilePtr,"Alchemical transformation [%s]<->[%s] + [%s] ,total tried: %lf:\n",
+            Components[SolventIndex].Name,
+            Components[SaltIndex[CurrentAlchReaction][0]].Name,
+            Components[SaltIndex[CurrentAlchReaction][1]].Name,
+            (double)AlchemicalChangeAttempts[CurrentSystem][CurrentAlchReaction]);
+          
+          fprintf(FilePtr,"\tAccepted steps replacing solvent to ions: %lf (%lf [%%])\n",
+            (double)AlchemicalChangeAccepted[CurrentSystem][CurrentAlchReaction][0],
+            (double)(AlchemicalChangeAttempts[CurrentSystem][CurrentAlchReaction]>(REAL)0.0?
+              100.0*AlchemicalChangeAccepted[CurrentSystem][CurrentAlchReaction][0]/AlchemicalChangeAttempts[CurrentSystem][CurrentAlchReaction]:(REAL)0.0));
+              
+          fprintf(FilePtr,"\tAccepted steps replacing ions to solvent: %lf (%lf [%%])\n",
+            (double)AlchemicalChangeAccepted[CurrentSystem][CurrentAlchReaction][1],
+            (double)(AlchemicalChangeAttempts[CurrentSystem][CurrentAlchReaction]>(REAL)0.0?
+              100.0*AlchemicalChangeAccepted[CurrentSystem][CurrentAlchReaction][1]/AlchemicalChangeAttempts[CurrentSystem][CurrentAlchReaction]:(REAL)0.0));
+              
+          fprintf(FilePtr,"\n");
+          fprintf(FilePtr,"**************************************************************\n");
+          fprintf(FilePtr,"\n");
+		  fprintf(FilePtr,"Informations about of theNCMC move in the NVE-ensemble during alchemical transformation:\n");
+		  fprintf(FilePtr,"==============================================================\n");
+
+		  fprintf(FilePtr,"\tLambdaStepsAlchemicalTransformationMove: %18.10lf \n\n",
+            (double)((REAL)AlchReacLambda));
+            
+		  fprintf(FilePtr,"\tRelaxationStepsAlchemicalTransformationMove: %18.10lf \n\n",
+            (double)((REAL)RelaxationStepsAlchemicalTransformationMove));
+
+		  fprintf(FilePtr,"\tTotal amount of MD-time simulated: %18.10lf [ps]\n\n",
+            (double)((REAL)RelaxationStepsAlchemicalTransformationMove*(AlchReacLambda+1)*DeltaT*AlchemicalChangeAttempts[CurrentSystem][CurrentAlchemicalReaction]));
+
+		  fprintf(FilePtr,"\tAverage drift in the energy:               % 18.10lf\n\n",
+            (double)(HybridNVEAlchDrift[CurrentSystem]/HybridNVEAlchDriftCount[CurrentSystem]));
+
+		  if(HybridNVEAlchStartTemperatureCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature:               % 18.10lf\n",
+			   (double)(HybridNVEAlchStartTemperature[CurrentSystem]/HybridNVEAlchStartTemperatureCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature (translation): % 18.10lf\n",
+			   (double)(HybridNVEAlchStartTranslationalTemperature[CurrentSystem]/HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature (rotation): % 18.10lf\n",
+               (double)(HybridNVEAlchStartRotationalTemperature[CurrentSystem]/HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature framework : % 18.10lf\n",
+               (double)(HybridNVEAlchStartTemperatureFramework[CurrentSystem]/HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature adsorbates: % 18.10lf\n",
+               (double)(HybridNVEAlchStartTemperatureAdsorbate[CurrentSystem]/HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureCationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature cations: % 18.10lf\n\n",
+               (double)(HybridNVEAlchStartTemperatureCation[CurrentSystem]/HybridNVEAlchStartTemperatureCationCount[CurrentSystem]));
+
+		  if(HybridNVEAlchEndTemperatureCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature: % 18.10lf\n",
+			   (double)(HybridNVEAlchEndTemperature[CurrentSystem]/HybridNVEAlchEndTemperatureCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureTranslationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature (translation): % 18.10lf\n",
+			   (double)(HybridNVEAlchEndTranslationalTemperature[CurrentSystem]/HybridNVEAlchEndTemperatureTranslationCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureRotationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature (rotation): % 18.10lf\n",
+               (double)(HybridNVEAlchEndRotationalTemperature[CurrentSystem]/HybridNVEAlchEndTemperatureRotationCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureFrameworkCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature framework : % 18.10lf\n",
+               (double)(HybridNVEAlchEndTemperatureFramework[CurrentSystem]/HybridNVEAlchEndTemperatureFrameworkCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureAdsorbateCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature adsorbates: % 18.10lf\n",
+			   (double)(HybridNVEAlchEndTemperatureAdsorbate[CurrentSystem]/HybridNVEAlchEndTemperatureAdsorbateCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureCationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature cations: % 18.10lf\n\n",
+               (double)(HybridNVEAlchEndTemperatureCation[CurrentSystem]/HybridNVEAlchEndTemperatureCationCount[CurrentSystem]));
+		}
+    }
+    fprintf(FilePtr,"\n");
+  }
+  else
+  {
+   fprintf(FilePtr,"Alchemical transformation move was OFF in current simulation.\n\n");
+  }
+}
+*/
+
+// Added by Ambroise de Izarra
+/*********************************************************************************************************
+ * Name       | PrintwidomOsmostatStatistics     (Added by A. de Izarra)                             	 *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | Print statistics of the alchemical work calculation				                    	 *
+ * Parameters | FILE *FilePtr => pointer to output file.												 *
+ *********************************************************************************************************/
+ 
+void PrintwidomOsmostatStatistics(FILE *FilePtr)
+{
+  int i,j,MoveUsed;
+  int CurrentAlchReaction;
+
+  MoveUsed=FALSE;
+  if(WidomOsmostat[CurrentSystem][0]>0)
+  {
+	  MoveUsed=TRUE;
+  }	
+
+  if(MoveUsed)
+  {
+    fprintf(FilePtr,"Osmostat calibration move:\n");
+    fprintf(FilePtr,"======================================\n");
+    for(CurrentAlchReaction=0;CurrentAlchReaction<NumberAlchemicalReactions;CurrentAlchReaction++)
+    {
+        if(WidomOsmostat[CurrentSystem][CurrentAlchReaction]>0.0)
+        {
+          fprintf(FilePtr,"osmostat vacuum<-> 2[%s], total tried: %lf:\n",
+            Components[SolventIndex].Name,
+            (double)WidomOsmostat[CurrentSystem][CurrentAlchReaction]);
+          
+          fprintf(FilePtr,"\n");
+          fprintf(FilePtr,"**************************************************************\n");
+          fprintf(FilePtr,"\n");
+		  fprintf(FilePtr,"Informations about of the hybrid MCMD in the NVE-ensemble during osmostat calibration:\n");
+		  fprintf(FilePtr,"==============================================================\n");		  
+		  	  
+		  fprintf(FilePtr,"\tLambdaStepsAlchemicalTransformationMove: %18.10lf \n\n",
+            (double)((REAL)AlchReacLambda));
+            
+		  fprintf(FilePtr,"\tRelaxationStepsAlchemicalTransformationMove: %18.10lf \n\n",
+            (double)((REAL)RelaxationStepsAlchemicalTransformationMove));
+		  
+		  fprintf(FilePtr,"\tTotal amount of MD-time simulated: %18.10lf [ps]\n\n",
+            (double)((REAL)RelaxationStepsAlchemicalTransformationMove*(AlchReacLambda+1)*DeltaT*WidomOsmostat[CurrentSystem][CurrentAlchReaction]));
+
+		  fprintf(FilePtr,"\tAverage drift in the energy:               % 18.10lf\n\n",
+            (double)(HybridNVEAlchDrift[CurrentSystem]/HybridNVEAlchDriftCount[CurrentSystem]));
+
+		  if(HybridNVEAlchStartTemperatureCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature:               % 18.10lf\n",
+			   (double)(HybridNVEAlchStartTemperature[CurrentSystem]/HybridNVEAlchStartTemperatureCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature (translation): % 18.10lf\n",
+			   (double)(HybridNVEAlchStartTranslationalTemperature[CurrentSystem]/HybridNVEAlchStartTemperatureTranslationCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature (rotation): % 18.10lf\n",
+               (double)(HybridNVEAlchStartRotationalTemperature[CurrentSystem]/HybridNVEAlchStartTemperatureRotationCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature framework : % 18.10lf\n",
+               (double)(HybridNVEAlchStartTemperatureFramework[CurrentSystem]/HybridNVEAlchStartTemperatureFrameworkCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature adsorbates: % 18.10lf\n",
+               (double)(HybridNVEAlchStartTemperatureAdsorbate[CurrentSystem]/HybridNVEAlchStartTemperatureAdsorbateCount[CurrentSystem]));
+		  if(HybridNVEAlchStartTemperatureCationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage begin temperature cations: % 18.10lf\n\n",
+               (double)(HybridNVEAlchStartTemperatureCation[CurrentSystem]/HybridNVEAlchStartTemperatureCationCount[CurrentSystem]));
+
+		  if(HybridNVEAlchEndTemperatureCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature: % 18.10lf\n",
+			   (double)(HybridNVEAlchEndTemperature[CurrentSystem]/HybridNVEAlchEndTemperatureCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureTranslationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature (translation): % 18.10lf\n",
+			   (double)(HybridNVEAlchEndTranslationalTemperature[CurrentSystem]/HybridNVEAlchEndTemperatureTranslationCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureRotationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature (rotation): % 18.10lf\n",
+               (double)(HybridNVEAlchEndRotationalTemperature[CurrentSystem]/HybridNVEAlchEndTemperatureRotationCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureFrameworkCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature framework : % 18.10lf\n",
+               (double)(HybridNVEAlchEndTemperatureFramework[CurrentSystem]/HybridNVEAlchEndTemperatureFrameworkCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureAdsorbateCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature adsorbates: % 18.10lf\n",
+			   (double)(HybridNVEAlchEndTemperatureAdsorbate[CurrentSystem]/HybridNVEAlchEndTemperatureAdsorbateCount[CurrentSystem]));
+		  if(HybridNVEAlchEndTemperatureCationCount[CurrentSystem]>0)
+			fprintf(FilePtr,"\tAverage end temperature cations: % 18.10lf\n\n",
+               (double)(HybridNVEAlchEndTemperatureCation[CurrentSystem]/HybridNVEAlchEndTemperatureCationCount[CurrentSystem]));
+		}
+    }
+    fprintf(FilePtr,"\n");
+  }
+  else
+  {
+   fprintf(FilePtr,"Osmostat calibration was OFF in current simulation.\n\n");
+  }
+}
+
 // Swap Monte-Carlo move
 //
 //
@@ -7007,9 +8785,12 @@ int SwapAddAdsorbateMove(void)
   // get partial pressure for this component
   PartialFugacity=Components[CurrentComponent].FugacityCoefficient[CurrentSystem]*
                   Components[CurrentComponent].PartialPressure[CurrentSystem];
-
+	//printf("quantité %f %f %f\n \n \n:",Components[CurrentComponent].FugacityCoefficient[CurrentSystem],Components[CurrentComponent].PartialPressure[CurrentSystem],PartialFugacity);
   RosenbluthIdealNew=Components[CurrentComponent].IdealGasRosenbluthWeight[CurrentSystem];
 
+  //printf("%f \n ",-log(GetAverageInverseDensity())/Beta[CurrentSystem]*ENERGY_TO_KELVIN);
+  
+
   // acceptence rule
   if(RandomNumber()<((RosenbluthNew/RosenbluthIdealNew)*Beta[CurrentSystem]*PartialFugacity*Volume[CurrentSystem]/
                     (1.0+Components[CurrentComponent].NumberOfMolecules[CurrentSystem]-(Components[CurrentComponent].FractionalMolecule[CurrentSystem]>=0?1:0))))
@@ -15028,11 +16809,11 @@ void HybridNVEMove(void)
   // integrated the system 'NumberOfHybridNVESteps' steps
   for(i=0;i<NumberOfHybridNVESteps;i++)
   {
-    // evolve the system a full time-step
-    Integration();
+		// evolve the system a full time-step
+		Integration();
 
-    // update the drift in the energy
-    Drift+=fabs((ConservedEnergy[CurrentSystem]-ReferenceEnergy)/ReferenceEnergy);
+		// update the drift in the energy
+		Drift+=fabs((ConservedEnergy[CurrentSystem]-ReferenceEnergy)/ReferenceEnergy);
   }
 
   if((RandomNumber()<exp(-Beta[CurrentSystem]*(ConservedEnergy[CurrentSystem]-ReferenceEnergy)))&&(isfinite(Drift)))
@@ -30411,6 +32192,78 @@ void WriteRestartMcMoves(FILE *FilePtr)
 
   fwrite(&CFWangLandauEvery,sizeof(int),1,FilePtr);
   fwrite(&TargetAccRatioLambdaChange,sizeof(REAL),1,FilePtr);
+  
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  fwrite(&NumberAlchemicalReactions,sizeof(int),1,FilePtr);
+  if(NumberAlchemicalReactions>0)
+  {	  
+	  // Read stored NVE statistics during osmostat transformation.
+	  fwrite(HybridNVEAlchDrift,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchDriftCount,sizeof(REAL),NumberOfSystems,FilePtr);
+
+	  fwrite(HybridNVEAlchStartTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTranslationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartRotationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureFramework,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureAdsorbate,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureCation,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureTranslationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureRotationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureFrameworkCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureAdsorbateCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchStartTemperatureCationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTranslationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndRotationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureFramework,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureAdsorbate,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureCation,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureTranslationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureRotationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureFrameworkCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureAdsorbateCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fwrite(HybridNVEAlchEndTemperatureCationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+
+	  // Statistics on tried MC steps.
+	  for(i=0;i<NumberOfSystems;i++)
+	  {
+		fwrite(AlchemicalChangeAttempts[i],sizeof(REAL),NumberAlchemicalReactions,FilePtr);
+	    fwrite(AlchemicalChangeAccepted[i],sizeof(REAL[2]),NumberAlchemicalReactions,FilePtr);
+	    fwrite(WidomOsmostat[i],sizeof(REAL),NumberAlchemicalReactions,FilePtr);
+	  }
+
+	  fwrite(&AlchReacLambda,sizeof(int),1,FilePtr);
+	  fwrite(&ProbabilityAlchemicalTransformationMove,sizeof(REAL),1,FilePtr);
+	  fwrite(&ChemicalPotentialAlchemical,sizeof(REAL),1,FilePtr);
+	  fwrite(&ProbabilityWidomOsmostatCalculationMove,sizeof(REAL),1,FilePtr);
+	  fwrite(&SizeAlchemicalWorkStore,sizeof(int),1,FilePtr);
+      printf("SizeAlchemicalWorkStore: %d\n",SizeAlchemicalWorkStore);
+	  if(ProbabilityWidomOsmostatCalculationMove>0.0) 
+	  {
+			fwrite(AlchemicalWorkStore,sizeof(REAL),SizeAlchemicalWorkStore,FilePtr);
+			fwrite(AlchemicalWorkStore_vdw,sizeof(REAL),SizeAlchemicalWorkStore,FilePtr);
+			fwrite(AlchemicalWorkStore_elec,sizeof(REAL),SizeAlchemicalWorkStore,FilePtr);
+	  }
+	  
+	  fwrite(&SolventIndex,sizeof(int),1,FilePtr);
+	  fwrite(&RelaxationStepsAlchemicalTransformationMove,sizeof(int),1,FilePtr);
+
+	  for(i=0;i<NumberAlchemicalReactions;i++)
+		 fwrite(SaltIndex[i],sizeof(int),2,FilePtr);
+		 
+	  for(i=0;i<NumberAlchemicalReactions;i++)
+		 fwrite(MultiplicitySalt[i],sizeof(int),2,FilePtr);
+	  
+	  
+	  for(i=0;i<Components[SolventIndex].NumberOfGroups;i++)
+			fwrite(SolventBodyfixedPositions[i],sizeof(VECTOR),Components[SolventIndex].Groups[i].NumberOfGroupAtoms,FilePtr);
+	  
+  }
+  //-------------------------------------------------------------------
+  
 
   Check=123456789.0;
   fwrite(&Check,1,sizeof(REAL),FilePtr);
@@ -30566,6 +32419,14 @@ void AllocateMCMovesMemory(void)
   IdentityChangeAttempts=(REAL***)calloc(NumberOfSystems,sizeof(REAL**));
   IdentityChangeAccepted=(REAL(***)[2])calloc(NumberOfSystems,sizeof(REAL(**)[2]));
 
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  AlchemicalChangeAttempts = (REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+  AlchemicalChangeAccepted = (REAL(**)[2])calloc(NumberOfSystems,sizeof(REAL(*)[2]));
+
+  WidomOsmostat = (REAL**)calloc(NumberOfSystems,sizeof(REAL*));
+  //-------------------------------------------------------------------
+
   GibbsIdentityChangeAttempts=(REAL***)calloc(NumberOfSystems,sizeof(REAL**));
   GibbsIdentityChangeAccepted=(REAL(***)[2])calloc(NumberOfSystems,sizeof(REAL(**)[2]));
 
@@ -30679,6 +32540,15 @@ void AllocateMCMovesMemory(void)
     IdentityChangeAttempts[i]=(REAL**)calloc(NumberOfComponents,sizeof(REAL*));
     IdentityChangeAccepted[i]=(REAL(**)[2])calloc(NumberOfComponents,sizeof(REAL(*)[2]));
 
+	// Added by Ambroise de Izarra
+	//-------------------------------------------------------------------
+	AlchemicalChangeAttempts[i] = (REAL*)calloc(NumberAlchemicalReactions,sizeof(REAL));
+	AlchemicalChangeAccepted[i] = (REAL(*)[2])calloc(NumberAlchemicalReactions,sizeof(REAL[2]));
+
+	WidomOsmostat[i] = (REAL*)calloc(NumberAlchemicalReactions,sizeof(REAL));
+	//-------------------------------------------------------------------
+	
+	
     GibbsIdentityChangeAttempts[i]=(REAL**)calloc(NumberOfComponents,sizeof(REAL*));
     GibbsIdentityChangeAccepted[i]=(REAL(**)[2])calloc(NumberOfComponents,sizeof(REAL(*)[2]));
 
@@ -30960,7 +32830,7 @@ void ReadRestartMcMoves(FILE *FilePtr)
       for(j=0;j<NumberOfReactions;j++)
         fread(RXMCLambdaHistogram[i][j],sizeof(REAL),RXMCLambdaHistogramSize,FilePtr);
     }
-
+    
     fread(ReinsertionAttempts[i],sizeof(REAL),NumberOfComponents,FilePtr);
     fread(ReinsertionAccepted[i],sizeof(REAL[2]),NumberOfComponents,FilePtr);
 
@@ -31155,7 +33025,112 @@ void ReadRestartMcMoves(FILE *FilePtr)
   fread(&CFWangLandauEvery,sizeof(int),1,FilePtr);
   fread(&TargetAccRatioLambdaChange,sizeof(REAL),1,FilePtr);
 
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  fread(&NumberAlchemicalReactions,sizeof(int),1,FilePtr);
+  if(NumberAlchemicalReactions>0)
+  {	  
+	  InitializeNVEAlchStatistics();
+	  // Read stored NVE statistics during osmostat transformation.
+	  fread(HybridNVEAlchDrift,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchDriftCount,sizeof(REAL),NumberOfSystems,FilePtr);
+
+	  fread(HybridNVEAlchStartTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTranslationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartRotationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureFramework,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureAdsorbate,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureCation,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureTranslationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureRotationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureFrameworkCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureAdsorbateCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchStartTemperatureCationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTranslationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndRotationalTemperature,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureFramework,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureAdsorbate,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureCation,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureTranslationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureRotationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureFrameworkCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureAdsorbateCount,sizeof(REAL),NumberOfSystems,FilePtr);
+	  fread(HybridNVEAlchEndTemperatureCationCount,sizeof(REAL),NumberOfSystems,FilePtr);
+
+	  // Statistics on tried MC steps.
+	  for(i=0;i<NumberOfSystems;i++)
+	  {
+		fread(AlchemicalChangeAttempts[i],sizeof(REAL),NumberAlchemicalReactions,FilePtr);
+	    fread(AlchemicalChangeAccepted[i],sizeof(REAL[2]),NumberAlchemicalReactions,FilePtr);
+	    fread(WidomOsmostat[i],sizeof(REAL),NumberAlchemicalReactions,FilePtr);
+	  }
+  
+	  fread(&AlchReacLambda,sizeof(int),1,FilePtr);
+	  fread(&ProbabilityAlchemicalTransformationMove,sizeof(REAL),1,FilePtr);
+	  fread(&ChemicalPotentialAlchemical,sizeof(REAL),1,FilePtr);
+	  fread(&ProbabilityWidomOsmostatCalculationMove,sizeof(REAL),1,FilePtr);
+	  fread(&SizeAlchemicalWorkStore,sizeof(int),1,FilePtr);
+
+	  if(ProbabilityWidomOsmostatCalculationMove>0.0) 
+	  {
+
+		AlchemicalWorkStore=(REAL*)realloc(AlchemicalWorkStore,SizeAlchemicalWorkStore*sizeof(REAL));
+		AlchemicalWorkStore_vdw=(REAL*)realloc(AlchemicalWorkStore_vdw,SizeAlchemicalWorkStore*sizeof(REAL));
+		AlchemicalWorkStore_elec=(REAL*)realloc(AlchemicalWorkStore_elec,SizeAlchemicalWorkStore*sizeof(REAL));
+	
+		InitializeFileAlchemicalWork(SizeAlchemicalWorkStore);
+		
+	  }
+	  
+	  fread(AlchemicalWorkStore,sizeof(REAL),SizeAlchemicalWorkStore,FilePtr);
+	  fread(AlchemicalWorkStore_vdw,sizeof(REAL),SizeAlchemicalWorkStore,FilePtr);
+	  fread(AlchemicalWorkStore_elec,sizeof(REAL),SizeAlchemicalWorkStore,FilePtr);
+			
+	  fread(&SolventIndex,sizeof(int),1,FilePtr);
+	  InitializeLambda();
+	  fread(&RelaxationStepsAlchemicalTransformationMove,sizeof(int),1,FilePtr);
+
+	  SaltIndex=(int**)calloc(NumberAlchemicalReactions,sizeof(int*));
+	  for(i=0;i<NumberAlchemicalReactions;i++)
+	  {
+			SaltIndex[i]=(int*)calloc(2,sizeof(int));
+			fread(SaltIndex[i],sizeof(int),2,FilePtr);
+	  }
+	  
+	  MultiplicitySalt=(int**)calloc(NumberAlchemicalReactions,sizeof(int*));
+	  for(i=0;i<NumberAlchemicalReactions;i++)
+	  {
+			MultiplicitySalt[i]=(int*)calloc(2,sizeof(int));
+			fread(MultiplicitySalt[i],sizeof(int),2,FilePtr);
+	  }
+	  
+	  // Read the fixed relative position of the solvent molecule.
+	  SolventBodyfixedPositions=(VECTOR**)calloc(Components[SolventIndex].NumberOfGroups,sizeof(VECTOR*));
+	  for(i=0;i<Components[SolventIndex].NumberOfGroups;i++)
+	  {
+			if(Components[SolventIndex].Groups[i].NumberOfGroupAtoms>0)
+				SolventBodyfixedPositions[i]=(VECTOR*)calloc(Components[SolventIndex].Groups[i].NumberOfGroupAtoms,sizeof(VECTOR));
+			
+			fread(SolventBodyfixedPositions[i],sizeof(VECTOR),Components[SolventIndex].Groups[i].NumberOfGroupAtoms,FilePtr);
+	  }
+
+	  ChosenMoleculeAlchemicalTransformation=(int**)calloc(NumberAlchemicalReactions,sizeof(int*));
+	  NumberTransientMoities=(int*)calloc(NumberAlchemicalReactions,sizeof(int));
+	  
+	  SetUpNumberMoitiesExchangedAlchemicalReaction(); 
+
+	  // Set up vdW parameters to be evolve during Alchemical transformation.
+	  InitializeIndexManagingTransientMoities();
+	  InitializeVectorforMixingRule();
+	  InitializeVectorCharge(); 
+  }
+  //-------------------------------------------------------------------
+  
   fread(&Check,1,sizeof(REAL),FilePtr);
+	 
   if(fabs(Check-123456789.0)>1e-10)
   {
     fprintf(stderr, "Error in binary restart-file (ReadRestartMcMoves)\n");
@@ -31163,3 +33138,4 @@ void ReadRestartMcMoves(FILE *FilePtr)
   }
 }
 
+ 
diff --git a/src/mc_moves.h b/src/mc_moves.h
index 555d776..dadef33 100644
--- a/src/mc_moves.h
+++ b/src/mc_moves.h
@@ -40,6 +40,21 @@
 #include "input.h"
 
 // delta energies
+// Modified by Ambroise de Izarra
+//-------------------------------------------------------------------
+// switched from static to extern for use in alchemical transformation.
+extern REAL UDeltaPolarization;
+extern REAL *UHostPolarizationNew;
+extern REAL *UAdsorbatePolarizationNew;
+extern REAL *UCationPolarizationNew;
+extern REAL *UPolarizationNew;
+
+extern REAL *UHostBackPolarizationNew;
+extern REAL *UAdsorbateBackPolarizationNew;
+extern REAL *UCationBackPolarizationNew;
+extern REAL *UBackPolarizationNew;
+//-------------------------------------------------------------------
+
 extern REAL *UHostVDWDelta;
 extern REAL *UHostChargeChargeRealDelta;
 extern REAL *UHostChargeBondDipoleRealDelta;
@@ -94,6 +109,9 @@ extern int NumberOfHybridNVESteps;
 extern int NumberOfHybridNPHSteps;
 extern int NumberOfHybridNPHPRSteps;
 
+
+//----------------------------------------------------------------------------------------
+
 //----------------------------------------------------------------------------------------
 // CFC-RXMC Parameters
 //----------------------------------------------------------------------------------------
@@ -149,6 +167,11 @@ int ReinsertionAdsorbateMove(void);
 int ReinsertionInPlaceAdsorbateMove(void);
 int ReinsertionInPlaneAdsorbateMove(void);
 int IdentityChangeAdsorbateMove(void);
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+//int AlchemicalChangeAdsorbateMove(void);
+int WidomOsmostatCalculation(void);
+//-------------------------------------------------------------------
 int PartialReinsertionAdsorbateMove(void);
 
 void OptimizeTranslationAcceptence(void);
@@ -198,6 +221,18 @@ void PrintPartialReinsertionStatistics(FILE *FilePtr);
 void PrintIdentityChangeStatistics(FILE *FilePtr);
 void PrintParallelTemperingStatistics(FILE *FilePtr);
 void PrintHyperParallelTemperingStatistics(FILE *FilePtr);
+
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+void PrintAlchemicalChangeStatistics(FILE *FilePtr);
+void PrintwidomOsmostatStatistics(FILE *FilePtr);
+
+extern REAL **AlchemicalChangeAttempts;
+extern REAL (**AlchemicalChangeAccepted)[2];
+
+extern REAL **WidomOsmostat;
+//-------------------------------------------------------------------
+
 void PrintParallelMolFractionStatistics(FILE *FilePtr);
 void PrintChiralInversionStatistics(FILE *FilePtr);
 void PrintVolumeChangeStatistics(FILE *FilePtr);
@@ -265,4 +300,5 @@ void WriteRestartMcMoves(FILE *FilePtr);
 void AllocateMCMovesMemory(void);
 void ReadRestartMcMoves(FILE *FilePtr);
 
+
 #endif
diff --git a/src/molecule.c b/src/molecule.c
index 7b9a144..ba766ab 100644
--- a/src/molecule.c
+++ b/src/molecule.c
@@ -50,6 +50,7 @@
 #include "mc_moves.h"
 #include "ewald.h"
 #include "thermo_baro_stats.h"
+#include "Alchemical_transformation.h"
 #include "integration.h"
 #include "scattering_factors.h"
 #include "input.h"
@@ -398,8 +399,160 @@ int IsFractionalReactionCationMolecule(int m)
   return FALSE;
 }
 
+// Added by Ambroise de Izarra
+
+/*********************************************************************************************************
+ * Name       | SelectRandomMoleculeAlchemicalTransformation   (Added by A. de Izarra)                   *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | This function select randomly a set of candidate molecules to be alchemically			 *
+ * 			  | transformed.                     						 								 *
+ * Parameters | int * OldComponent => List of old component index										 *
+ * 			  | int NumberSpecies => if NumberSpecies=1, water is chosen, otherwise ions are chosen.	 *
+ * 			  | int CurrentAlchemicalReaction => index of AlchemicalReaction (always = 0 in this version *
+ *********************************************************************************************************/
+void SelectRandomMoleculeAlchemicalTransformation(int * OldComponent, int NumberSpecies, int CurrentAlchemicalReaction)
+{
+	int i,j,d;
+	int SameIndexPicked;
+	int count,CurrentMolecule;
+	int species;
+	int TotalSaltIon;
+	int index1,index2;
+	
+	// We now it is water to be exchanged
+	if(NumberSpecies == 1)
+	{
+		do{
+			
+			// pick the index of water required
+			for(i=0;i<NumberTransientMoities[CurrentAlchemicalReaction];i++)
+			{
+				ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][i] = (int)(RandomNumber()*Components[OldComponent[0]].NumberOfMolecules[CurrentSystem]);
+			}
+
+			// Test if all molecule index are differents.
+			for(i=0;i<NumberTransientMoities[CurrentAlchemicalReaction];i++)
+			{
+				for(j=0;j<NumberTransientMoities[CurrentAlchemicalReaction];j++)
+				{
+					if(i!=j)
+					{
+						if(ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][i] == ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][j])
+						{
+							SameIndexPicked = 1;
+							goto here;
+						}
+						else
+						{
+							SameIndexPicked = 0;
+						}
+					}
+				}
+			}
+			here:;
+		
+		}while(SameIndexPicked==1);
+		
+		for(i=0;i<NumberTransientMoities[CurrentAlchemicalReaction];i++)
+		{
+			count=-1;
+			CurrentMolecule=-1;
+			do   // search for n-th molecule of the right type
+			{
+			  CurrentMolecule++;
+			  if((Adsorbates[CurrentSystem][CurrentMolecule].Type==OldComponent[0])) count++;
+			}
+			while(ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][i]!=count);
+			
+			// index molecule to be outputed.
+			ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][i] = CurrentMolecule;
+		}
+	}
+	else
+	{
+		
+		do{
+			TotalSaltIon=0;
+			// pick the index salt ions.
+			for(species=0; species<NumberSpecies; species++)
+			{
+				for(i=0;i<MultiplicitySalt[CurrentAlchemicalReaction][species];i++)
+				{
+					ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][TotalSaltIon] = (int)(RandomNumber()*Components[OldComponent[species]].NumberOfMolecules[CurrentSystem]);					
+					TotalSaltIon++;
+					
+				}
+			}
+			
+			index1=-1; 
+			index2=-1;
+			
+			//If there is only one cation and one anion, no need to check if two indexes are same within picked anions, and separately within picked cations.
+			// otherwise we need to make the test with the else
+			if(TotalSaltIon == 2)
+			{
+				SameIndexPicked = 0;
+			}
+			else
+			{
+				// Test if all molecule index are differents within cation and anions.
+				for(species=0; species<NumberSpecies; species++)
+				{
+					for(i=0;i<MultiplicitySalt[CurrentAlchemicalReaction][species];i++)
+					{
+						index1++;
+						
+						for(j=0;j<MultiplicitySalt[CurrentAlchemicalReaction][species];j++)
+						{
+							index2++;
+				
+							if(index1!=index2)
+							{
+								if(ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][index1] == ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][index2])
+								{
+									SameIndexPicked = 1;
+									goto here2;
+								}
+								else
+								{
+									SameIndexPicked = 0;
+								}
+							}
+						}
+					}
+				}
+				
+				here2:;
+			}
+		}while(SameIndexPicked==1);
+		
+		TotalSaltIon=0;
+
+		for(species=0; species<NumberSpecies; species++)
+		{
+			for(i=0;i<MultiplicitySalt[CurrentAlchemicalReaction][species];i++)
+			{
+				count=-1;
+				CurrentMolecule=-1;
+				do   // search for n-th molecule of the right type
+				{
+					CurrentMolecule++;
+					if((Adsorbates[CurrentSystem][CurrentMolecule].Type==OldComponent[species])) count++;
+				}
+				while(ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][TotalSaltIon]!=count);
+			
+				// index molecule to be outputed.
+				ChosenMoleculeAlchemicalTransformation[CurrentAlchemicalReaction][TotalSaltIon] = CurrentMolecule;
+				TotalSaltIon++;
+			}
+		}
+	}	
+}
+
+
 int SelectRandomMoleculeOfTypeExcludingFractionalMolecule(int comp)
 {
+
   int d,count;
   int CurrentMolecule;
 
@@ -803,14 +956,14 @@ void ReadPseudoAtomsDefinitions(void)
 }
 
 void ComputeInertiaTensorGroups(int comp)
-{
+{		
   int j,k,ill;
   REAL Mass,TotalMass,rotxyz,temp,rotall,rotlim;
   VECTOR com,pos;
   REAL_MATRIX3x3 eigenvectors;
   VECTOR eigenvalues,dr;
   int atom_nr;
-
+  
   for(j=0;j<Components[comp].NumberOfGroups;j++)
   {
     TotalMass=0.0;
@@ -859,10 +1012,16 @@ void ComputeInertiaTensorGroups(int comp)
 
     // the local body frame is taken to be that in which the rotational inertia tensor is diagonal
     EigenSystem3x3(Components[comp].Groups[j].InertiaTensor,&eigenvectors,&eigenvalues);
-
     Components[comp].Groups[j].InertiaVector.x=0.0;
     Components[comp].Groups[j].InertiaVector.y=0.0;
-    Components[comp].Groups[j].InertiaVector.z=0.0;
+    Components[comp].Groups[j].InertiaVector.z=0.0;          
+    /*if(comp==3)
+	  {
+	 		int A=Components[3].Groups[0].Atoms[0];	 
+			printf("inertiaComponents[3].Positions[A].y : %lf \n",Components[3].Positions[A].y);
+			printf("\n"); 
+	  }
+	*/
     for(k=0;k<Components[comp].Groups[j].NumberOfGroupAtoms;k++)
     {
       atom_nr=Components[comp].Groups[j].Atoms[k];
@@ -876,7 +1035,6 @@ void ComputeInertiaTensorGroups(int comp)
       if(fabs(pos.y)<1e-8) pos.y=0.0;
       if(fabs(pos.z)<1e-8) pos.z=0.0;
       Components[comp].Positions[atom_nr]=pos;
-
       atom_nr=Components[comp].Groups[j].Atoms[k];
       Mass=PseudoAtoms[Components[comp].Type[atom_nr]].Mass;
       Components[comp].Groups[j].InertiaVector.x+=Mass*(SQR(pos.y)+SQR(pos.z));
@@ -1132,12 +1290,61 @@ void ComputeInertiaTensorGroups(int comp)
         break;
     }
   }
+}
 
+// Added by Ambroise de Izarra
+/*********************************************************************************************************
+ * Name       | SetUpNumberMoitiesExchangedAlchemicalReaction   (Added by A. de Izarra)                  *
+ * ----------------------------------------------------------------------------------------------------- *
+ * Function   | This function manage number of molecules to be transformed depending of the				 *
+ * 			  | charge of the cation and the anion.                  						 			 *
+ * Parameters | No parameters																			 *
+ *********************************************************************************************************/
+void SetUpNumberMoitiesExchangedAlchemicalReaction(void)
+{
+	// This is used to determine ratio of salt ions, depending of their charge.
+	REAL charge_salt_absolute_value[2]= {0.0,0.0};
+	REAL Total_charge = 0.0;
+	
+	int CurrentAlchReaction,i,j;
+	  
+	for(CurrentAlchReaction=0;CurrentAlchReaction<NumberAlchemicalReactions;CurrentAlchReaction++)
+	{
+		NumberTransientMoities[CurrentAlchReaction] = 0;
+		  
+		// Read over salt
+		for(i=0;i<2;i++)
+		{	 
+			// This is one atom for salt ions.
+			for(j=0;j<Components[SaltIndex[CurrentAlchReaction][i]].NumberOfAtoms;j++)
+			{
+				NumberTransientMoities[CurrentAlchReaction] += 1;
+				charge_salt_absolute_value[i] = 1;
+			}
+		}
+		
+		// Initialize the vector to store index of chosen molecule to be replaced in the MC-move.
+		ChosenMoleculeAlchemicalTransformation[CurrentAlchReaction] = (int*)calloc(NumberTransientMoities[CurrentAlchReaction],sizeof(int));
+		
+		// Set up charge multiplicity to take account of ion ratio if charge differ from cation and anion.
+		if(charge_salt_absolute_value[0] == charge_salt_absolute_value[1])
+		{
+			MultiplicitySalt[CurrentAlchReaction][0] = 1;
+			MultiplicitySalt[CurrentAlchReaction][1] = 1;
+		}
+		else 
+		{
+			MultiplicitySalt[CurrentAlchReaction][0] = (int)(charge_salt_absolute_value[1]);
+			MultiplicitySalt[CurrentAlchReaction][1] = (int)(charge_salt_absolute_value[0]);
+		}
+	
+		// Test if charge is well defined.	
+	}
 }
 
 // Read the definition of the comp-th Component of Type "Name"
 void ReadComponentDefinition(int comp)
-{
+{	
   int i,j,k,n,nr;
   int A,B,C,D,temp;
   int A1,A2,B1,B2,C1,C2;
@@ -1205,7 +1412,7 @@ void ReadComponentDefinition(int comp)
            Components[comp].NumberOfAtoms);
     exit(0);
   }
-
+  
   // allocate charility-centers
   Components[comp].Chirality=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
   Components[comp].ChiralityType=(int*)calloc(Components[comp].NumberOfAtoms,sizeof(int));
@@ -1337,11 +1544,17 @@ void ReadComponentDefinition(int comp)
   }
 
   total_mass=0.0;
+  
+   // Added by Ambroise de Izarra
+   //-------------------------------------------------------------------
+  if(comp==SolventIndex)
+	SolventBodyfixedPositions=(VECTOR**)calloc(Components[comp].NumberOfGroups,sizeof(VECTOR*));
+  //-------------------------------------------------------------------
+  
   for(i=0;i<Components[comp].NumberOfGroups;i++)
   {
     ReadLine(line,1024,FilePtr);  // skip line
-
-
+    
     ReadLine(line,1024,FilePtr);
     sscanf(line,"%s",buffer);
     if(strcasecmp("rigid",buffer)==0)
@@ -1375,6 +1588,13 @@ void ReadComponentDefinition(int comp)
     {
       ReadLine(line,1024,FilePtr);  // skip line
       Components[comp].Groups[i].Atoms=(int*)calloc(Components[comp].Groups[i].NumberOfGroupAtoms,sizeof(int));
+      
+      // Added by Ambroise de Izarra
+      //-------------------------------------------------------------------
+	  if(comp==SolventIndex)
+		SolventBodyfixedPositions[i]=(VECTOR*)calloc(Components[comp].Groups[i].NumberOfGroupAtoms,sizeof(VECTOR));
+      //-------------------------------------------------------------------
+      
       for(j=0;j<Components[comp].Groups[i].NumberOfGroupAtoms;j++)
       {
         temp1=temp2=temp3=0.0;
@@ -1392,6 +1612,14 @@ void ReadComponentDefinition(int comp)
         pos.y=(REAL)temp2;
         pos.z=(REAL)temp3;
 
+		
+		// Added by Ambroise de Izarra
+		//-------------------------------------------------------------------
+		if(comp==SolventIndex)
+		{
+		  SolventBodyfixedPositions[i][j]=pos;
+		}
+		//-------------------------------------------------------------------
         k=ReturnPseudoAtomNumber(buffer);
         Components[comp].Type[temp]=k;
         mass+=PseudoAtoms[k].Mass;
@@ -1402,7 +1630,7 @@ void ReadComponentDefinition(int comp)
         Components[comp].Groups[i].Atoms[j]=temp;
       }
     }
-
+    	 		
     if(Components[comp].Groups[i].NumberOfPermanentDipoles>0)
     {
       ReadLine(line,1024,FilePtr);  // skip line
@@ -1456,11 +1684,17 @@ void ReadComponentDefinition(int comp)
     Components[comp].Groups[i].Mass=0.0;
     for(j=0;j<Components[comp].Groups[i].NumberOfGroupAtoms;j++)
     {
+	  
       A=Components[comp].Groups[i].Atoms[j];
       Components[comp].Groups[i].Mass+=PseudoAtoms[Components[comp].Type[A]].Mass;
     }
   }
 
+  //pos=Components[Type].Positions[A];
+  //printf("Components[3].Positions[A].y : %lf \n",Components[0].Positions[0].y);
+  //printf("Components[3].Positions[A].y : %lf \n",Components[0].Positions[1].y);
+  //printf("Components[3].Positions[A].y : %lf \n",Components[0].Positions[2].y);
+  //printf("Components[3].Positions[A].y : %lf \n",Components[0].Positions[3].y);
 
   ComputeInertiaTensorGroups(comp);
 
@@ -2917,7 +3151,6 @@ void ReadComponentDefinition(int comp)
     }
   }
 
-
   if(Components[comp].NumberOfIntraBondDipoleBondDipole>0)
   {
     ReadLine(line,1024,FilePtr); // skip line
@@ -3112,6 +3345,92 @@ void ReadComponentDefinition(int comp)
   fclose(FilePtr);
 }
 
+void InsertAdsorbateAlchMolecule(void)
+{
+  int i,type,nr_atoms;
+  int NewMolecule;
+
+  // add the number of atoms
+  nr_atoms=Components[CurrentComponent].NumberOfAtoms;
+  NumberOfAtomsPerSystem[CurrentSystem]+=nr_atoms;
+  NumberOfChargesPerSystem[CurrentSystem]+=Components[CurrentComponent].NumberOfCharges;
+  NumberOfBondDipolesPerSystem[CurrentSystem]+=Components[CurrentComponent].NumberOfBondDipoles;
+
+  // update the number of adsorbate molecules
+  NumberOfAdsorbateMolecules[CurrentSystem]++;
+  Components[CurrentComponent].NumberOfMolecules[CurrentSystem]++;
+
+  // add the new data at the last newly created element
+  NewMolecule=NumberOfAdsorbateMolecules[CurrentSystem]-1;
+  Adsorbates[CurrentSystem][NewMolecule].NumberOfAtoms=nr_atoms;
+  Adsorbates[CurrentSystem][NewMolecule].Type=CurrentComponent;
+
+  // allocate the meory for the atoms and groups
+  Adsorbates[CurrentSystem][NewMolecule].Atoms=(ATOM*)calloc(nr_atoms,sizeof(ATOM));
+  if(Components[CurrentComponent].NumberOfGroups>0)
+    Adsorbates[CurrentSystem][NewMolecule].Groups=(GROUP*)calloc(Components[CurrentComponent].NumberOfGroups,sizeof(GROUP));
+
+  // copy the grown positions etc to the current element
+  for(i=0;i<nr_atoms;i++)
+  {
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Position=NewPosition[CurrentSystem][i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].AnisotropicPosition=TrialAnisotropicPosition[CurrentSystem][i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Velocity=NewVelocity[CurrentSystem][i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Force=NewForce[CurrentSystem][i];
+
+    // new Continuous-Fraction scaling factors are taken from the component-information
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].CFVDWScalingParameter=CFVDWScaling[i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].CFChargeScalingParameter=CFChargeScaling[i];
+
+    type=Components[CurrentComponent].Type[i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Type=type;
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Fixed.x=Components[CurrentComponent].Fixed[i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Fixed.y=Components[CurrentComponent].Fixed[i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Fixed.z=Components[CurrentComponent].Fixed[i];
+    Adsorbates[CurrentSystem][NewMolecule].Atoms[i].Charge=Components[CurrentComponent].Charge[i];
+    NumberOfPseudoAtomsType[CurrentSystem][type]++;
+  }
+
+  // update the center of mass
+  UpdateGroupCenterOfMassAdsorbate(NewMolecule);
+
+  // compute the quaternion (orientation) from the positions
+  ComputeQuaternionAdsorbate(NewMolecule);
+
+  // initialize the velocities
+  InitializeVelocityAdsorbate(NewMolecule);
+
+  // modify the degrees of freedom
+  for(i=0;i<Components[CurrentComponent].NumberOfGroups;i++)
+  {
+    if(Components[CurrentComponent].Groups[i].Rigid)
+    {
+	  DegreesOfFreedomAdsorbates[CurrentSystem]+=3;
+      DegreesOfFreedomTranslation[CurrentSystem]+=3;
+      DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]+=3;
+      DegreesOfFreedom[CurrentSystem]+=3;
+                                  
+      DegreesOfFreedomRotation[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
+      DegreesOfFreedomAdsorbates[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
+      DegreesOfFreedomRotationalAdsorbates[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
+      DegreesOfFreedom[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
+    }
+    else
+    {
+      DegreesOfFreedomTranslation[CurrentSystem]+=3*Components[CurrentComponent].Groups[i].NumberOfGroupAtoms;
+      DegreesOfFreedomAdsorbates[CurrentSystem]+=3*Components[CurrentComponent].Groups[i].NumberOfGroupAtoms;
+      DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]+=3*Components[CurrentComponent].Groups[i].NumberOfGroupAtoms;
+      DegreesOfFreedom[CurrentSystem]+=3*Components[CurrentComponent].Groups[i].NumberOfGroupAtoms;
+    }
+  }
+// reinitialize the Nose-Hoover internal variables based on the current number of molecules for MuPT, MuPTPR and MuVT ensembles 
+  if((Ensemble[CurrentSystem]==MuPT)||(Ensemble[CurrentSystem]==MuPTPR)||(Ensemble[CurrentSystem]==MuVT))
+  {
+    InitializeNoseHooverCurrentSystem();
+  }
+}
+
+
 void InsertAdsorbateMolecule(void)
 {
   int i,type,nr_atoms;
@@ -3134,6 +3453,7 @@ void InsertAdsorbateMolecule(void)
 
   // if the number is largest than the currently allocated memory reallocate the memory for Ewald
   // the hard-coded default here is to extend the arrays with 256 atoms
+  
   if(LargestNumberOfCoulombicSites>=MaxNumberOfCoulombicSites)
   {
     MaxNumberOfCoulombicSites+=MAX2(MaxNumberOfBeads,512);
@@ -3210,11 +3530,11 @@ void InsertAdsorbateMolecule(void)
   {
     if(Components[CurrentComponent].Groups[i].Rigid)
     {
-      DegreesOfFreedomAdsorbates[CurrentSystem]+=3;
+	  DegreesOfFreedomAdsorbates[CurrentSystem]+=3;
       DegreesOfFreedomTranslation[CurrentSystem]+=3;
       DegreesOfFreedomTranslationalAdsorbates[CurrentSystem]+=3;
       DegreesOfFreedom[CurrentSystem]+=3;
-
+                                  
       DegreesOfFreedomRotation[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
       DegreesOfFreedomAdsorbates[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
       DegreesOfFreedomRotationalAdsorbates[CurrentSystem]+=Components[CurrentComponent].Groups[i].RotationalDegreesOfFreedom;
@@ -3238,7 +3558,7 @@ void InsertAdsorbateMolecule(void)
 void RemoveAdsorbateMolecule(void)
 {
   int i,j,k,type,nr_atoms;
-  int LastMolecule;
+  int LastMolecule;	
 
   // remove the the amount of atoms from the total
   nr_atoms=Components[CurrentComponent].NumberOfAtoms;
@@ -3261,6 +3581,8 @@ void RemoveAdsorbateMolecule(void)
   Adsorbates[CurrentSystem][LastMolecule].Atoms=NULL;
   Adsorbates[CurrentSystem][LastMolecule].Groups=NULL;
 
+
+
   // decrease the molecule counters
   NumberOfAdsorbateMolecules[CurrentSystem]--;
   Components[CurrentComponent].NumberOfMolecules[CurrentSystem]--;
@@ -3599,7 +3921,9 @@ void RescaleComponentProbabilities(void)
             ProbabilityGibbsVolumeChangeMove+
             ProbabilityFrameworkChangeMove+
             ProbabilityFrameworkShiftMove+
-            ProbabilityCFCRXMCLambdaChangeMove;
+            ProbabilityCFCRXMCLambdaChangeMove+
+            ProbabilityAlchemicalTransformationMove+
+            ProbabilityWidomOsmostatCalculationMove; // <- Added by Ambroise de Izarra
 
     Components[i].ProbabilityRandomTranslationMove+=Components[i].ProbabilityTranslationMove;
     Components[i].ProbabilityRotationMove+=Components[i].ProbabilityRandomTranslationMove;
@@ -3631,6 +3955,11 @@ void RescaleComponentProbabilities(void)
     Components[i].ProbabilityParallelMolFractionMove=ProbabilityParallelMolFractionMove+Components[i].ProbabilityHyperParallelTemperingMove;
     Components[i].ProbabilityChiralInversionMove=ProbabilityChiralInversionMove+Components[i].ProbabilityParallelMolFractionMove;
     Components[i].ProbabilityHybridNVEMove=ProbabilityHybridNVEMove+Components[i].ProbabilityChiralInversionMove;
+    // Added by Ambroise de Izarra
+    //-------------------------------------------------------------------
+    Components[i].ProbabilityAlchemicalTransformationMove=ProbabilityAlchemicalTransformationMove+Components[i].ProbabilityHybridNVEMove;
+    Components[i].ProbabilityWidomOsmostatCalculationMove=ProbabilityWidomOsmostatCalculationMove+Components[i].ProbabilityAlchemicalTransformationMove;
+    //-------------------------------------------------------------------
     Components[i].ProbabilityHybridNPHMove=ProbabilityHybridNPHMove+Components[i].ProbabilityHybridNVEMove;
     Components[i].ProbabilityHybridNPHPRMove=ProbabilityHybridNPHPRMove+Components[i].ProbabilityHybridNPHMove;
     Components[i].ProbabilityVolumeChangeMove=ProbabilityVolumeChangeMove+Components[i].ProbabilityHybridNPHPRMove;
@@ -3640,6 +3969,7 @@ void RescaleComponentProbabilities(void)
     Components[i].ProbabilityFrameworkShiftMove=ProbabilityFrameworkShiftMove+Components[i].ProbabilityFrameworkChangeMove;
     Components[i].ProbabilityCFCRXMCLambdaChangeMove=ProbabilityCFCRXMCLambdaChangeMove+Components[i].ProbabilityFrameworkShiftMove;
 
+
     if(TotProb>1e-5)
     {
       Components[i].ProbabilityTranslationMove/=TotProb;
@@ -3672,6 +4002,11 @@ void RescaleComponentProbabilities(void)
       Components[i].ProbabilityParallelMolFractionMove/=TotProb;
       Components[i].ProbabilityChiralInversionMove/=TotProb;
       Components[i].ProbabilityHybridNVEMove/=TotProb;
+      // Added by Ambroise de Izarra
+      //-------------------------------------------------------------------
+      Components[i].ProbabilityAlchemicalTransformationMove/=TotProb;
+      Components[i].ProbabilityWidomOsmostatCalculationMove/=TotProb;
+      //-------------------------------------------------------------------
       Components[i].ProbabilityHybridNPHMove/=TotProb;
       Components[i].ProbabilityHybridNPHPRMove/=TotProb;
       Components[i].ProbabilityVolumeChangeMove/=TotProb;
@@ -3681,7 +4016,9 @@ void RescaleComponentProbabilities(void)
       Components[i].ProbabilityFrameworkShiftMove/=TotProb;
       Components[i].ProbabilityCFCRXMCLambdaChangeMove/=TotProb;
     }
-
+    
+    
+    
     Components[i].FractionOfTranslationMove=Components[i].ProbabilityTranslationMove;
     Components[i].FractionOfRandomTranslationMove=Components[i].ProbabilityRandomTranslationMove-Components[i].ProbabilityTranslationMove;
     Components[i].FractionOfRotationMove=Components[i].ProbabilityRotationMove-Components[i].ProbabilityRandomTranslationMove;
@@ -3721,6 +4058,7 @@ void RescaleComponentProbabilities(void)
     Components[i].FractionOfFrameworkChangeMove=Components[i].ProbabilityFrameworkChangeMove-Components[i].ProbabilityGibbsVolumeChangeMove;
     Components[i].FractionOfFrameworkShiftMove=Components[i].ProbabilityFrameworkShiftMove-Components[i].ProbabilityFrameworkChangeMove;
     Components[i].FractionOfCFCRXMCLambdaChangeMove=Components[i].ProbabilityCFCRXMCLambdaChangeMove-Components[i].ProbabilityFrameworkShiftMove;
+		
   }
 }
 
@@ -4596,6 +4934,7 @@ void InitializeVelocityAdsorbate(int m)
   const int max_iter=5000;
 
   Type=Adsorbates[CurrentSystem][m].Type;
+
   for(l=0;l<Components[Type].NumberOfGroups;l++)
   {
     if(Components[Type].Groups[l].Rigid)
@@ -4649,7 +4988,7 @@ void InitializeVelocityAdsorbate(int m)
 
         MassA=PseudoAtoms[Components[Type].Type[A]].Mass;
         MassB=PseudoAtoms[Components[Type].Type[B]].Mass;
-
+		
         velA=Adsorbates[CurrentSystem][m].Atoms[A].Velocity;
         velB=Adsorbates[CurrentSystem][m].Atoms[B].Velocity;
 
@@ -5494,7 +5833,7 @@ void CalculateAnisotropicSites(void)
       Framework[CurrentSystem].Atoms[f1][i].AnisotropicPosition=posA;
     }
   }
-
+ 
   for(i=0;i<NumberOfAdsorbateMolecules[CurrentSystem];i++)
   {
     TypeMolA=Adsorbates[CurrentSystem][i].Type;
@@ -6173,6 +6512,11 @@ void PrintCPUStatistics(FILE *FilePtr)
   REAL CpuTimeCFGibbsSwapFractionalMoleculeToOtherBoxMove,CpuTimeCFGibbsLambdaChangeMove,CpuTimeCFGibbsFractionalToIntegerMove;
   REAL CpuTimeParallelTemperingMoveTotal,CpuTimeHyperParallelTemperingMoveTotal,CpuTimeParallelMolFractionMoveTotal;
   REAL CpuTimeChiralInversionMoveTotal,CpuTimeHybridNVEMoveTotal,CpuTimeHybridNPHMoveTotal;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  REAL CpuTimeAlchemicalChangeMoveTotal;
+  REAL CpuTimeWidomOsmostatChangeMoveTotal;
+  //-------------------------------------------------------------------
   REAL CpuTimeHybridNPHPRMoveTotal,CpuTimeVolumeChangeMoveTotal,CpuTimeBoxShapeChangeMoveTotal;
   REAL CpuTimeGibbsVolumeChangeMoveTotal,CpuTimeFrameworkChangeMoveTotal,CpuTimeFrameworkShiftMoveTotal;
   REAL CpuTimeCFCRXMCLambdaChangeMoveTotal;
@@ -6302,6 +6646,11 @@ void PrintCPUStatistics(FILE *FilePtr)
   fprintf(FilePtr,"\tmol-fraction replica-exchange: %18.10g [s]\n",CpuTimeParallelMolFractionMove[CurrentSystem]);
   fprintf(FilePtr,"\tchiral inversion:              %18.10g [s]\n",CpuTimeChiralInversionMove[CurrentSystem]);
   fprintf(FilePtr,"\thybrid MC/MD (NVE):            %18.10g [s]\n",CpuTimeHybridNVEMove[CurrentSystem]);
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  fprintf(FilePtr,"\talchemical transformation:     %18.10g [s]\n",CpuTimeAlchemicalChangeMove[CurrentSystem]);
+  fprintf(FilePtr,"\twidom osmostat:                %18.10g [s]\n",CpuTimeWidomOsmostatChangeMove[CurrentSystem]);
+  //-------------------------------------------------------------------
   fprintf(FilePtr,"\thybrid MC/MD (NPH):            %18.10g [s]\n",CpuTimeHybridNPHMove[CurrentSystem]);
   fprintf(FilePtr,"\thybrid MC/MD (NPHPR):          %18.10g [s]\n",CpuTimeHybridNPHPRMove[CurrentSystem]);
   fprintf(FilePtr,"\tvolume change:                 %18.10g [s]\n",CpuTimeVolumeChangeMove[CurrentSystem]);
@@ -6395,7 +6744,7 @@ void PrintCPUStatistics(FILE *FilePtr)
   fprintf(FilePtr,"\tGibbs particle transform:           %18.10g [s]\n",CpuTimeGibbsChangeMove);
   fprintf(FilePtr,"\tGibbs particle transform (CFMC):    %18.10g [s]\n",CpuTimeCFGibbsChangeMove);
   fprintf(FilePtr,"\tGibbs particle transform (CB/CFMC): %18.10g [s]\n",CpuTimeCBCFGibbsChangeMove);
-  fprintf(FilePtr,"\tGibbs indentity change:             %18.10g [s]\n",CpuTimeGibbsIdentityChangeMove);
+  fprintf(FilePtr,"\tGibbs identity change:              %18.10g [s]\n",CpuTimeGibbsIdentityChangeMove);
   fprintf(FilePtr,"\tExchange frac./int. particle:       %18.10g [s]\n",CpuTimeExchangeFractionalParticleMove);
   fprintf(FilePtr,"\tSwap Gibbs-fractional molecules:    %18.10g [s]\n",CpuTimeCFGibbsSwapFractionalMoleculeToOtherBoxMove);
   fprintf(FilePtr,"\tChange Gibs-lambda value:           %18.10g [s]\n",CpuTimeCFGibbsLambdaChangeMove);
@@ -6406,6 +6755,11 @@ void PrintCPUStatistics(FILE *FilePtr)
   CpuTimeParallelMolFractionMoveTotal=0.0;
   CpuTimeChiralInversionMoveTotal=0.0;
   CpuTimeHybridNVEMoveTotal=0.0;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  CpuTimeAlchemicalChangeMoveTotal=0.0;
+  CpuTimeWidomOsmostatChangeMoveTotal=0.0;
+  //-------------------------------------------------------------------
   CpuTimeHybridNPHMoveTotal=0.0;
   CpuTimeHybridNPHPRMoveTotal=0.0;
   CpuTimeVolumeChangeMoveTotal=0.0;
@@ -6421,6 +6775,11 @@ void PrintCPUStatistics(FILE *FilePtr)
     CpuTimeParallelMolFractionMoveTotal+=CpuTimeParallelMolFractionMove[j];
     CpuTimeChiralInversionMoveTotal+=CpuTimeChiralInversionMove[j];
     CpuTimeHybridNVEMoveTotal+=CpuTimeHybridNVEMove[j];
+    // Added by Ambroise de Izarra
+    //-------------------------------------------------------------------
+    CpuTimeAlchemicalChangeMoveTotal+=CpuTimeAlchemicalChangeMove[j];
+    CpuTimeWidomOsmostatChangeMoveTotal+=CpuTimeWidomOsmostatChangeMove[j];
+    //-------------------------------------------------------------------
     CpuTimeHybridNPHMoveTotal+=CpuTimeHybridNPHMove[j];
     CpuTimeHybridNPHPRMoveTotal+=CpuTimeHybridNPHPRMove[j];
     CpuTimeVolumeChangeMoveTotal+=CpuTimeVolumeChangeMove[j];
@@ -6437,6 +6796,11 @@ void PrintCPUStatistics(FILE *FilePtr)
   fprintf(FilePtr,"\tmol-fraction replica-exchange: %18.10g [s]\n",CpuTimeParallelMolFractionMoveTotal);
   fprintf(FilePtr,"\tchiral inversion:              %18.10g [s]\n",CpuTimeChiralInversionMoveTotal);
   fprintf(FilePtr,"\thybrid MC/MD (NVE):            %18.10g [s]\n",CpuTimeHybridNVEMoveTotal);
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  fprintf(FilePtr,"\talchemical transformation:     %18.10g [s]\n",CpuTimeAlchemicalChangeMoveTotal);
+  fprintf(FilePtr,"\twidom osmostat:                %18.10g [s]\n",CpuTimeWidomOsmostatChangeMoveTotal);
+  //-------------------------------------------------------------------
   fprintf(FilePtr,"\thybrid MC/MD (NPH):            %18.10g [s]\n",CpuTimeHybridNPHMoveTotal);
   fprintf(FilePtr,"\thybrid MC/MD (NPHPR):          %18.10g [s]\n",CpuTimeHybridNPHPRMoveTotal);
   fprintf(FilePtr,"\tvolume change:                 %18.10g [s]\n",CpuTimeVolumeChangeMoveTotal);
@@ -7693,5 +8057,7 @@ void ReadRestartComponent(FILE *FilePtr)
     fprintf(stderr, "Error in binary restart-file (ReadRestartComponent)\n");
     ContinueAfterCrash=FALSE;
   }
-  printf("DONE!!!\n");
+  printf("DONE!!!!\n");
+
+
 }
diff --git a/src/molecule.h b/src/molecule.h
index 59fa4d4..c1c9801 100644
--- a/src/molecule.h
+++ b/src/molecule.h
@@ -39,6 +39,7 @@
 #include "simulation.h"
 #include "cubic_spline_1d.h"
 
+
 #define MAX_BOND_POTENTIAL_ARGUMENTS 20
 #define MAX_BEND_POTENTIAL_ARGUMENTS 10
 #define MAX_UREYBRADLEY_POTENTIAL_ARGUMENTS 10
@@ -546,6 +547,11 @@ typedef struct Component
   REAL ProbabilityParallelMolFractionMove;
   REAL ProbabilityChiralInversionMove;
   REAL ProbabilityHybridNVEMove;
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  REAL ProbabilityAlchemicalTransformationMove;
+  REAL ProbabilityWidomOsmostatCalculationMove;
+  //-------------------------------------------------------------------
   REAL ProbabilityHybridNPHMove;
   REAL ProbabilityHybridNPHPRMove;
   REAL ProbabilityVolumeChangeMove;
@@ -696,6 +702,11 @@ void CheckTypeOfMolecules();
 int SelectRandomMoleculeOfTypeExcludingReactionMolecules(int reaction,int **LambdaRetraceMolecules);
 int SelectRandomMoleculeOfTypeExcludingProductMolecules(int reaction,int **LambdaRetraceMolecules);
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+void SelectRandomMoleculeAlchemicalTransformation(int * OldComponent, int NumberSpecies, int CurrentAlchemicalReaction);
+//-------------------------------------------------------------------
+
 int SelectRandomMoleculeOfType(int comp);
 int SelectRandomMoleculeOfTypeExcludingFractionalMolecule(int comp);
 
@@ -708,9 +719,14 @@ int AddPseudoAtom(PSEUDO_ATOM atom);
 void ReadPseudoAtomsDefinitions(void);
 
 void AllocateComponentMemory(void);
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+void SetUpNumberMoitiesExchangedAlchemicalReaction(void);
+//-------------------------------------------------------------------
 void ReadComponentDefinition(int comp);
 
 void InsertAdsorbateMolecule(void);
+void InsertAdsorbateAlchMolecule(void);
 void RemoveAdsorbateMolecule(void);
 
 void InsertCationMolecule(void);
diff --git a/src/monte_carlo.c b/src/monte_carlo.c
index bec0d1e..9c6cc02 100644
--- a/src/monte_carlo.c
+++ b/src/monte_carlo.c
@@ -42,6 +42,7 @@
 #include "simulation.h"
 #include "molecule.h"
 #include "framework_energy.h"
+#include "Alchemical_transformation.h"
 #include "framework.h"
 #include "utils.h"
 #include "molecule.h"
@@ -126,7 +127,6 @@ void MonteCarloSimulation(void)
   SampleDcTSTConfigurationFiles(ALLOCATE);
   SamplePDBMovies(ALLOCATE,-1);
 
-
   // loop over all the pressures of the isotherm
   for(CurrentIsothermPressure=0;CurrentIsothermPressure<NumberOfIsothermPressures;CurrentIsothermPressure++)
   {
@@ -146,13 +146,37 @@ void MonteCarloSimulation(void)
 
     InitializeSmallMCStatisticsAllSystems();
     InitializeMCMovesStatisticsAllSystems();
-
+    
     // compute total energy for all systems
     CalculateTotalEnergyAllSystems();
-
+	
     CFWangLandauIteration(INITIALIZE);
     CFRXMCWangLandauIteration(INITIALIZE);
-
+	// If alchemical simulation is existing
+	
+	// Added by Ambroise de Izarra
+	//-------------------------------------------------------------------
+	if(NumberAlchemicalReactions>0)
+    {
+	  // Read the multiplicity of salt (e.g. take into account of ion ratio).
+	  SetUpNumberMoitiesExchangedAlchemicalReaction(); 
+	  // Set up vdW parameters to be evolve during Alchemical transformation.
+	  InitializeIndexManagingTransientMoities();
+	  InitializeVectorforMixingRule();
+	  InitializeVectorCharge();
+	  // Initialize the lambda pointers for alchemical transformation.
+	  InitializeLambda();
+	  // Initialize NVE-MD statistics for alchemical transformation.
+	  InitializeNVEAlchStatistics();
+
+	  if(ProbabilityWidomOsmostatCalculationMove>0.0) 
+	  {
+		InitializeStoreAlchemicalWork();
+		InitializeFileAlchemicalWork(0);
+	  }
+	}	
+	//-------------------------------------------------------------------
+	
     // initialization to reach equilibration of positions (no averages are computed yet)
     SimulationStage=POSITION_INITIALIZATION;
     for(CurrentCycle=0;CurrentCycle<NumberOfInitializationCycles;CurrentCycle++)
@@ -315,17 +339,15 @@ void MonteCarloSimulation(void)
 
     }
 
-
     // initialize the energies and compute the total energies for all systems
     InitializesEnergiesAllSystems();
     InitializesEnergyAveragesAllSystems();
-
     InitializeSmallMCStatisticsAllSystems();
     InitializeMCMovesStatisticsAllSystems();
 
     // compute total energy for all systems
     CalculateTotalEnergyAllSystems();
-
+    
     if(NumberOfEquilibrationCycles>0)
     {
       CFWangLandauIteration(INITIALIZE);
@@ -537,7 +559,7 @@ void MonteCarloSimulation(void)
 
       CalculateTotalEnergyAllSystems();
     }
-
+   
     // initialize sampling-routines at the start of the production run
     SampleRadialDistributionFunction(INITIALIZE);
     SampleProjectedLengthsDistributionFunction(INITIALIZE);
@@ -564,7 +586,6 @@ void MonteCarloSimulation(void)
 
     ClearLambdaHistogram();
 
-
     SimulationStage=PRODUCTION;
     for(CurrentCycle=0;CurrentCycle<NumberOfCycles;CurrentCycle++)
     {
@@ -608,18 +629,18 @@ void MonteCarloSimulation(void)
         for(CurrentSystem=0;CurrentSystem<NumberOfSystems;CurrentSystem++)
           PrintPropertyStatus(CurrentCycle,NumberOfCycles,OutputFilePtr[CurrentSystem]);
       }
-
+  
       // Print at 'PrintEvery' intervals the status and a restart-file
       if((CurrentCycle%PrintEvery)==0)
       {
         for(CurrentSystem=0;CurrentSystem<NumberOfSystems;CurrentSystem++)
         {
-          PrintIntervalStatusProduction(CurrentCycle,NumberOfCycles,OutputFilePtr[CurrentSystem]);
+          PrintIntervalStatusProduction(CurrentCycle,NumberOfCycles,OutputFilePtr[CurrentSystem]); 
           PrintRestartFile();
         }
       }
-
-      // select MC moves
+		 
+	  // select MC moves
       for(i=0;i<NumberOfSystems;i++)
       {
         // choose a random system
@@ -636,6 +657,7 @@ void MonteCarloSimulation(void)
         // loop over the MC 'steps' per MC 'cycle'
         for(j=0;j<NumberOfSteps;j++)
         {
+
           // set the selected system
           CurrentSystem=SelectedSystem;
 
@@ -647,9 +669,11 @@ void MonteCarloSimulation(void)
 
           // choose any of the MC moves randomly with the selected probability
           ran=RandomNumber();
-
+          
+          
           if(ran<Components[CurrentComponent].ProbabilityTranslationMove)
-          {
+          {	  
+			//printf("Translation\n");
             cpu_before=get_cpu_time();
             TranslationMove();
             cpu_after=get_cpu_time();
@@ -664,6 +688,7 @@ void MonteCarloSimulation(void)
           }
           else if(ran<Components[CurrentComponent].ProbabilityRotationMove)
           {
+			//printf("Orientation\n");
             cpu_before=get_cpu_time();
             RotationMove();
             cpu_after=get_cpu_time();
@@ -854,6 +879,30 @@ void MonteCarloSimulation(void)
             cpu_after=get_cpu_time();
             CpuTimeChiralInversionMove[CurrentSystem]+=(cpu_after-cpu_before);
           }
+          // Added by Ambroise de Izarra 
+          //-------------------------------------------------------------------
+          // (MC move for alchemical transformation)
+          //else if(ran<Components[CurrentComponent].ProbabilityAlchemicalTransformationMove)
+          //{			  
+		  //  cpu_before=get_cpu_time();
+          //  AlchemicalChangeAdsorbateMove();
+          //  cpu_after=get_cpu_time();
+          //  CpuTimeAlchemicalChangeMove[CurrentSystem]+=(cpu_after-cpu_before);
+             
+		  //}	 
+		  //-------------------------------------------------------------------
+		  
+		  // Added by Ambroise de Izarra 
+		  // (widom osmostat)
+		  //-------------------------------------------------------------------
+		  else if(ran<Components[CurrentComponent].ProbabilityWidomOsmostatCalculationMove)
+		  {
+			cpu_before=get_cpu_time();
+			WidomOsmostatCalculation();
+			cpu_after=get_cpu_time();
+			CpuTimeWidomOsmostatChangeMove[CurrentSystem]+=(cpu_after-cpu_before);
+		  }
+		  //-------------------------------------------------------------------
           else if(ran<Components[CurrentComponent].ProbabilityHybridNVEMove) 
           {
             cpu_before=get_cpu_time();
@@ -925,7 +974,6 @@ void MonteCarloSimulation(void)
         }
       }
 
-
       if(CurrentCycle%OptimizeAcceptenceEvery==0)
       {
         for(CurrentSystem=0;CurrentSystem<NumberOfSystems;CurrentSystem++)
@@ -986,7 +1034,7 @@ void MonteCarloSimulation(void)
     }
 
     SimulationStage=FINISHED;
-
+   
     for(CurrentSystem=0;CurrentSystem<NumberOfSystems;CurrentSystem++)
     {
       OptimizeVolumeChangeAcceptence();
@@ -1049,7 +1097,7 @@ void MonteCarloSimulation(void)
   // set current prssure to the last one
   CurrentIsothermPressure=NumberOfIsothermPressures-1;
 
-
+ 
   // finalize output
   SampleRadialDistributionFunction(FINALIZE);
   SampleProjectedLengthsDistributionFunction(FINALIZE);
@@ -1132,7 +1180,6 @@ void DebugEnergyStatus(void)
   REAL UHostPolarizationStored,UAdsorbatePolarizationStored,UCationPolarizationStored;
   REAL UHostBackPolarizationStored,UAdsorbateBackPolarizationStored,UCationBackPolarizationStored;
 
-
   // store all energies
   StoredUTotal=UTotal[CurrentSystem];
   StoredUTailCorrection=UTailCorrection[CurrentSystem];
diff --git a/src/run.c b/src/run.c
index f40a451..3d31f2d 100644
--- a/src/run.c
+++ b/src/run.c
@@ -256,7 +256,7 @@ char* run(char *inputData, char *inputCrystal, char *raspaDir, bool stream)
         free(FILE_CONTENTS[i]);
       }
     }
-
+  
   // Write the final positions to files
   } else {
     WriteFrameworkDefinitionCSSR("final");
@@ -318,9 +318,37 @@ char* run(char *inputData, char *inputCrystal, char *raspaDir, bool stream)
 
       free(Framework[i].Atoms[j]);
     }
+    
     free(Framework[i].Atoms);
     free(Framework[i].ExclusionMatrix);
     free(Framework[i].Neighbours);
+    // Added by Ambroise de Izarra
+    // Free memory
+    //-------------------------------------------------------------------
+    for (j = 0; j < Framework[i].NumberOfFrameworks; j++)
+    {
+		for(k = 0; k < Framework[i].pair14VDW_size[j]; k++)
+		{free(Framework[i].scaling_pair14VDW[j][k]);}
+		free(Framework[j].scaling_pair14VDW[j]);
+		
+		for(k = 0; k < Framework[i].pair14ChargeCharge_size[j]; k++)
+		{free(Framework[i].scaling_pair14ChargeCharge[j][k]);}
+		free(Framework[i].scaling_pair14ChargeCharge[j]);
+
+		//for(k = 0; k < Framework[i].list14pair_size[j]; k++)
+		//{free(Framework[i].list14pair[j][k]);}
+		free(Framework[i].list14pair[j]);    
+    }	
+    
+    free(Framework[i].scaling_pair14VDW);
+    free(Framework[i].scaling_pair14ChargeCharge);
+    free(Framework[i].list14pair);
+
+    free(Framework[i].pair14VDW_size);
+    free(Framework[i].pair14ChargeCharge_size);
+    free(Framework[i].list14pair_size);
+    //-------------------------------------------------------------------
+    
   }
 
   return output;
diff --git a/src/simulation.c b/src/simulation.c
index 5558ddd..f65473f 100644
--- a/src/simulation.c
+++ b/src/simulation.c
@@ -77,6 +77,26 @@ REAL **CFRXMCWangLandauScalingFactor;
 
 //----------------------------------------------------------------------------------------
 
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+// Alchemical transformation Parameters
+
+int NumberAlchemicalReactions;                       // Total number of Reactions
+int AlchReacLambda;                       	    	 // Number of step for chemical transformation
+REAL ProbabilityAlchReacLambdaChangeMove;            
+int **SaltIndex;                   // Reactants Stoichiometry
+int **MultiplicitySalt;								 // Tell the number of cation and anion (for charge)
+int SolventIndex;					 // The solvent to be exchanged with the salt.
+int *NumberTransientMoities;
+int **ChosenMoleculeAlchemicalTransformation;
+REAL *Lambda;										 // Parameter lambda step
+int RelaxationStepsAlchemicalTransformationMove;
+REAL ChemicalPotentialAlchemical;
+//-------------------------------------------------------------------
+
+
+
+
 int NumberOfPartialPressures;
 int CurrentPartialPressure;
 
@@ -384,6 +404,11 @@ REAL ProbabilityHyperParallelTemperingMove;
 REAL ProbabilityParallelMolFractionMove;
 REAL ProbabilityChiralInversionMove;
 REAL ProbabilityHybridNVEMove;
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+REAL ProbabilityAlchemicalTransformationMove;
+REAL ProbabilityWidomOsmostatCalculationMove;
+//-------------------------------------------------------------------
 REAL ProbabilityHybridNPHMove;
 REAL ProbabilityHybridNPHPRMove;
 REAL ProbabilityVolumeChangeMove;
@@ -402,6 +427,11 @@ REAL *CpuTimeHyperParallelTemperingMove;
 REAL *CpuTimeParallelMolFractionMove;
 REAL *CpuTimeChiralInversionMove;
 REAL *CpuTimeHybridNVEMove;
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+REAL *CpuTimeAlchemicalChangeMove;
+REAL *CpuTimeWidomOsmostatChangeMove;
+//-------------------------------------------------------------------
 REAL *CpuTimeHybridNPHMove;
 REAL *CpuTimeHybridNPHPRMove;
 REAL *CpuTimeVolumeChangeMove;
@@ -1202,6 +1232,11 @@ void AllocateSimulationMemory(void)
   CpuTimeParallelMolFractionMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
   CpuTimeChiralInversionMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
   CpuTimeHybridNVEMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  CpuTimeAlchemicalChangeMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  CpuTimeWidomOsmostatChangeMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
+  //-------------------------------------------------------------------
   CpuTimeHybridNPHMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
   CpuTimeHybridNPHPRMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
   CpuTimeVolumeChangeMove=(REAL*)calloc(NumberOfSystems,sizeof(REAL));
diff --git a/src/simulation.h b/src/simulation.h
index 1574b18..1e59a9e 100644
--- a/src/simulation.h
+++ b/src/simulation.h
@@ -109,7 +109,22 @@ extern int RXMCLambdaHistogramSize;
 extern REAL ***RXMCBiasingFactors;
 extern REAL **CFRXMCWangLandauScalingFactor;
 
-//----------------------------------------------------------------------------------------
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+// Alchemical transformation Parameters
+
+extern int NumberAlchemicalReactions;                       // Total number of Reactions
+extern int AlchReacLambda;                       	    	// Number of step for chemical transformation
+extern REAL ProbabilityAlchReacLambdaChangeMove;
+extern int **SaltIndex;                	// Reactants Stoichiometry
+extern int **MultiplicitySalt;							 	// Tell the number of cation and anion (for charge)
+extern int SolventIndex;					// The solvent to be exchanged with the salt.
+extern int *NumberTransientMoities;
+extern int **ChosenMoleculeAlchemicalTransformation;
+extern REAL *Lambda;						 				// Parameter lambda step
+extern int RelaxationStepsAlchemicalTransformationMove;      // Steps of NVE MD to relax between lambda change.
+extern REAL ChemicalPotentialAlchemical;
+//-------------------------------------------------------------------
 
 
 extern int NumberOfPartialPressures;
@@ -422,6 +437,11 @@ extern REAL ProbabilityHyperParallelTemperingMove;
 extern REAL ProbabilityParallelMolFractionMove;
 extern REAL ProbabilityChiralInversionMove;
 extern REAL ProbabilityHybridNVEMove;
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+extern REAL ProbabilityAlchemicalTransformationMove;
+extern REAL ProbabilityWidomOsmostatCalculationMove;
+//-------------------------------------------------------------------
 extern REAL ProbabilityHybridNPHMove;
 extern REAL ProbabilityHybridNPHPRMove;
 extern REAL ProbabilityVolumeChangeMove;
@@ -440,6 +460,11 @@ extern REAL *CpuTimeHyperParallelTemperingMove;
 extern REAL *CpuTimeParallelMolFractionMove;
 extern REAL *CpuTimeChiralInversionMove;
 extern REAL *CpuTimeHybridNVEMove;
+// Added by Ambroise de Izarra
+//-------------------------------------------------------------------
+extern REAL *CpuTimeAlchemicalChangeMove;
+extern REAL *CpuTimeWidomOsmostatChangeMove;
+//-------------------------------------------------------------------
 extern REAL *CpuTimeHybridNPHMove;
 extern REAL *CpuTimeHybridNPHPRMove;
 extern REAL *CpuTimeVolumeChangeMove;
@@ -461,6 +486,7 @@ extern int OptimizeCBCFLambdaChange;
 extern int OptimizeCBCFGibbsLambdaChange;
 extern int OptimizeRXMCLambdaChange;
 
+//void InitializeLambdaAlchemicalMove(void);
 void ScaleBornTerm(REAL r);
 void AddContributionToCrossTerm(int i,REAL_MATRIX CrossTerm,REAL DDF,REAL DF,VECTOR dr);
 void AddContributionToBornTerm(REAL DDF,REAL DF,VECTOR dr);
diff --git a/src/statistics.c b/src/statistics.c
index 9b7be64..5ae5d65 100644
--- a/src/statistics.c
+++ b/src/statistics.c
@@ -48,6 +48,7 @@
 #include "inter_energy.h"
 #include "framework.h"
 #include "framework_energy.h"
+#include "Alchemical_transformation.h"
 #include "ewald.h"
 #include "sample.h"
 #include "utils.h"
@@ -253,7 +254,6 @@ REAL **SurfaceAreaCount;
 VECTOR ***PrincipleMomentsOfInertiaAccumulated;
 REAL ***PrincipleMomentsOfInertiaCount;
 
-
 void AddBornTermToAverages(void)
 {
 
@@ -2842,6 +2842,16 @@ void PrintPropertyStatus(long long CurrentCycle,long long NumberOfCycles, FILE *
       fprintf(FilePtr,"\t\t(average excess chemical potential: %18.10f [K], ideal-gas contribution: %18.10f [K])\n",
             (-log(GetAverageWidomExcess(i))/Beta[CurrentSystem])*ENERGY_TO_KELVIN,
             (-log(GetAverageWidomIdealGas(i))/Beta[CurrentSystem])*ENERGY_TO_KELVIN);
+            
+      /*fprintf(FilePtr,"ideal-gas contribution: %18.10f [K])\n ideal-gas value: %18.10f [K])\n volume: %18.10f [A^3])\n inverse density: %18.10f [])\n Beta: %18.10f [])\n toto: %18.10f [])\n",
+            (-log(GetAverageWidomIdealGas(i))/Beta[CurrentSystem])*ENERGY_TO_KELVIN,
+            (-log(GetAverageInverseDensity())/Beta[CurrentSystem])*ENERGY_TO_KELVIN,
+            Volume[CurrentSystem],
+            GetAverageInverseDensity(),
+            Beta[CurrentSystem],
+            -log(GetAverageInverseDensity())/Beta[CurrentSystem],
+            );
+       */
     }
 
     if(Components[i].FractionOfGibbsWidomMove>0.0)
@@ -3900,7 +3910,7 @@ void PrintAverageTotalSystemEnergiesMC(FILE *FilePtr)
       }
 
       InverseRealMatrix(matrix);
-
+	 
       for(int k1=0;k1<NumberOfComponents;k1++)
       {
         HeatOfAdsorptionPerComponent[k1][i]=0.0;
@@ -4502,7 +4512,56 @@ void PrintAverageTotalSystemEnergiesMC(FILE *FilePtr)
     fprintf(FilePtr,"\t[%s] Average Gibbs chemical potential:   %lg +/- %lf [K]\n",
       Components[j].Name, avg, error);
   }
-
+  
+  
+  // Added by Ambroise de Izarra
+  //------------------------------------------------------------------- 
+  fprintf(FilePtr,"\n");
+  fprintf(FilePtr,"Average osmostat calibration for alchemical transformation:\n");
+  fprintf(FilePtr,"=======================================\n"); 
+   
+  if(WidomOsmostat[CurrentSystem][0]>0.0)
+  {
+		sum=sum_squared=0.0;
+		
+		REAL increase;
+		REAL wavelength_broglie_water = 0.237475478;
+		
+		int blocksize=floor(SizeAlchemicalWorkStore/NR_BLOCKS);
+
+		for(int i=0;i<NR_BLOCKS;i++)
+		{
+			increase = 0.0;
+			for(int j=0;j<blocksize;j++)
+			{	
+		        increase+= exp(-AlchemicalWorkStore[i*blocksize+j]*Beta[CurrentSystem]);
+			}
+			
+			REAL tmp=-(log(Volume[CurrentSystem]/pow(wavelength_broglie_water,3)/NumberOfAdsorbateMolecules[CurrentSystem])/Beta[CurrentSystem])*ENERGY_TO_KELVIN-(log((increase/blocksize))/Beta[CurrentSystem])*ENERGY_TO_KELVIN;
+			sum+=tmp;
+			sum_squared+=SQR(tmp);
+			fprintf(FilePtr,"\tBlock[%2d] %-lg [-]\n",i,(double)tmp);
+		}
+   }
+   else
+	{
+		for(int i=0;i<NR_BLOCKS;i++)
+		{
+			fprintf(FilePtr,"\tBlock[%2d] %-lg [-]\n",i,(double)0.0);
+		}
+    } 
+      
+    avg=AVERAGE(sum);
+    error=ERROR_CONFIDENCE_INTERVAL_95(sum,sum_squared);
+    fprintf(FilePtr,"\t------------------------------------------------------------------------------\n");
+    fprintf(FilePtr,"\tAverage osmostat calibration for alchemical transformation:   %lg +/- %lf [K]\n",
+      avg, error);
+    fprintf(FilePtr,"\tAverage osmostat calibration for alchemical transformation:   %lg +/- %lf [kJ/mol]\n",
+      avg*KELVIN_TO_KJ_PER_MOL, error*KELVIN_TO_KJ_PER_MOL);
+  //-------------------------------------------------------------------
+  
+  
+  
   // Average Gibbs Widom ideal-gas contribution
   fprintf(FilePtr,"\n");
   fprintf(FilePtr,"Average Gibbs Widom Ideal-gas contribution:\n");
@@ -5476,3 +5535,5 @@ void ReadRestartStatistics(FILE *FilePtr)
     ContinueAfterCrash=FALSE;
   }
 }
+
+
diff --git a/src/warnings.c b/src/warnings.c
index ab1dae7..998b001 100644
--- a/src/warnings.c
+++ b/src/warnings.c
@@ -76,6 +76,36 @@ void CheckForErrors(void)
       }
     }
   }
+  
+  // Added by Ambroise de Izarra
+  //-------------------------------------------------------------------
+  // Check the alchemical reactions
+  int k;
+ 
+  // Read over the chemical reactions
+  for(i=0;i<NumberAlchemicalReactions;i++)
+  {
+	// Read over the index of salt.
+	for(j=0;j<2;j++)
+	{
+		
+		// We check if the input index for the chemical transformation is present in the components.
+		if((SaltIndex[i][j]<0)||SaltIndex[i][j]>(NumberOfComponents-1))
+		{
+		        printf("ERROR: alchemical index %d is not present in the component.\n",SaltIndex[i][j]);
+				exit(0);	
+		}
+		
+		// We check if the ions are monoatomic.
+		if(Components[SaltIndex[i][j]].NumberOfAtoms>1)
+		{
+		        printf("ERROR: a salt ion is not monoatomic.\n");
+				exit(0);					
+		}	
+	} 
+  }
+
+  //-------------------------------------------------------------------
 }
 
 
-- 
2.39.2 (Apple Git-143)

